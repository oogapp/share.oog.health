/* eslint-disable */
import { DocumentTypeDecoration } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Any: { input: any; output: any; }
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: { input: any; output: any; }
  /** The builtin Map type */
  Map: { input: any; output: any; }
  /** The builtin Time type */
  Time: { input: any; output: any; }
};

export type Abstract = {
  __typename?: 'Abstract';
  label?: Maybe<Scalars['String']['output']>;
  nlmCategory?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

export type AccountConnection = Node & {
  __typename?: 'AccountConnection';
  accountID?: Maybe<Scalars['String']['output']>;
  connectionStatus: AccountConnectionConnectionStatus;
  createdAt: Scalars['Time']['output'];
  exportStatus: AccountConnectionExportStatus;
  id: Scalars['ID']['output'];
  importStatus: AccountConnectionImportStatus;
  /** The imported videos for this account connection */
  importedVideos?: Maybe<Array<ImportedVideo>>;
  /** The scrape logs for this account connection */
  instagramScrapeLogs?: Maybe<Array<InstagramScrapeLog>>;
  profilePictureURL?: Maybe<Scalars['String']['output']>;
  totalIgnored: Scalars['Int']['output'];
  totalPublished: Scalars['Int']['output'];
  /** The type of account connection */
  type: AccountConnectionType;
  updatedAt: Scalars['Time']['output'];
  /** The user that owns the account connection */
  user: User;
  userID: Scalars['ID']['output'];
  username?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of items. */
export type AccountConnectionConnection = {
  __typename?: 'AccountConnectionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccountConnectionEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** AccountConnectionConnectionStatus is enum for the field connection_status */
export enum AccountConnectionConnectionStatus {
  Connected = 'connected',
  FailedToConnect = 'failed_to_connect',
  Pending = 'pending'
}

/** An edge in a connection. */
export type AccountConnectionEdge = {
  __typename?: 'AccountConnectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AccountConnection>;
};

/** AccountConnectionExportStatus is enum for the field export_status */
export enum AccountConnectionExportStatus {
  Error = 'error',
  Idle = 'idle',
  Running = 'running'
}

/** AccountConnectionImportStatus is enum for the field import_status */
export enum AccountConnectionImportStatus {
  Complete = 'complete',
  Error = 'error',
  Running = 'running'
}

/** Ordering options for AccountConnection connections */
export type AccountConnectionOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order AccountConnections. */
  field: AccountConnectionOrderField;
};

/** Properties by which AccountConnection connections can be ordered. */
export enum AccountConnectionOrderField {
  CreatedAt = 'CREATED_AT'
}

/** AccountConnectionType is enum for the field type */
export enum AccountConnectionType {
  Instagram = 'instagram',
  Tiktok = 'tiktok',
  Youtube = 'youtube'
}

/**
 * AccountConnectionWhereInput is used for filtering AccountConnection objects.
 * Input was generated by ent.
 */
export type AccountConnectionWhereInput = {
  /** account_id field predicates */
  accountID?: InputMaybe<Scalars['String']['input']>;
  accountIDContains?: InputMaybe<Scalars['String']['input']>;
  accountIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  accountIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  accountIDGT?: InputMaybe<Scalars['String']['input']>;
  accountIDGTE?: InputMaybe<Scalars['String']['input']>;
  accountIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  accountIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  accountIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  accountIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  accountIDLT?: InputMaybe<Scalars['String']['input']>;
  accountIDLTE?: InputMaybe<Scalars['String']['input']>;
  accountIDNEQ?: InputMaybe<Scalars['String']['input']>;
  accountIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  accountIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  and?: InputMaybe<Array<AccountConnectionWhereInput>>;
  /** connection_status field predicates */
  connectionStatus?: InputMaybe<AccountConnectionConnectionStatus>;
  connectionStatusIn?: InputMaybe<Array<AccountConnectionConnectionStatus>>;
  connectionStatusNEQ?: InputMaybe<AccountConnectionConnectionStatus>;
  connectionStatusNotIn?: InputMaybe<Array<AccountConnectionConnectionStatus>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** export_status field predicates */
  exportStatus?: InputMaybe<AccountConnectionExportStatus>;
  exportStatusIn?: InputMaybe<Array<AccountConnectionExportStatus>>;
  exportStatusNEQ?: InputMaybe<AccountConnectionExportStatus>;
  exportStatusNotIn?: InputMaybe<Array<AccountConnectionExportStatus>>;
  /** imported_videos edge predicates */
  hasImportedVideos?: InputMaybe<Scalars['Boolean']['input']>;
  hasImportedVideosWith?: InputMaybe<Array<ImportedVideoWhereInput>>;
  /** instagram_scrape_logs edge predicates */
  hasInstagramScrapeLogs?: InputMaybe<Scalars['Boolean']['input']>;
  hasInstagramScrapeLogsWith?: InputMaybe<Array<InstagramScrapeLogWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** import_status field predicates */
  importStatus?: InputMaybe<AccountConnectionImportStatus>;
  importStatusIn?: InputMaybe<Array<AccountConnectionImportStatus>>;
  importStatusNEQ?: InputMaybe<AccountConnectionImportStatus>;
  importStatusNotIn?: InputMaybe<Array<AccountConnectionImportStatus>>;
  not?: InputMaybe<AccountConnectionWhereInput>;
  or?: InputMaybe<Array<AccountConnectionWhereInput>>;
  /** profile_picture_url field predicates */
  profilePictureURL?: InputMaybe<Scalars['String']['input']>;
  profilePictureURLContains?: InputMaybe<Scalars['String']['input']>;
  profilePictureURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  profilePictureURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  profilePictureURLGT?: InputMaybe<Scalars['String']['input']>;
  profilePictureURLGTE?: InputMaybe<Scalars['String']['input']>;
  profilePictureURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  profilePictureURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  profilePictureURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  profilePictureURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  profilePictureURLLT?: InputMaybe<Scalars['String']['input']>;
  profilePictureURLLTE?: InputMaybe<Scalars['String']['input']>;
  profilePictureURLNEQ?: InputMaybe<Scalars['String']['input']>;
  profilePictureURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  profilePictureURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** total_ignored field predicates */
  totalIgnored?: InputMaybe<Scalars['Int']['input']>;
  totalIgnoredGT?: InputMaybe<Scalars['Int']['input']>;
  totalIgnoredGTE?: InputMaybe<Scalars['Int']['input']>;
  totalIgnoredIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalIgnoredLT?: InputMaybe<Scalars['Int']['input']>;
  totalIgnoredLTE?: InputMaybe<Scalars['Int']['input']>;
  totalIgnoredNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalIgnoredNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** total_published field predicates */
  totalPublished?: InputMaybe<Scalars['Int']['input']>;
  totalPublishedGT?: InputMaybe<Scalars['Int']['input']>;
  totalPublishedGTE?: InputMaybe<Scalars['Int']['input']>;
  totalPublishedIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalPublishedLT?: InputMaybe<Scalars['Int']['input']>;
  totalPublishedLTE?: InputMaybe<Scalars['Int']['input']>;
  totalPublishedNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalPublishedNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** type field predicates */
  type?: InputMaybe<AccountConnectionType>;
  typeIn?: InputMaybe<Array<AccountConnectionType>>;
  typeNEQ?: InputMaybe<AccountConnectionType>;
  typeNotIn?: InputMaybe<Array<AccountConnectionType>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** username field predicates */
  username?: InputMaybe<Scalars['String']['input']>;
  usernameContains?: InputMaybe<Scalars['String']['input']>;
  usernameContainsFold?: InputMaybe<Scalars['String']['input']>;
  usernameEqualFold?: InputMaybe<Scalars['String']['input']>;
  usernameGT?: InputMaybe<Scalars['String']['input']>;
  usernameGTE?: InputMaybe<Scalars['String']['input']>;
  usernameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  usernameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  usernameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  usernameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  usernameLT?: InputMaybe<Scalars['String']['input']>;
  usernameLTE?: InputMaybe<Scalars['String']['input']>;
  usernameNEQ?: InputMaybe<Scalars['String']['input']>;
  usernameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  usernameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

/** The AdminLoginInput is used to authenticate an admin user only */
export type AdminLoginInput = {
  /** The admin user's email address */
  email: Scalars['String']['input'];
  /** The admin user's password */
  password: Scalars['String']['input'];
};

export type AdminReflectionStatValue = {
  __typename?: 'AdminReflectionStatValue';
  label?: Maybe<Scalars['String']['output']>;
  percentage?: Maybe<Scalars['String']['output']>;
  total?: Maybe<Scalars['Int']['output']>;
};

export type AdminReflectionStats = {
  __typename?: 'AdminReflectionStats';
  containsMedicalTerms?: Maybe<Array<AdminReflectionStatValue>>;
  isInquisitive?: Maybe<Array<AdminReflectionStatValue>>;
  isLinguisticallyAcceptable?: Maybe<Array<AdminReflectionStatValue>>;
  isReflective?: Maybe<Array<AdminReflectionStatValue>>;
  isToxic?: Maybe<Array<AdminReflectionStatValue>>;
  topEntityGroups?: Maybe<Array<NamedEntityStat>>;
};

export type AdminVideoCompletion = {
  __typename?: 'AdminVideoCompletion';
  completedAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
};

export type AlternatePlaylist = {
  __typename?: 'AlternatePlaylist';
  cdn: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type AnatomicalModel = Node & {
  __typename?: 'AnatomicalModel';
  createdAt: Scalars['Time']['output'];
  /** A description of the model. */
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Keywords for the model. These are used to help users find the model. */
  keywords?: Maybe<Array<Scalars['String']['output']>>;
  name: Scalars['String']['output'];
  /** The image for the 3d model. Images are hosted using Cloudflare images. Please see https://developers.cloudflare.com/images/cloudflare-images/serve-images/ for details on how to serve images. */
  renderedImage?: Maybe<Image>;
  updatedAt: Scalars['Time']['output'];
  video?: Maybe<Video>;
};

/** A connection to a list of items. */
export type AnatomicalModelConnection = {
  __typename?: 'AnatomicalModelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AnatomicalModelEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type AnatomicalModelEdge = {
  __typename?: 'AnatomicalModelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AnatomicalModel>;
};

/**
 * AnatomicalModelWhereInput is used for filtering AnatomicalModel objects.
 * Input was generated by ent.
 */
export type AnatomicalModelWhereInput = {
  and?: InputMaybe<Array<AnatomicalModelWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  hasKeywords?: InputMaybe<Array<Scalars['String']['input']>>;
  /** rendered_image edge predicates */
  hasRenderedImage?: InputMaybe<Scalars['Boolean']['input']>;
  hasRenderedImageWith?: InputMaybe<Array<ImageWhereInput>>;
  /** video edge predicates */
  hasVideo?: InputMaybe<Scalars['Boolean']['input']>;
  hasVideoWith?: InputMaybe<Array<VideoWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<AnatomicalModelWhereInput>;
  or?: InputMaybe<Array<AnatomicalModelWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type ApiQueryLog = Node & {
  __typename?: 'ApiQueryLog';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  operationName?: Maybe<Scalars['String']['output']>;
  query?: Maybe<Scalars['String']['output']>;
  /** The user that created the like. */
  user?: Maybe<User>;
  userID?: Maybe<Scalars['ID']['output']>;
  variables?: Maybe<Scalars['Map']['output']>;
};

/** A connection to a list of items. */
export type ApiQueryLogConnection = {
  __typename?: 'ApiQueryLogConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ApiQueryLogEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ApiQueryLogEdge = {
  __typename?: 'ApiQueryLogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ApiQueryLog>;
};

/** Ordering options for ApiQueryLog connections */
export type ApiQueryLogOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order ApiQueryLogs. */
  field: ApiQueryLogOrderField;
};

/** Properties by which ApiQueryLog connections can be ordered. */
export enum ApiQueryLogOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * ApiQueryLogWhereInput is used for filtering ApiQueryLog objects.
 * Input was generated by ent.
 */
export type ApiQueryLogWhereInput = {
  and?: InputMaybe<Array<ApiQueryLogWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<ApiQueryLogWhereInput>;
  /** operation_name field predicates */
  operationName?: InputMaybe<Scalars['String']['input']>;
  operationNameContains?: InputMaybe<Scalars['String']['input']>;
  operationNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  operationNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  operationNameGT?: InputMaybe<Scalars['String']['input']>;
  operationNameGTE?: InputMaybe<Scalars['String']['input']>;
  operationNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  operationNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  operationNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  operationNameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  operationNameLT?: InputMaybe<Scalars['String']['input']>;
  operationNameLTE?: InputMaybe<Scalars['String']['input']>;
  operationNameNEQ?: InputMaybe<Scalars['String']['input']>;
  operationNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  operationNameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  or?: InputMaybe<Array<ApiQueryLogWhereInput>>;
  /** query field predicates */
  query?: InputMaybe<Scalars['String']['input']>;
  queryContains?: InputMaybe<Scalars['String']['input']>;
  queryContainsFold?: InputMaybe<Scalars['String']['input']>;
  queryEqualFold?: InputMaybe<Scalars['String']['input']>;
  queryGT?: InputMaybe<Scalars['String']['input']>;
  queryGTE?: InputMaybe<Scalars['String']['input']>;
  queryHasPrefix?: InputMaybe<Scalars['String']['input']>;
  queryHasSuffix?: InputMaybe<Scalars['String']['input']>;
  queryIn?: InputMaybe<Array<Scalars['String']['input']>>;
  queryIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  queryLT?: InputMaybe<Scalars['String']['input']>;
  queryLTE?: InputMaybe<Scalars['String']['input']>;
  queryNEQ?: InputMaybe<Scalars['String']['input']>;
  queryNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  queryNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ApiToken = Node & {
  __typename?: 'ApiToken';
  createdAt: Scalars['Time']['output'];
  /** The timestamp when the token expires */
  expiresAt?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  /** The last time the token was used */
  lastUsedAt?: Maybe<Scalars['Time']['output']>;
  /** The name of the token */
  name: Scalars['String']['output'];
  /** The token used to authenticate the user */
  token: Scalars['String']['output'];
  /** The user that owns the token */
  user?: Maybe<User>;
};

/**
 * ApiTokenWhereInput is used for filtering ApiToken objects.
 * Input was generated by ent.
 */
export type ApiTokenWhereInput = {
  and?: InputMaybe<Array<ApiTokenWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** expires_at field predicates */
  expiresAt?: InputMaybe<Scalars['Time']['input']>;
  expiresAtGT?: InputMaybe<Scalars['Time']['input']>;
  expiresAtGTE?: InputMaybe<Scalars['Time']['input']>;
  expiresAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  expiresAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  expiresAtLT?: InputMaybe<Scalars['Time']['input']>;
  expiresAtLTE?: InputMaybe<Scalars['Time']['input']>;
  expiresAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  expiresAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  expiresAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_used_at field predicates */
  lastUsedAt?: InputMaybe<Scalars['Time']['input']>;
  lastUsedAtGT?: InputMaybe<Scalars['Time']['input']>;
  lastUsedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  lastUsedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastUsedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  lastUsedAtLT?: InputMaybe<Scalars['Time']['input']>;
  lastUsedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  lastUsedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  lastUsedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastUsedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ApiTokenWhereInput>;
  or?: InputMaybe<Array<ApiTokenWhereInput>>;
  /** token field predicates */
  token?: InputMaybe<Scalars['String']['input']>;
  tokenContains?: InputMaybe<Scalars['String']['input']>;
  tokenContainsFold?: InputMaybe<Scalars['String']['input']>;
  tokenEqualFold?: InputMaybe<Scalars['String']['input']>;
  tokenGT?: InputMaybe<Scalars['String']['input']>;
  tokenGTE?: InputMaybe<Scalars['String']['input']>;
  tokenHasPrefix?: InputMaybe<Scalars['String']['input']>;
  tokenHasSuffix?: InputMaybe<Scalars['String']['input']>;
  tokenIn?: InputMaybe<Array<Scalars['String']['input']>>;
  tokenLT?: InputMaybe<Scalars['String']['input']>;
  tokenLTE?: InputMaybe<Scalars['String']['input']>;
  tokenNEQ?: InputMaybe<Scalars['String']['input']>;
  tokenNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type Article = Node & {
  __typename?: 'Article';
  body?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  createdAt: Scalars['Time']['output'];
  /** The description of the article, either from the RSS feed or the opengraph meta tag */
  description?: Maybe<Scalars['String']['output']>;
  /** The main discussion points for this post */
  discussionPoints?: Maybe<Array<Scalars['String']['output']>>;
  feed?: Maybe<ArticleFeed>;
  id: Scalars['ID']['output'];
  /** The Cloudflare CDN url of the image */
  imageURL?: Maybe<Scalars['String']['output']>;
  /** The original image URL from the RSS feed or the opengraph meta tag */
  originalImageURL?: Maybe<Scalars['String']['output']>;
  post?: Maybe<Post>;
  publicationDate?: Maybe<Scalars['Time']['output']>;
  /** The raw HTML content of the article */
  rawContent?: Maybe<Scalars['String']['output']>;
  status: ArticleStatus;
  /** The AI generated summary of the article */
  summary?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  /** The topics this article is associated with */
  topics?: Maybe<Array<Topic>>;
  updatedAt: Scalars['Time']['output'];
  url: Scalars['String']['output'];
};

/** A connection to a list of items. */
export type ArticleConnection = {
  __typename?: 'ArticleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ArticleEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ArticleEdge = {
  __typename?: 'ArticleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Article>;
};

export type ArticleFeed = Node & {
  __typename?: 'ArticleFeed';
  articles?: Maybe<Array<Article>>;
  enabled: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  ignoreImages: Scalars['Boolean']['output'];
  lastUpdated?: Maybe<Scalars['Time']['output']>;
  /** The profile image for the user. Images are hosted using Cloudflare images. Please see https://developers.cloudflare.com/images/cloudflare-images/serve-images/ for details on how to serve images. */
  profileImage?: Maybe<Image>;
  rssUrls: Array<Scalars['String']['output']>;
  syntheticUser: User;
  title: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

/**
 * ArticleFeedWhereInput is used for filtering ArticleFeed objects.
 * Input was generated by ent.
 */
export type ArticleFeedWhereInput = {
  and?: InputMaybe<Array<ArticleFeedWhereInput>>;
  /** enabled field predicates */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  enabledNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** articles edge predicates */
  hasArticles?: InputMaybe<Scalars['Boolean']['input']>;
  hasArticlesWith?: InputMaybe<Array<ArticleWhereInput>>;
  /** profile_image edge predicates */
  hasProfileImage?: InputMaybe<Scalars['Boolean']['input']>;
  hasProfileImageWith?: InputMaybe<Array<ImageWhereInput>>;
  /** synthetic_user edge predicates */
  hasSyntheticUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasSyntheticUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** ignore_images field predicates */
  ignoreImages?: InputMaybe<Scalars['Boolean']['input']>;
  ignoreImagesNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** last_updated field predicates */
  lastUpdated?: InputMaybe<Scalars['Time']['input']>;
  lastUpdatedGT?: InputMaybe<Scalars['Time']['input']>;
  lastUpdatedGTE?: InputMaybe<Scalars['Time']['input']>;
  lastUpdatedIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastUpdatedIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  lastUpdatedLT?: InputMaybe<Scalars['Time']['input']>;
  lastUpdatedLTE?: InputMaybe<Scalars['Time']['input']>;
  lastUpdatedNEQ?: InputMaybe<Scalars['Time']['input']>;
  lastUpdatedNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastUpdatedNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<ArticleFeedWhereInput>;
  or?: InputMaybe<Array<ArticleFeedWhereInput>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']['input']>;
  urlContains?: InputMaybe<Scalars['String']['input']>;
  urlContainsFold?: InputMaybe<Scalars['String']['input']>;
  urlEqualFold?: InputMaybe<Scalars['String']['input']>;
  urlGT?: InputMaybe<Scalars['String']['input']>;
  urlGTE?: InputMaybe<Scalars['String']['input']>;
  urlHasPrefix?: InputMaybe<Scalars['String']['input']>;
  urlHasSuffix?: InputMaybe<Scalars['String']['input']>;
  urlIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlLT?: InputMaybe<Scalars['String']['input']>;
  urlLTE?: InputMaybe<Scalars['String']['input']>;
  urlNEQ?: InputMaybe<Scalars['String']['input']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type ArticleId = {
  __typename?: 'ArticleId';
  IdType?: Maybe<Scalars['String']['output']>;
  Value?: Maybe<Scalars['String']['output']>;
};

/** Ordering options for Article connections */
export type ArticleOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Articles. */
  field: ArticleOrderField;
};

/** Properties by which Article connections can be ordered. */
export enum ArticleOrderField {
  CreatedAt = 'CREATED_AT',
  PublicationDate = 'PUBLICATION_DATE'
}

/** ArticleStatus is enum for the field status */
export enum ArticleStatus {
  Completed = 'completed',
  Failed = 'failed',
  Generating = 'generating',
  Pending = 'pending'
}

/**
 * ArticleWhereInput is used for filtering Article objects.
 * Input was generated by ent.
 */
export type ArticleWhereInput = {
  and?: InputMaybe<Array<ArticleWhereInput>>;
  /** body field predicates */
  body?: InputMaybe<Scalars['String']['input']>;
  bodyContains?: InputMaybe<Scalars['String']['input']>;
  bodyContainsFold?: InputMaybe<Scalars['String']['input']>;
  bodyEqualFold?: InputMaybe<Scalars['String']['input']>;
  bodyGT?: InputMaybe<Scalars['String']['input']>;
  bodyGTE?: InputMaybe<Scalars['String']['input']>;
  bodyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bodyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bodyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bodyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bodyLT?: InputMaybe<Scalars['String']['input']>;
  bodyLTE?: InputMaybe<Scalars['String']['input']>;
  bodyNEQ?: InputMaybe<Scalars['String']['input']>;
  bodyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bodyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** code field predicates */
  code?: InputMaybe<Scalars['String']['input']>;
  codeContains?: InputMaybe<Scalars['String']['input']>;
  codeContainsFold?: InputMaybe<Scalars['String']['input']>;
  codeEqualFold?: InputMaybe<Scalars['String']['input']>;
  codeGT?: InputMaybe<Scalars['String']['input']>;
  codeGTE?: InputMaybe<Scalars['String']['input']>;
  codeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  codeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  codeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  codeLT?: InputMaybe<Scalars['String']['input']>;
  codeLTE?: InputMaybe<Scalars['String']['input']>;
  codeNEQ?: InputMaybe<Scalars['String']['input']>;
  codeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** feed edge predicates */
  hasFeed?: InputMaybe<Scalars['Boolean']['input']>;
  hasFeedWith?: InputMaybe<Array<ArticleFeedWhereInput>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** topics edge predicates */
  hasTopics?: InputMaybe<Scalars['Boolean']['input']>;
  hasTopicsWith?: InputMaybe<Array<TopicWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** image_url field predicates */
  imageURL?: InputMaybe<Scalars['String']['input']>;
  imageURLContains?: InputMaybe<Scalars['String']['input']>;
  imageURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  imageURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  imageURLGT?: InputMaybe<Scalars['String']['input']>;
  imageURLGTE?: InputMaybe<Scalars['String']['input']>;
  imageURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  imageURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  imageURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  imageURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  imageURLLT?: InputMaybe<Scalars['String']['input']>;
  imageURLLTE?: InputMaybe<Scalars['String']['input']>;
  imageURLNEQ?: InputMaybe<Scalars['String']['input']>;
  imageURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  imageURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<ArticleWhereInput>;
  or?: InputMaybe<Array<ArticleWhereInput>>;
  /** original_image_url field predicates */
  originalImageURL?: InputMaybe<Scalars['String']['input']>;
  originalImageURLContains?: InputMaybe<Scalars['String']['input']>;
  originalImageURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  originalImageURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  originalImageURLGT?: InputMaybe<Scalars['String']['input']>;
  originalImageURLGTE?: InputMaybe<Scalars['String']['input']>;
  originalImageURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  originalImageURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  originalImageURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  originalImageURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  originalImageURLLT?: InputMaybe<Scalars['String']['input']>;
  originalImageURLLTE?: InputMaybe<Scalars['String']['input']>;
  originalImageURLNEQ?: InputMaybe<Scalars['String']['input']>;
  originalImageURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  originalImageURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** publication_date field predicates */
  publicationDate?: InputMaybe<Scalars['Time']['input']>;
  publicationDateGT?: InputMaybe<Scalars['Time']['input']>;
  publicationDateGTE?: InputMaybe<Scalars['Time']['input']>;
  publicationDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  publicationDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  publicationDateLT?: InputMaybe<Scalars['Time']['input']>;
  publicationDateLTE?: InputMaybe<Scalars['Time']['input']>;
  publicationDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  publicationDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  publicationDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** raw_content field predicates */
  rawContent?: InputMaybe<Scalars['String']['input']>;
  rawContentContains?: InputMaybe<Scalars['String']['input']>;
  rawContentContainsFold?: InputMaybe<Scalars['String']['input']>;
  rawContentEqualFold?: InputMaybe<Scalars['String']['input']>;
  rawContentGT?: InputMaybe<Scalars['String']['input']>;
  rawContentGTE?: InputMaybe<Scalars['String']['input']>;
  rawContentHasPrefix?: InputMaybe<Scalars['String']['input']>;
  rawContentHasSuffix?: InputMaybe<Scalars['String']['input']>;
  rawContentIn?: InputMaybe<Array<Scalars['String']['input']>>;
  rawContentIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  rawContentLT?: InputMaybe<Scalars['String']['input']>;
  rawContentLTE?: InputMaybe<Scalars['String']['input']>;
  rawContentNEQ?: InputMaybe<Scalars['String']['input']>;
  rawContentNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  rawContentNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** status field predicates */
  status?: InputMaybe<ArticleStatus>;
  statusIn?: InputMaybe<Array<ArticleStatus>>;
  statusNEQ?: InputMaybe<ArticleStatus>;
  statusNotIn?: InputMaybe<Array<ArticleStatus>>;
  /** summary field predicates */
  summary?: InputMaybe<Scalars['String']['input']>;
  summaryContains?: InputMaybe<Scalars['String']['input']>;
  summaryContainsFold?: InputMaybe<Scalars['String']['input']>;
  summaryEqualFold?: InputMaybe<Scalars['String']['input']>;
  summaryGT?: InputMaybe<Scalars['String']['input']>;
  summaryGTE?: InputMaybe<Scalars['String']['input']>;
  summaryHasPrefix?: InputMaybe<Scalars['String']['input']>;
  summaryHasSuffix?: InputMaybe<Scalars['String']['input']>;
  summaryIn?: InputMaybe<Array<Scalars['String']['input']>>;
  summaryIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  summaryLT?: InputMaybe<Scalars['String']['input']>;
  summaryLTE?: InputMaybe<Scalars['String']['input']>;
  summaryNEQ?: InputMaybe<Scalars['String']['input']>;
  summaryNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  summaryNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']['input']>;
  urlContains?: InputMaybe<Scalars['String']['input']>;
  urlContainsFold?: InputMaybe<Scalars['String']['input']>;
  urlEqualFold?: InputMaybe<Scalars['String']['input']>;
  urlGT?: InputMaybe<Scalars['String']['input']>;
  urlGTE?: InputMaybe<Scalars['String']['input']>;
  urlHasPrefix?: InputMaybe<Scalars['String']['input']>;
  urlHasSuffix?: InputMaybe<Scalars['String']['input']>;
  urlIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlLT?: InputMaybe<Scalars['String']['input']>;
  urlLTE?: InputMaybe<Scalars['String']['input']>;
  urlNEQ?: InputMaybe<Scalars['String']['input']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type Audience = Node & {
  __typename?: 'Audience';
  createdAt: Scalars['Time']['output'];
  /** The rendered text designation for the audience / credit hours. Can only be used when nested inside a post. */
  designation: Scalars['String']['output'];
  /** The raw text template for the designation text that will be displayed on the certificate. Use the designation field to get the rendered text. */
  designationtemplate: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  npiTaxonomies?: Maybe<Array<NpiTaxonomy>>;
  posts?: Maybe<Array<Post>>;
  /** The tenant that the topic belongs to. */
  tenant?: Maybe<Tenant>;
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type AudienceConnection = {
  __typename?: 'AudienceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AudienceEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type AudienceEdge = {
  __typename?: 'AudienceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Audience>;
};

/** Ordering options for Audience connections */
export type AudienceOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Audiences. */
  field: AudienceOrderField;
};

/** Properties by which Audience connections can be ordered. */
export enum AudienceOrderField {
  Name = 'NAME'
}

/**
 * AudienceWhereInput is used for filtering Audience objects.
 * Input was generated by ent.
 */
export type AudienceWhereInput = {
  and?: InputMaybe<Array<AudienceWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** designationTemplate field predicates */
  designationtemplate?: InputMaybe<Scalars['String']['input']>;
  designationtemplateContains?: InputMaybe<Scalars['String']['input']>;
  designationtemplateContainsFold?: InputMaybe<Scalars['String']['input']>;
  designationtemplateEqualFold?: InputMaybe<Scalars['String']['input']>;
  designationtemplateGT?: InputMaybe<Scalars['String']['input']>;
  designationtemplateGTE?: InputMaybe<Scalars['String']['input']>;
  designationtemplateHasPrefix?: InputMaybe<Scalars['String']['input']>;
  designationtemplateHasSuffix?: InputMaybe<Scalars['String']['input']>;
  designationtemplateIn?: InputMaybe<Array<Scalars['String']['input']>>;
  designationtemplateLT?: InputMaybe<Scalars['String']['input']>;
  designationtemplateLTE?: InputMaybe<Scalars['String']['input']>;
  designationtemplateNEQ?: InputMaybe<Scalars['String']['input']>;
  designationtemplateNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** npi_taxonomies edge predicates */
  hasNpiTaxonomies?: InputMaybe<Scalars['Boolean']['input']>;
  hasNpiTaxonomiesWith?: InputMaybe<Array<NpiTaxonomyWhereInput>>;
  /** posts edge predicates */
  hasPosts?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']['input']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<AudienceWhereInput>;
  or?: InputMaybe<Array<AudienceWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type AuditLog = Node & {
  __typename?: 'AuditLog';
  action: Scalars['String']['output'];
  changes?: Maybe<Scalars['Map']['output']>;
  createdAt: Scalars['Time']['output'];
  entityID: Scalars['String']['output'];
  entityType: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  remoteAddr?: Maybe<Scalars['String']['output']>;
  /** The user who created this change */
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type AuditLogConnection = {
  __typename?: 'AuditLogConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AuditLogEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type AuditLogEdge = {
  __typename?: 'AuditLogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<AuditLog>;
};

/** Ordering options for AuditLog connections */
export type AuditLogOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order AuditLogs. */
  field: AuditLogOrderField;
};

/** Properties by which AuditLog connections can be ordered. */
export enum AuditLogOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * AuditLogWhereInput is used for filtering AuditLog objects.
 * Input was generated by ent.
 */
export type AuditLogWhereInput = {
  /** action field predicates */
  action?: InputMaybe<Scalars['String']['input']>;
  actionContains?: InputMaybe<Scalars['String']['input']>;
  actionContainsFold?: InputMaybe<Scalars['String']['input']>;
  actionEqualFold?: InputMaybe<Scalars['String']['input']>;
  actionGT?: InputMaybe<Scalars['String']['input']>;
  actionGTE?: InputMaybe<Scalars['String']['input']>;
  actionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  actionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  actionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  actionLT?: InputMaybe<Scalars['String']['input']>;
  actionLTE?: InputMaybe<Scalars['String']['input']>;
  actionNEQ?: InputMaybe<Scalars['String']['input']>;
  actionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  and?: InputMaybe<Array<AuditLogWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** entity_id field predicates */
  entityID?: InputMaybe<Scalars['String']['input']>;
  entityIDContains?: InputMaybe<Scalars['String']['input']>;
  entityIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  entityIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  entityIDGT?: InputMaybe<Scalars['String']['input']>;
  entityIDGTE?: InputMaybe<Scalars['String']['input']>;
  entityIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  entityIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  entityIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  entityIDLT?: InputMaybe<Scalars['String']['input']>;
  entityIDLTE?: InputMaybe<Scalars['String']['input']>;
  entityIDNEQ?: InputMaybe<Scalars['String']['input']>;
  entityIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** entity_type field predicates */
  entityType?: InputMaybe<Scalars['String']['input']>;
  entityTypeContains?: InputMaybe<Scalars['String']['input']>;
  entityTypeContainsFold?: InputMaybe<Scalars['String']['input']>;
  entityTypeEqualFold?: InputMaybe<Scalars['String']['input']>;
  entityTypeGT?: InputMaybe<Scalars['String']['input']>;
  entityTypeGTE?: InputMaybe<Scalars['String']['input']>;
  entityTypeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  entityTypeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  entityTypeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  entityTypeLT?: InputMaybe<Scalars['String']['input']>;
  entityTypeLTE?: InputMaybe<Scalars['String']['input']>;
  entityTypeNEQ?: InputMaybe<Scalars['String']['input']>;
  entityTypeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<AuditLogWhereInput>;
  or?: InputMaybe<Array<AuditLogWhereInput>>;
  /** remote_addr field predicates */
  remoteAddr?: InputMaybe<Scalars['String']['input']>;
  remoteAddrContains?: InputMaybe<Scalars['String']['input']>;
  remoteAddrContainsFold?: InputMaybe<Scalars['String']['input']>;
  remoteAddrEqualFold?: InputMaybe<Scalars['String']['input']>;
  remoteAddrGT?: InputMaybe<Scalars['String']['input']>;
  remoteAddrGTE?: InputMaybe<Scalars['String']['input']>;
  remoteAddrHasPrefix?: InputMaybe<Scalars['String']['input']>;
  remoteAddrHasSuffix?: InputMaybe<Scalars['String']['input']>;
  remoteAddrIn?: InputMaybe<Array<Scalars['String']['input']>>;
  remoteAddrIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  remoteAddrLT?: InputMaybe<Scalars['String']['input']>;
  remoteAddrLTE?: InputMaybe<Scalars['String']['input']>;
  remoteAddrNEQ?: InputMaybe<Scalars['String']['input']>;
  remoteAddrNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  remoteAddrNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Author = {
  __typename?: 'Author';
  affiliation?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  initials?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
};

export type BioCDocument = {
  __typename?: 'BioCDocument';
  id: Scalars['ID']['output'];
  passage?: Maybe<Array<Maybe<BioCPassage>>>;
};

export type BioCInfon = {
  __typename?: 'BioCInfon';
  key?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

export type BioCPassage = {
  __typename?: 'BioCPassage';
  infon?: Maybe<Array<Maybe<BioCInfon>>>;
  offset?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

export type BoardCertification = Node & {
  __typename?: 'BoardCertification';
  id: Scalars['ID']['output'];
  /** Name of the certifying board */
  name: Scalars['String']['output'];
  /** Sub-specialty of the certification */
  subSpecialty?: Maybe<Scalars['String']['output']>;
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type BoardCertificationConnection = {
  __typename?: 'BoardCertificationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BoardCertificationEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BoardCertificationEdge = {
  __typename?: 'BoardCertificationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<BoardCertification>;
};

/**
 * BoardCertificationWhereInput is used for filtering BoardCertification objects.
 * Input was generated by ent.
 */
export type BoardCertificationWhereInput = {
  and?: InputMaybe<Array<BoardCertificationWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<BoardCertificationWhereInput>;
  or?: InputMaybe<Array<BoardCertificationWhereInput>>;
  /** sub_specialty field predicates */
  subSpecialty?: InputMaybe<Scalars['String']['input']>;
  subSpecialtyContains?: InputMaybe<Scalars['String']['input']>;
  subSpecialtyContainsFold?: InputMaybe<Scalars['String']['input']>;
  subSpecialtyEqualFold?: InputMaybe<Scalars['String']['input']>;
  subSpecialtyGT?: InputMaybe<Scalars['String']['input']>;
  subSpecialtyGTE?: InputMaybe<Scalars['String']['input']>;
  subSpecialtyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  subSpecialtyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  subSpecialtyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  subSpecialtyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  subSpecialtyLT?: InputMaybe<Scalars['String']['input']>;
  subSpecialtyLTE?: InputMaybe<Scalars['String']['input']>;
  subSpecialtyNEQ?: InputMaybe<Scalars['String']['input']>;
  subSpecialtyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  subSpecialtyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Bookmark = Node & {
  __typename?: 'Bookmark';
  /** The time that the user bookmarked the post. */
  bookmarkedAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  /** The post that the user bookmarked. */
  post: Post;
  postID: Scalars['ID']['output'];
  /** The user that created the bookmark. */
  user: User;
  userID: Scalars['ID']['output'];
};

/** A connection to a list of items. */
export type BookmarkConnection = {
  __typename?: 'BookmarkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BookmarkEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BookmarkEdge = {
  __typename?: 'BookmarkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Bookmark>;
};

/** Ordering options for Bookmark connections */
export type BookmarkOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Bookmarks. */
  field: BookmarkOrderField;
};

/** Properties by which Bookmark connections can be ordered. */
export enum BookmarkOrderField {
  BookmarkedAt = 'BOOKMARKED_AT'
}

export type BookmarkPostInput = {
  postId: Scalars['ID']['input'];
};

/**
 * BookmarkWhereInput is used for filtering Bookmark objects.
 * Input was generated by ent.
 */
export type BookmarkWhereInput = {
  and?: InputMaybe<Array<BookmarkWhereInput>>;
  /** bookmarked_at field predicates */
  bookmarkedAt?: InputMaybe<Scalars['Time']['input']>;
  bookmarkedAtGT?: InputMaybe<Scalars['Time']['input']>;
  bookmarkedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  bookmarkedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  bookmarkedAtLT?: InputMaybe<Scalars['Time']['input']>;
  bookmarkedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  bookmarkedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  bookmarkedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<BookmarkWhereInput>;
  or?: InputMaybe<Array<BookmarkWhereInput>>;
};

export type Certificate = Node & {
  __typename?: 'Certificate';
  /** The survey answers that the certificate was redeemed for. */
  certificateSurveyAnswers?: Maybe<Array<CertificateSurveyAnswer>>;
  createdAt: Scalars['Time']['output'];
  /** The credits that the certificate was redeemed for. */
  educationCredits?: Maybe<Array<EducationCredit>>;
  id: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
  /** The url of the certificate for download. */
  url?: Maybe<Scalars['String']['output']>;
  /** The user that the certificate belongs to. */
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type CertificateConnection = {
  __typename?: 'CertificateConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CertificateEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CertificateEdge = {
  __typename?: 'CertificateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Certificate>;
};

export type CertificateSurveyAnswer = Node & {
  __typename?: 'CertificateSurveyAnswer';
  /** The answer to the question. */
  answer: Scalars['String']['output'];
  /** The certificate that the answer is for. */
  certificate?: Maybe<Certificate>;
  /** The question that the answer is for. */
  certificateSurveyQuestion?: Maybe<CertificateSurveyQuestion>;
  choice?: Maybe<CertificateSurveyQuestionChoice>;
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
  /** The user that answered the question. */
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type CertificateSurveyAnswerConnection = {
  __typename?: 'CertificateSurveyAnswerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CertificateSurveyAnswerEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CertificateSurveyAnswerEdge = {
  __typename?: 'CertificateSurveyAnswerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CertificateSurveyAnswer>;
};

/**
 * CertificateSurveyAnswerWhereInput is used for filtering CertificateSurveyAnswer objects.
 * Input was generated by ent.
 */
export type CertificateSurveyAnswerWhereInput = {
  and?: InputMaybe<Array<CertificateSurveyAnswerWhereInput>>;
  /** answer field predicates */
  answer?: InputMaybe<Scalars['String']['input']>;
  answerContains?: InputMaybe<Scalars['String']['input']>;
  answerContainsFold?: InputMaybe<Scalars['String']['input']>;
  answerEqualFold?: InputMaybe<Scalars['String']['input']>;
  answerGT?: InputMaybe<Scalars['String']['input']>;
  answerGTE?: InputMaybe<Scalars['String']['input']>;
  answerHasPrefix?: InputMaybe<Scalars['String']['input']>;
  answerHasSuffix?: InputMaybe<Scalars['String']['input']>;
  answerIn?: InputMaybe<Array<Scalars['String']['input']>>;
  answerLT?: InputMaybe<Scalars['String']['input']>;
  answerLTE?: InputMaybe<Scalars['String']['input']>;
  answerNEQ?: InputMaybe<Scalars['String']['input']>;
  answerNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** certificate edge predicates */
  hasCertificate?: InputMaybe<Scalars['Boolean']['input']>;
  /** certificate_survey_question edge predicates */
  hasCertificateSurveyQuestion?: InputMaybe<Scalars['Boolean']['input']>;
  hasCertificateSurveyQuestionWith?: InputMaybe<Array<CertificateSurveyQuestionWhereInput>>;
  hasCertificateWith?: InputMaybe<Array<CertificateWhereInput>>;
  /** choice edge predicates */
  hasChoice?: InputMaybe<Scalars['Boolean']['input']>;
  hasChoiceWith?: InputMaybe<Array<CertificateSurveyQuestionChoiceWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CertificateSurveyAnswerWhereInput>;
  or?: InputMaybe<Array<CertificateSurveyAnswerWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type CertificateSurveyQuestion = Node & {
  __typename?: 'CertificateSurveyQuestion';
  /** The choices for the question. */
  choices?: Maybe<Array<CertificateSurveyQuestionChoice>>;
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  /** The learning objective that the question is for. */
  learningObjective?: Maybe<LearningObjective>;
  /** The question to ask the user. */
  question: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
};

export type CertificateSurveyQuestionChoice = Node & {
  __typename?: 'CertificateSurveyQuestionChoice';
  /** The emoji for the choice. */
  emoji: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** The label for the choice. */
  label: Scalars['String']['output'];
  /** The question that the choice is for. */
  question?: Maybe<CertificateSurveyQuestion>;
};

/** A connection to a list of items. */
export type CertificateSurveyQuestionChoiceConnection = {
  __typename?: 'CertificateSurveyQuestionChoiceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CertificateSurveyQuestionChoiceEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CertificateSurveyQuestionChoiceEdge = {
  __typename?: 'CertificateSurveyQuestionChoiceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CertificateSurveyQuestionChoice>;
};

/**
 * CertificateSurveyQuestionChoiceWhereInput is used for filtering CertificateSurveyQuestionChoice objects.
 * Input was generated by ent.
 */
export type CertificateSurveyQuestionChoiceWhereInput = {
  and?: InputMaybe<Array<CertificateSurveyQuestionChoiceWhereInput>>;
  /** emoji field predicates */
  emoji?: InputMaybe<Scalars['String']['input']>;
  emojiContains?: InputMaybe<Scalars['String']['input']>;
  emojiContainsFold?: InputMaybe<Scalars['String']['input']>;
  emojiEqualFold?: InputMaybe<Scalars['String']['input']>;
  emojiGT?: InputMaybe<Scalars['String']['input']>;
  emojiGTE?: InputMaybe<Scalars['String']['input']>;
  emojiHasPrefix?: InputMaybe<Scalars['String']['input']>;
  emojiHasSuffix?: InputMaybe<Scalars['String']['input']>;
  emojiIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emojiLT?: InputMaybe<Scalars['String']['input']>;
  emojiLTE?: InputMaybe<Scalars['String']['input']>;
  emojiNEQ?: InputMaybe<Scalars['String']['input']>;
  emojiNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** question edge predicates */
  hasQuestion?: InputMaybe<Scalars['Boolean']['input']>;
  hasQuestionWith?: InputMaybe<Array<CertificateSurveyQuestionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']['input']>;
  labelContains?: InputMaybe<Scalars['String']['input']>;
  labelContainsFold?: InputMaybe<Scalars['String']['input']>;
  labelEqualFold?: InputMaybe<Scalars['String']['input']>;
  labelGT?: InputMaybe<Scalars['String']['input']>;
  labelGTE?: InputMaybe<Scalars['String']['input']>;
  labelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  labelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  labelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  labelLT?: InputMaybe<Scalars['String']['input']>;
  labelLTE?: InputMaybe<Scalars['String']['input']>;
  labelNEQ?: InputMaybe<Scalars['String']['input']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<CertificateSurveyQuestionChoiceWhereInput>;
  or?: InputMaybe<Array<CertificateSurveyQuestionChoiceWhereInput>>;
};

/** A connection to a list of items. */
export type CertificateSurveyQuestionConnection = {
  __typename?: 'CertificateSurveyQuestionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CertificateSurveyQuestionEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CertificateSurveyQuestionEdge = {
  __typename?: 'CertificateSurveyQuestionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CertificateSurveyQuestion>;
};

/**
 * CertificateSurveyQuestionWhereInput is used for filtering CertificateSurveyQuestion objects.
 * Input was generated by ent.
 */
export type CertificateSurveyQuestionWhereInput = {
  and?: InputMaybe<Array<CertificateSurveyQuestionWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** choices edge predicates */
  hasChoices?: InputMaybe<Scalars['Boolean']['input']>;
  hasChoicesWith?: InputMaybe<Array<CertificateSurveyQuestionChoiceWhereInput>>;
  /** learning_objective edge predicates */
  hasLearningObjective?: InputMaybe<Scalars['Boolean']['input']>;
  hasLearningObjectiveWith?: InputMaybe<Array<LearningObjectiveWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CertificateSurveyQuestionWhereInput>;
  or?: InputMaybe<Array<CertificateSurveyQuestionWhereInput>>;
  /** question field predicates */
  question?: InputMaybe<Scalars['String']['input']>;
  questionContains?: InputMaybe<Scalars['String']['input']>;
  questionContainsFold?: InputMaybe<Scalars['String']['input']>;
  questionEqualFold?: InputMaybe<Scalars['String']['input']>;
  questionGT?: InputMaybe<Scalars['String']['input']>;
  questionGTE?: InputMaybe<Scalars['String']['input']>;
  questionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  questionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  questionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  questionLT?: InputMaybe<Scalars['String']['input']>;
  questionLTE?: InputMaybe<Scalars['String']['input']>;
  questionNEQ?: InputMaybe<Scalars['String']['input']>;
  questionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * CertificateWhereInput is used for filtering Certificate objects.
 * Input was generated by ent.
 */
export type CertificateWhereInput = {
  and?: InputMaybe<Array<CertificateWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** certificate_survey_answers edge predicates */
  hasCertificateSurveyAnswers?: InputMaybe<Scalars['Boolean']['input']>;
  hasCertificateSurveyAnswersWith?: InputMaybe<Array<CertificateSurveyAnswerWhereInput>>;
  /** education_credits edge predicates */
  hasEducationCredits?: InputMaybe<Scalars['Boolean']['input']>;
  hasEducationCreditsWith?: InputMaybe<Array<EducationCreditWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CertificateWhereInput>;
  or?: InputMaybe<Array<CertificateWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']['input']>;
  urlContains?: InputMaybe<Scalars['String']['input']>;
  urlContainsFold?: InputMaybe<Scalars['String']['input']>;
  urlEqualFold?: InputMaybe<Scalars['String']['input']>;
  urlGT?: InputMaybe<Scalars['String']['input']>;
  urlGTE?: InputMaybe<Scalars['String']['input']>;
  urlHasPrefix?: InputMaybe<Scalars['String']['input']>;
  urlHasSuffix?: InputMaybe<Scalars['String']['input']>;
  urlIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  urlLT?: InputMaybe<Scalars['String']['input']>;
  urlLTE?: InputMaybe<Scalars['String']['input']>;
  urlNEQ?: InputMaybe<Scalars['String']['input']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type CertifyingBoard = Node & {
  __typename?: 'CertifyingBoard';
  id: Scalars['ID']['output'];
  /** Name of the certifying board */
  name: Scalars['String']['output'];
};

/** A connection to a list of items. */
export type CertifyingBoardConnection = {
  __typename?: 'CertifyingBoardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CertifyingBoardEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CertifyingBoardEdge = {
  __typename?: 'CertifyingBoardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CertifyingBoard>;
};

/**
 * CertifyingBoardWhereInput is used for filtering CertifyingBoard objects.
 * Input was generated by ent.
 */
export type CertifyingBoardWhereInput = {
  and?: InputMaybe<Array<CertifyingBoardWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<CertifyingBoardWhereInput>;
  or?: InputMaybe<Array<CertifyingBoardWhereInput>>;
};

export enum ChatType {
  Ask = 'Ask',
  Reflect = 'Reflect'
}

export type ClinicalTrial = Node & {
  __typename?: 'ClinicalTrial';
  completionDate?: Maybe<Scalars['Time']['output']>;
  conditions: Array<Scalars['String']['output']>;
  contacts: Array<ClinicalTrialContact>;
  createdAt: Scalars['Time']['output'];
  description: Scalars['String']['output'];
  embeddings?: Maybe<Array<ClinicalTrialEmbedding>>;
  id: Scalars['ID']['output'];
  keywords: Array<Scalars['String']['output']>;
  locations: Array<ClinicalTrialLocation>;
  nctID: Scalars['String']['output'];
  startDate?: Maybe<Scalars['Time']['output']>;
  status: Scalars['String']['output'];
  summary: Scalars['String']['output'];
  title: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
};

export type ClinicalTrialConditionCount = {
  __typename?: 'ClinicalTrialConditionCount';
  count: Scalars['Int']['output'];
  name: Scalars['String']['output'];
};

/** A connection to a list of items. */
export type ClinicalTrialConnection = {
  __typename?: 'ClinicalTrialConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ClinicalTrialEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

export type ClinicalTrialContact = {
  __typename?: 'ClinicalTrialContact';
  email?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  role?: Maybe<Scalars['String']['output']>;
};

export type ClinicalTrialDocument = Node & {
  __typename?: 'ClinicalTrialDocument';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  nctID: Scalars['String']['output'];
  processedAt?: Maybe<Scalars['Time']['output']>;
  rawBody?: Maybe<Scalars['String']['output']>;
};

/**
 * ClinicalTrialDocumentWhereInput is used for filtering ClinicalTrialDocument objects.
 * Input was generated by ent.
 */
export type ClinicalTrialDocumentWhereInput = {
  and?: InputMaybe<Array<ClinicalTrialDocumentWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** nct_id field predicates */
  nctID?: InputMaybe<Scalars['String']['input']>;
  nctIDContains?: InputMaybe<Scalars['String']['input']>;
  nctIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  nctIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  nctIDGT?: InputMaybe<Scalars['String']['input']>;
  nctIDGTE?: InputMaybe<Scalars['String']['input']>;
  nctIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nctIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nctIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nctIDLT?: InputMaybe<Scalars['String']['input']>;
  nctIDLTE?: InputMaybe<Scalars['String']['input']>;
  nctIDNEQ?: InputMaybe<Scalars['String']['input']>;
  nctIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ClinicalTrialDocumentWhereInput>;
  or?: InputMaybe<Array<ClinicalTrialDocumentWhereInput>>;
  /** processed_at field predicates */
  processedAt?: InputMaybe<Scalars['Time']['input']>;
  processedAtGT?: InputMaybe<Scalars['Time']['input']>;
  processedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  processedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  processedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  processedAtLT?: InputMaybe<Scalars['Time']['input']>;
  processedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  processedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  processedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  processedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** raw_body field predicates */
  rawBody?: InputMaybe<Scalars['String']['input']>;
  rawBodyContains?: InputMaybe<Scalars['String']['input']>;
  rawBodyContainsFold?: InputMaybe<Scalars['String']['input']>;
  rawBodyEqualFold?: InputMaybe<Scalars['String']['input']>;
  rawBodyGT?: InputMaybe<Scalars['String']['input']>;
  rawBodyGTE?: InputMaybe<Scalars['String']['input']>;
  rawBodyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  rawBodyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  rawBodyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  rawBodyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  rawBodyLT?: InputMaybe<Scalars['String']['input']>;
  rawBodyLTE?: InputMaybe<Scalars['String']['input']>;
  rawBodyNEQ?: InputMaybe<Scalars['String']['input']>;
  rawBodyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  rawBodyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An edge in a connection. */
export type ClinicalTrialEdge = {
  __typename?: 'ClinicalTrialEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ClinicalTrial>;
};

export type ClinicalTrialEmbedding = Node & {
  __typename?: 'ClinicalTrialEmbedding';
  clinicalTrial: ClinicalTrial;
  clinicalTrialID: Scalars['ID']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
};

/**
 * ClinicalTrialEmbeddingWhereInput is used for filtering ClinicalTrialEmbedding objects.
 * Input was generated by ent.
 */
export type ClinicalTrialEmbeddingWhereInput = {
  and?: InputMaybe<Array<ClinicalTrialEmbeddingWhereInput>>;
  /** clinical_trial_id field predicates */
  clinicalTrialID?: InputMaybe<Scalars['ID']['input']>;
  clinicalTrialIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  clinicalTrialIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  clinicalTrialIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** clinical_trial edge predicates */
  hasClinicalTrial?: InputMaybe<Scalars['Boolean']['input']>;
  hasClinicalTrialWith?: InputMaybe<Array<ClinicalTrialWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<ClinicalTrialEmbeddingWhereInput>;
  or?: InputMaybe<Array<ClinicalTrialEmbeddingWhereInput>>;
};

export type ClinicalTrialLocation = {
  __typename?: 'ClinicalTrialLocation';
  city?: Maybe<Scalars['String']['output']>;
  contacts?: Maybe<Array<Maybe<ClinicalTrialContact>>>;
  country?: Maybe<Scalars['String']['output']>;
  facility?: Maybe<Scalars['String']['output']>;
  latitude?: Maybe<Scalars['Float']['output']>;
  longitude?: Maybe<Scalars['Float']['output']>;
  state?: Maybe<Scalars['String']['output']>;
  status?: Maybe<Scalars['String']['output']>;
  zip?: Maybe<Scalars['String']['output']>;
};

export type ClinicalTrialMapPoint = {
  __typename?: 'ClinicalTrialMapPoint';
  id: Scalars['ID']['output'];
  lat: Scalars['Float']['output'];
  lng: Scalars['Float']['output'];
};

/** Ordering options for ClinicalTrial connections */
export type ClinicalTrialOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order ClinicalTrials. */
  field: ClinicalTrialOrderField;
};

/** Properties by which ClinicalTrial connections can be ordered. */
export enum ClinicalTrialOrderField {
  CompletionDate = 'COMPLETION_DATE',
  StartDate = 'START_DATE'
}

export type ClinicalTrialStatusCount = {
  __typename?: 'ClinicalTrialStatusCount';
  count: Scalars['Int']['output'];
  name: Scalars['String']['output'];
};

/**
 * ClinicalTrialWhereInput is used for filtering ClinicalTrial objects.
 * Input was generated by ent.
 */
export type ClinicalTrialWhereInput = {
  and?: InputMaybe<Array<ClinicalTrialWhereInput>>;
  /** completion_date field predicates */
  completionDate?: InputMaybe<Scalars['Time']['input']>;
  completionDateGT?: InputMaybe<Scalars['Time']['input']>;
  completionDateGTE?: InputMaybe<Scalars['Time']['input']>;
  completionDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completionDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  completionDateLT?: InputMaybe<Scalars['Time']['input']>;
  completionDateLTE?: InputMaybe<Scalars['Time']['input']>;
  completionDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  completionDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completionDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** embeddings edge predicates */
  hasEmbeddings?: InputMaybe<Scalars['Boolean']['input']>;
  hasEmbeddingsWith?: InputMaybe<Array<ClinicalTrialEmbeddingWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** nct_id field predicates */
  nctID?: InputMaybe<Scalars['String']['input']>;
  nctIDContains?: InputMaybe<Scalars['String']['input']>;
  nctIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  nctIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  nctIDGT?: InputMaybe<Scalars['String']['input']>;
  nctIDGTE?: InputMaybe<Scalars['String']['input']>;
  nctIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nctIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nctIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nctIDLT?: InputMaybe<Scalars['String']['input']>;
  nctIDLTE?: InputMaybe<Scalars['String']['input']>;
  nctIDNEQ?: InputMaybe<Scalars['String']['input']>;
  nctIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ClinicalTrialWhereInput>;
  or?: InputMaybe<Array<ClinicalTrialWhereInput>>;
  /** start_date field predicates */
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startDateGT?: InputMaybe<Scalars['Time']['input']>;
  startDateGTE?: InputMaybe<Scalars['Time']['input']>;
  startDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  startDateLT?: InputMaybe<Scalars['Time']['input']>;
  startDateLTE?: InputMaybe<Scalars['Time']['input']>;
  startDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  startDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** status field predicates */
  status?: InputMaybe<Scalars['String']['input']>;
  statusContains?: InputMaybe<Scalars['String']['input']>;
  statusContainsFold?: InputMaybe<Scalars['String']['input']>;
  statusEqualFold?: InputMaybe<Scalars['String']['input']>;
  statusGT?: InputMaybe<Scalars['String']['input']>;
  statusGTE?: InputMaybe<Scalars['String']['input']>;
  statusHasPrefix?: InputMaybe<Scalars['String']['input']>;
  statusHasSuffix?: InputMaybe<Scalars['String']['input']>;
  statusIn?: InputMaybe<Array<Scalars['String']['input']>>;
  statusLT?: InputMaybe<Scalars['String']['input']>;
  statusLTE?: InputMaybe<Scalars['String']['input']>;
  statusNEQ?: InputMaybe<Scalars['String']['input']>;
  statusNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** summary field predicates */
  summary?: InputMaybe<Scalars['String']['input']>;
  summaryContains?: InputMaybe<Scalars['String']['input']>;
  summaryContainsFold?: InputMaybe<Scalars['String']['input']>;
  summaryEqualFold?: InputMaybe<Scalars['String']['input']>;
  summaryGT?: InputMaybe<Scalars['String']['input']>;
  summaryGTE?: InputMaybe<Scalars['String']['input']>;
  summaryHasPrefix?: InputMaybe<Scalars['String']['input']>;
  summaryHasSuffix?: InputMaybe<Scalars['String']['input']>;
  summaryIn?: InputMaybe<Array<Scalars['String']['input']>>;
  summaryLT?: InputMaybe<Scalars['String']['input']>;
  summaryLTE?: InputMaybe<Scalars['String']['input']>;
  summaryNEQ?: InputMaybe<Scalars['String']['input']>;
  summaryNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type CloudflareUpload = Node & {
  __typename?: 'CloudflareUpload';
  completedAt?: Maybe<Scalars['Time']['output']>;
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  signedURL?: Maybe<Scalars['String']['output']>;
  status: CloudflareUploadStatus;
  storageKey?: Maybe<Scalars['String']['output']>;
  uid?: Maybe<Scalars['String']['output']>;
};

/** CloudflareUploadStatus is enum for the field status */
export enum CloudflareUploadStatus {
  Complete = 'complete',
  Failed = 'failed',
  Pending = 'pending',
  Processing = 'processing'
}

/**
 * CloudflareUploadWhereInput is used for filtering CloudflareUpload objects.
 * Input was generated by ent.
 */
export type CloudflareUploadWhereInput = {
  and?: InputMaybe<Array<CloudflareUploadWhereInput>>;
  /** completed_at field predicates */
  completedAt?: InputMaybe<Scalars['Time']['input']>;
  completedAtGT?: InputMaybe<Scalars['Time']['input']>;
  completedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  completedAtLT?: InputMaybe<Scalars['Time']['input']>;
  completedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  completedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CloudflareUploadWhereInput>;
  or?: InputMaybe<Array<CloudflareUploadWhereInput>>;
  /** signed_url field predicates */
  signedURL?: InputMaybe<Scalars['String']['input']>;
  signedURLContains?: InputMaybe<Scalars['String']['input']>;
  signedURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  signedURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  signedURLGT?: InputMaybe<Scalars['String']['input']>;
  signedURLGTE?: InputMaybe<Scalars['String']['input']>;
  signedURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  signedURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  signedURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  signedURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  signedURLLT?: InputMaybe<Scalars['String']['input']>;
  signedURLLTE?: InputMaybe<Scalars['String']['input']>;
  signedURLNEQ?: InputMaybe<Scalars['String']['input']>;
  signedURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  signedURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** status field predicates */
  status?: InputMaybe<CloudflareUploadStatus>;
  statusIn?: InputMaybe<Array<CloudflareUploadStatus>>;
  statusNEQ?: InputMaybe<CloudflareUploadStatus>;
  statusNotIn?: InputMaybe<Array<CloudflareUploadStatus>>;
  /** storage_key field predicates */
  storageKey?: InputMaybe<Scalars['String']['input']>;
  storageKeyContains?: InputMaybe<Scalars['String']['input']>;
  storageKeyContainsFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyEqualFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyGT?: InputMaybe<Scalars['String']['input']>;
  storageKeyGTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  storageKeyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  storageKeyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  storageKeyLT?: InputMaybe<Scalars['String']['input']>;
  storageKeyLTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyNEQ?: InputMaybe<Scalars['String']['input']>;
  storageKeyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  storageKeyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** uid field predicates */
  uid?: InputMaybe<Scalars['String']['input']>;
  uidContains?: InputMaybe<Scalars['String']['input']>;
  uidContainsFold?: InputMaybe<Scalars['String']['input']>;
  uidEqualFold?: InputMaybe<Scalars['String']['input']>;
  uidGT?: InputMaybe<Scalars['String']['input']>;
  uidGTE?: InputMaybe<Scalars['String']['input']>;
  uidHasPrefix?: InputMaybe<Scalars['String']['input']>;
  uidHasSuffix?: InputMaybe<Scalars['String']['input']>;
  uidIn?: InputMaybe<Array<Scalars['String']['input']>>;
  uidIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  uidLT?: InputMaybe<Scalars['String']['input']>;
  uidLTE?: InputMaybe<Scalars['String']['input']>;
  uidNEQ?: InputMaybe<Scalars['String']['input']>;
  uidNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  uidNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Collection = Node & {
  __typename?: 'Collection';
  /** The cover image of the collection. */
  cover?: Maybe<Image>;
  /** The description of the collection. */
  description?: Maybe<Scalars['String']['output']>;
  educationCredit?: Maybe<EducationCredit>;
  id: Scalars['ID']['output'];
  /** The name of the collection. */
  name: Scalars['String']['output'];
  /** The posts in the collection. */
  postcollections?: Maybe<Array<PostCollection>>;
  posts: Array<Post>;
  /** The tenant that the topic belongs to. */
  tenant?: Maybe<Tenant>;
  /** The total duration of all the posts in the collection. */
  totalDuration: Scalars['Int']['output'];
  /** The total number of posts in the collection. */
  totalPosts: Scalars['Int']['output'];
  userCompletion?: Maybe<UserCollectionCompletion>;
  /** The users that have completed the collection. */
  userCompletions?: Maybe<Array<UserCollectionCompletion>>;
};

/** A connection to a list of items. */
export type CollectionConnection = {
  __typename?: 'CollectionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CollectionEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CollectionEdge = {
  __typename?: 'CollectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Collection>;
};

/**
 * CollectionWhereInput is used for filtering Collection objects.
 * Input was generated by ent.
 */
export type CollectionWhereInput = {
  and?: InputMaybe<Array<CollectionWhereInput>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** cover edge predicates */
  hasCover?: InputMaybe<Scalars['Boolean']['input']>;
  hasCoverWith?: InputMaybe<Array<ImageWhereInput>>;
  /** postcollections edge predicates */
  hasPostcollections?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostcollectionsWith?: InputMaybe<Array<PostCollectionWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']['input']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** user_completions edge predicates */
  hasUserCompletions?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserCompletionsWith?: InputMaybe<Array<UserCollectionCompletionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<CollectionWhereInput>;
  or?: InputMaybe<Array<CollectionWhereInput>>;
  /** total_duration field predicates */
  totalDuration?: InputMaybe<Scalars['Int']['input']>;
  totalDurationGT?: InputMaybe<Scalars['Int']['input']>;
  totalDurationGTE?: InputMaybe<Scalars['Int']['input']>;
  totalDurationIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalDurationLT?: InputMaybe<Scalars['Int']['input']>;
  totalDurationLTE?: InputMaybe<Scalars['Int']['input']>;
  totalDurationNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalDurationNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** total_posts field predicates */
  totalPosts?: InputMaybe<Scalars['Int']['input']>;
  totalPostsGT?: InputMaybe<Scalars['Int']['input']>;
  totalPostsGTE?: InputMaybe<Scalars['Int']['input']>;
  totalPostsIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalPostsLT?: InputMaybe<Scalars['Int']['input']>;
  totalPostsLTE?: InputMaybe<Scalars['Int']['input']>;
  totalPostsNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalPostsNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type Comment = Node & {
  __typename?: 'Comment';
  /** The author of the comment */
  author?: Maybe<User>;
  /** Body of the comment */
  body: Scalars['String']['output'];
  commentLikes?: Maybe<Array<CommentLike>>;
  commentNamedEntities?: Maybe<Array<CommentNamedEntity>>;
  createdAt: Scalars['Time']['output'];
  /** Whether or not the credit was approved */
  creditWasApproved?: Maybe<Scalars['Boolean']['output']>;
  /** Whether or not the user earned credits for this comment */
  didEarnCredits: Scalars['Boolean']['output'];
  /** The education credit this comment earned */
  educationCredit?: Maybe<EducationCredit>;
  id: Scalars['ID']['output'];
  likedAt?: Maybe<Scalars['Time']['output']>;
  /** The users who liked this comment */
  likedUsers?: Maybe<Array<User>>;
  namedEntities?: Maybe<Array<NamedEntity>>;
  /** The replies to this comment */
  parent?: Maybe<Comment>;
  /** The post this comment belongs to */
  post?: Maybe<Post>;
  reflectionAnalysis?: Maybe<ReflectionAnalysis>;
  /** The results of the reflection analysis. Only set of the ReflectionVersion is 1 */
  reflectionAnalysisResults?: Maybe<ReflectionResult>;
  /** The reflection prompt the user chose for this comment */
  reflectionPrompt?: Maybe<Scalars['String']['output']>;
  /**
   * The version of the reflection analysis algorithm used to analyze this comment.
   *
   * Version 1 is the original version, and is synchronous and the results are available immediately.
   *  - DidEarnCredits is set to true if the comment is approved.
   *  - ReflectionAnalysisResults is set to the results of the analysis.
   *
   * Version 2 is the newest version, and is asynchronous. Poll completedAt on the ReflectionAnalysis field to see if the comment was approved.
   *  - DidEarnCredits is set to true if the comment is approved.
   *           - ReflectionAnalysisResults is NOT set
   *           - See the ReflectionAnalysis field for details on the analysis.
   *  - If the comment was not approved, use the linked SparkyChat to continue the reflective process.
   */
  reflectionVersion: Scalars['Int']['output'];
  replies?: Maybe<Array<Comment>>;
  /** The user who reviewed this comment */
  reviewedBy?: Maybe<User>;
  sentiment?: Maybe<Sentiment>;
  /** Whether or not the user should earn credits for this comment */
  shouldEarnCredits: Scalars['Boolean']['output'];
  sparkyChat?: Maybe<SparkyChat>;
  sparkyConversations?: Maybe<Array<SparkyConversation>>;
  /** The total number of likes this comment has */
  totalLikes: Scalars['Int']['output'];
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type CommentConnection = {
  __typename?: 'CommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommentEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CommentEdge = {
  __typename?: 'CommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Comment>;
};

export type CommentLike = Node & {
  __typename?: 'CommentLike';
  /** The comment that the user liked. */
  comment: Comment;
  commentID: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  /** The time that the user liked the comment.  */
  likedAt: Scalars['Time']['output'];
  /** The user that created this like. */
  user: User;
  userID: Scalars['ID']['output'];
};

/** A connection to a list of items. */
export type CommentLikeConnection = {
  __typename?: 'CommentLikeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommentLikeEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CommentLikeEdge = {
  __typename?: 'CommentLikeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<CommentLike>;
};

/** Ordering options for CommentLike connections */
export type CommentLikeOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order CommentLikes. */
  field: CommentLikeOrderField;
};

/** Properties by which CommentLike connections can be ordered. */
export enum CommentLikeOrderField {
  LikedAt = 'LIKED_AT'
}

/**
 * CommentLikeWhereInput is used for filtering CommentLike objects.
 * Input was generated by ent.
 */
export type CommentLikeWhereInput = {
  and?: InputMaybe<Array<CommentLikeWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** liked_at field predicates */
  likedAt?: InputMaybe<Scalars['Time']['input']>;
  likedAtGT?: InputMaybe<Scalars['Time']['input']>;
  likedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  likedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  likedAtLT?: InputMaybe<Scalars['Time']['input']>;
  likedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  likedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  likedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  not?: InputMaybe<CommentLikeWhereInput>;
  or?: InputMaybe<Array<CommentLikeWhereInput>>;
};

export type CommentNamedEntity = Node & {
  __typename?: 'CommentNamedEntity';
  comment?: Maybe<Comment>;
  end: Scalars['Int']['output'];
  entityGroup: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  score: Scalars['Float']['output'];
  start: Scalars['Int']['output'];
  word: Scalars['String']['output'];
};

/**
 * CommentNamedEntityWhereInput is used for filtering CommentNamedEntity objects.
 * Input was generated by ent.
 */
export type CommentNamedEntityWhereInput = {
  and?: InputMaybe<Array<CommentNamedEntityWhereInput>>;
  /** end field predicates */
  end?: InputMaybe<Scalars['Int']['input']>;
  endGT?: InputMaybe<Scalars['Int']['input']>;
  endGTE?: InputMaybe<Scalars['Int']['input']>;
  endIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  endLT?: InputMaybe<Scalars['Int']['input']>;
  endLTE?: InputMaybe<Scalars['Int']['input']>;
  endNEQ?: InputMaybe<Scalars['Int']['input']>;
  endNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** entity_group field predicates */
  entityGroup?: InputMaybe<Scalars['String']['input']>;
  entityGroupContains?: InputMaybe<Scalars['String']['input']>;
  entityGroupContainsFold?: InputMaybe<Scalars['String']['input']>;
  entityGroupEqualFold?: InputMaybe<Scalars['String']['input']>;
  entityGroupGT?: InputMaybe<Scalars['String']['input']>;
  entityGroupGTE?: InputMaybe<Scalars['String']['input']>;
  entityGroupHasPrefix?: InputMaybe<Scalars['String']['input']>;
  entityGroupHasSuffix?: InputMaybe<Scalars['String']['input']>;
  entityGroupIn?: InputMaybe<Array<Scalars['String']['input']>>;
  entityGroupLT?: InputMaybe<Scalars['String']['input']>;
  entityGroupLTE?: InputMaybe<Scalars['String']['input']>;
  entityGroupNEQ?: InputMaybe<Scalars['String']['input']>;
  entityGroupNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** comment edge predicates */
  hasComment?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommentWith?: InputMaybe<Array<CommentWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CommentNamedEntityWhereInput>;
  or?: InputMaybe<Array<CommentNamedEntityWhereInput>>;
  /** score field predicates */
  score?: InputMaybe<Scalars['Float']['input']>;
  scoreGT?: InputMaybe<Scalars['Float']['input']>;
  scoreGTE?: InputMaybe<Scalars['Float']['input']>;
  scoreIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  scoreLT?: InputMaybe<Scalars['Float']['input']>;
  scoreLTE?: InputMaybe<Scalars['Float']['input']>;
  scoreNEQ?: InputMaybe<Scalars['Float']['input']>;
  scoreNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** start field predicates */
  start?: InputMaybe<Scalars['Int']['input']>;
  startGT?: InputMaybe<Scalars['Int']['input']>;
  startGTE?: InputMaybe<Scalars['Int']['input']>;
  startIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  startLT?: InputMaybe<Scalars['Int']['input']>;
  startLTE?: InputMaybe<Scalars['Int']['input']>;
  startNEQ?: InputMaybe<Scalars['Int']['input']>;
  startNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** word field predicates */
  word?: InputMaybe<Scalars['String']['input']>;
  wordContains?: InputMaybe<Scalars['String']['input']>;
  wordContainsFold?: InputMaybe<Scalars['String']['input']>;
  wordEqualFold?: InputMaybe<Scalars['String']['input']>;
  wordGT?: InputMaybe<Scalars['String']['input']>;
  wordGTE?: InputMaybe<Scalars['String']['input']>;
  wordHasPrefix?: InputMaybe<Scalars['String']['input']>;
  wordHasSuffix?: InputMaybe<Scalars['String']['input']>;
  wordIn?: InputMaybe<Array<Scalars['String']['input']>>;
  wordLT?: InputMaybe<Scalars['String']['input']>;
  wordLTE?: InputMaybe<Scalars['String']['input']>;
  wordNEQ?: InputMaybe<Scalars['String']['input']>;
  wordNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Ordering options for Comment connections */
export type CommentOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Comments. */
  field: CommentOrderField;
};

/** Properties by which Comment connections can be ordered. */
export enum CommentOrderField {
  CreatedAt = 'CREATED_AT',
  TotalLikes = 'TOTAL_LIKES'
}

/**
 * CommentWhereInput is used for filtering Comment objects.
 * Input was generated by ent.
 */
export type CommentWhereInput = {
  and?: InputMaybe<Array<CommentWhereInput>>;
  /** body field predicates */
  body?: InputMaybe<Scalars['String']['input']>;
  bodyContains?: InputMaybe<Scalars['String']['input']>;
  bodyContainsFold?: InputMaybe<Scalars['String']['input']>;
  bodyEqualFold?: InputMaybe<Scalars['String']['input']>;
  bodyGT?: InputMaybe<Scalars['String']['input']>;
  bodyGTE?: InputMaybe<Scalars['String']['input']>;
  bodyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bodyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bodyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bodyLT?: InputMaybe<Scalars['String']['input']>;
  bodyLTE?: InputMaybe<Scalars['String']['input']>;
  bodyNEQ?: InputMaybe<Scalars['String']['input']>;
  bodyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** credit_was_approved field predicates */
  creditWasApproved?: InputMaybe<Scalars['Boolean']['input']>;
  creditWasApprovedIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  creditWasApprovedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  creditWasApprovedNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** did_earn_credits field predicates */
  didEarnCredits?: InputMaybe<Scalars['Boolean']['input']>;
  didEarnCreditsNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** author edge predicates */
  hasAuthor?: InputMaybe<Scalars['Boolean']['input']>;
  hasAuthorWith?: InputMaybe<Array<UserWhereInput>>;
  /** comment_likes edge predicates */
  hasCommentLikes?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommentLikesWith?: InputMaybe<Array<CommentLikeWhereInput>>;
  /** comment_named_entities edge predicates */
  hasCommentNamedEntities?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommentNamedEntitiesWith?: InputMaybe<Array<CommentNamedEntityWhereInput>>;
  /** education_credit edge predicates */
  hasEducationCredit?: InputMaybe<Scalars['Boolean']['input']>;
  hasEducationCreditWith?: InputMaybe<Array<EducationCreditWhereInput>>;
  /** liked_users edge predicates */
  hasLikedUsers?: InputMaybe<Scalars['Boolean']['input']>;
  hasLikedUsersWith?: InputMaybe<Array<UserWhereInput>>;
  /** parent edge predicates */
  hasParent?: InputMaybe<Scalars['Boolean']['input']>;
  hasParentWith?: InputMaybe<Array<CommentWhereInput>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** reflection_analysis edge predicates */
  hasReflectionAnalysis?: InputMaybe<Scalars['Boolean']['input']>;
  hasReflectionAnalysisWith?: InputMaybe<Array<ReflectionAnalysisWhereInput>>;
  /** replies edge predicates */
  hasReplies?: InputMaybe<Scalars['Boolean']['input']>;
  hasRepliesWith?: InputMaybe<Array<CommentWhereInput>>;
  /** reviewed_by edge predicates */
  hasReviewedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasReviewedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** sparky_chat edge predicates */
  hasSparkyChat?: InputMaybe<Scalars['Boolean']['input']>;
  hasSparkyChatWith?: InputMaybe<Array<SparkyChatWhereInput>>;
  /** sparky_conversations edge predicates */
  hasSparkyConversations?: InputMaybe<Scalars['Boolean']['input']>;
  hasSparkyConversationsWith?: InputMaybe<Array<SparkyConversationWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<CommentWhereInput>;
  or?: InputMaybe<Array<CommentWhereInput>>;
  /** reflection_prompt field predicates */
  reflectionPrompt?: InputMaybe<Scalars['String']['input']>;
  reflectionPromptContains?: InputMaybe<Scalars['String']['input']>;
  reflectionPromptContainsFold?: InputMaybe<Scalars['String']['input']>;
  reflectionPromptEqualFold?: InputMaybe<Scalars['String']['input']>;
  reflectionPromptGT?: InputMaybe<Scalars['String']['input']>;
  reflectionPromptGTE?: InputMaybe<Scalars['String']['input']>;
  reflectionPromptHasPrefix?: InputMaybe<Scalars['String']['input']>;
  reflectionPromptHasSuffix?: InputMaybe<Scalars['String']['input']>;
  reflectionPromptIn?: InputMaybe<Array<Scalars['String']['input']>>;
  reflectionPromptIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  reflectionPromptLT?: InputMaybe<Scalars['String']['input']>;
  reflectionPromptLTE?: InputMaybe<Scalars['String']['input']>;
  reflectionPromptNEQ?: InputMaybe<Scalars['String']['input']>;
  reflectionPromptNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  reflectionPromptNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** reflection_version field predicates */
  reflectionVersion?: InputMaybe<Scalars['Int']['input']>;
  reflectionVersionGT?: InputMaybe<Scalars['Int']['input']>;
  reflectionVersionGTE?: InputMaybe<Scalars['Int']['input']>;
  reflectionVersionIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  reflectionVersionLT?: InputMaybe<Scalars['Int']['input']>;
  reflectionVersionLTE?: InputMaybe<Scalars['Int']['input']>;
  reflectionVersionNEQ?: InputMaybe<Scalars['Int']['input']>;
  reflectionVersionNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** should_earn_credits field predicates */
  shouldEarnCredits?: InputMaybe<Scalars['Boolean']['input']>;
  shouldEarnCreditsNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** total_likes field predicates */
  totalLikes?: InputMaybe<Scalars['Int']['input']>;
  totalLikesGT?: InputMaybe<Scalars['Int']['input']>;
  totalLikesGTE?: InputMaybe<Scalars['Int']['input']>;
  totalLikesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalLikesLT?: InputMaybe<Scalars['Int']['input']>;
  totalLikesLTE?: InputMaybe<Scalars['Int']['input']>;
  totalLikesNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalLikesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export enum ConversationModel {
  ChatGpt = 'ChatGPT',
  OpenEvidence = 'OpenEvidence',
  Perplexity = 'Perplexity',
  Reflection = 'Reflection'
}

export type Course = Node & {
  __typename?: 'Course';
  author?: Maybe<User>;
  createdAt: Scalars['Time']['output'];
  creditHours: Scalars['Float']['output'];
  description?: Maybe<Scalars['String']['output']>;
  disclosure?: Maybe<Scalars['String']['output']>;
  faculty?: Maybe<Array<User>>;
  id: Scalars['ID']['output'];
  isRaceApproved: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  price: Scalars['Float']['output'];
  reviewedAt?: Maybe<Scalars['Time']['output']>;
  reviewedBy?: Maybe<User>;
  startDate?: Maybe<Scalars['Time']['output']>;
  status: CourseStatus;
  tenant?: Maybe<Tenant>;
  type: CourseType;
  video?: Maybe<Video>;
  website?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of items. */
export type CourseConnection = {
  __typename?: 'CourseConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CourseEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type CourseEdge = {
  __typename?: 'CourseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Course>;
};

/** CourseStatus is enum for the field status */
export enum CourseStatus {
  Approved = 'approved',
  Denied = 'denied',
  Pending = 'pending'
}

/** CourseType is enum for the field type */
export enum CourseType {
  Hybrid = 'hybrid',
  Live = 'live',
  Ondemand = 'ondemand'
}

/**
 * CourseWhereInput is used for filtering Course objects.
 * Input was generated by ent.
 */
export type CourseWhereInput = {
  and?: InputMaybe<Array<CourseWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** credit_hours field predicates */
  creditHours?: InputMaybe<Scalars['Float']['input']>;
  creditHoursGT?: InputMaybe<Scalars['Float']['input']>;
  creditHoursGTE?: InputMaybe<Scalars['Float']['input']>;
  creditHoursIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  creditHoursLT?: InputMaybe<Scalars['Float']['input']>;
  creditHoursLTE?: InputMaybe<Scalars['Float']['input']>;
  creditHoursNEQ?: InputMaybe<Scalars['Float']['input']>;
  creditHoursNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** disclosure field predicates */
  disclosure?: InputMaybe<Scalars['String']['input']>;
  disclosureContains?: InputMaybe<Scalars['String']['input']>;
  disclosureContainsFold?: InputMaybe<Scalars['String']['input']>;
  disclosureEqualFold?: InputMaybe<Scalars['String']['input']>;
  disclosureGT?: InputMaybe<Scalars['String']['input']>;
  disclosureGTE?: InputMaybe<Scalars['String']['input']>;
  disclosureHasPrefix?: InputMaybe<Scalars['String']['input']>;
  disclosureHasSuffix?: InputMaybe<Scalars['String']['input']>;
  disclosureIn?: InputMaybe<Array<Scalars['String']['input']>>;
  disclosureIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  disclosureLT?: InputMaybe<Scalars['String']['input']>;
  disclosureLTE?: InputMaybe<Scalars['String']['input']>;
  disclosureNEQ?: InputMaybe<Scalars['String']['input']>;
  disclosureNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  disclosureNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** author edge predicates */
  hasAuthor?: InputMaybe<Scalars['Boolean']['input']>;
  hasAuthorWith?: InputMaybe<Array<UserWhereInput>>;
  /** faculty edge predicates */
  hasFaculty?: InputMaybe<Scalars['Boolean']['input']>;
  hasFacultyWith?: InputMaybe<Array<UserWhereInput>>;
  /** reviewed_by edge predicates */
  hasReviewedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasReviewedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']['input']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** video edge predicates */
  hasVideo?: InputMaybe<Scalars['Boolean']['input']>;
  hasVideoWith?: InputMaybe<Array<VideoWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_race_approved field predicates */
  isRaceApproved?: InputMaybe<Scalars['Boolean']['input']>;
  isRaceApprovedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<CourseWhereInput>;
  or?: InputMaybe<Array<CourseWhereInput>>;
  /** price field predicates */
  price?: InputMaybe<Scalars['Float']['input']>;
  priceGT?: InputMaybe<Scalars['Float']['input']>;
  priceGTE?: InputMaybe<Scalars['Float']['input']>;
  priceIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  priceLT?: InputMaybe<Scalars['Float']['input']>;
  priceLTE?: InputMaybe<Scalars['Float']['input']>;
  priceNEQ?: InputMaybe<Scalars['Float']['input']>;
  priceNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** reviewed_at field predicates */
  reviewedAt?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtGT?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  reviewedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  reviewedAtLT?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  reviewedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** start_date field predicates */
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startDateGT?: InputMaybe<Scalars['Time']['input']>;
  startDateGTE?: InputMaybe<Scalars['Time']['input']>;
  startDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  startDateLT?: InputMaybe<Scalars['Time']['input']>;
  startDateLTE?: InputMaybe<Scalars['Time']['input']>;
  startDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  startDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** status field predicates */
  status?: InputMaybe<CourseStatus>;
  statusIn?: InputMaybe<Array<CourseStatus>>;
  statusNEQ?: InputMaybe<CourseStatus>;
  statusNotIn?: InputMaybe<Array<CourseStatus>>;
  /** type field predicates */
  type?: InputMaybe<CourseType>;
  typeIn?: InputMaybe<Array<CourseType>>;
  typeNEQ?: InputMaybe<CourseType>;
  typeNotIn?: InputMaybe<Array<CourseType>>;
  /** website field predicates */
  website?: InputMaybe<Scalars['String']['input']>;
  websiteContains?: InputMaybe<Scalars['String']['input']>;
  websiteContainsFold?: InputMaybe<Scalars['String']['input']>;
  websiteEqualFold?: InputMaybe<Scalars['String']['input']>;
  websiteGT?: InputMaybe<Scalars['String']['input']>;
  websiteGTE?: InputMaybe<Scalars['String']['input']>;
  websiteHasPrefix?: InputMaybe<Scalars['String']['input']>;
  websiteHasSuffix?: InputMaybe<Scalars['String']['input']>;
  websiteIn?: InputMaybe<Array<Scalars['String']['input']>>;
  websiteIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  websiteLT?: InputMaybe<Scalars['String']['input']>;
  websiteLTE?: InputMaybe<Scalars['String']['input']>;
  websiteNEQ?: InputMaybe<Scalars['String']['input']>;
  websiteNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  websiteNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * CreateAnatomicalModelInput is used for create AnatomicalModel object.
 * Input was generated by ent.
 */
export type CreateAnatomicalModelInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** A description of the model. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Keywords for the model. These are used to help users find the model. */
  keywords?: InputMaybe<Array<Scalars['String']['input']>>;
  name: Scalars['String']['input'];
  renderedImageID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  videoID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateArticleInput is used for create Article object.
 * Input was generated by ent.
 */
export type CreateArticleInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The description of the article, either from the RSS feed or the opengraph meta tag */
  description?: InputMaybe<Scalars['String']['input']>;
  feedID?: InputMaybe<Scalars['ID']['input']>;
  /** The Cloudflare CDN url of the image */
  imageURL?: InputMaybe<Scalars['String']['input']>;
  /** The original image URL from the RSS feed or the opengraph meta tag */
  originalImageURL?: InputMaybe<Scalars['String']['input']>;
  postID?: InputMaybe<Scalars['ID']['input']>;
  publicationDate?: InputMaybe<Scalars['Time']['input']>;
  /** The raw HTML content of the article */
  rawContent?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ArticleStatus>;
  /** The AI generated summary of the article */
  summary?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  topicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  url: Scalars['String']['input'];
};

/**
 * CreateAudienceInput is used for create Audience object.
 * Input was generated by ent.
 */
export type CreateAudienceInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The raw text template for the designation text that will be displayed on the certificate. Use the designation field to get the rendered text. */
  designationtemplate: Scalars['String']['input'];
  name: Scalars['String']['input'];
  npiTaxonomyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  postIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateBoardCertificationInput is used for create BoardCertification object.
 * Input was generated by ent.
 */
export type CreateBoardCertificationInput = {
  /** Name of the certifying board */
  name: Scalars['String']['input'];
  /** Sub-specialty of the certification */
  subSpecialty?: InputMaybe<Scalars['String']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateBookmarkInput is used for create Bookmark object.
 * Input was generated by ent.
 */
export type CreateBookmarkInput = {
  /** The time that the user bookmarked the post. */
  bookmarkedAt?: InputMaybe<Scalars['Time']['input']>;
  postID: Scalars['ID']['input'];
  userID: Scalars['ID']['input'];
};

export type CreateCertificateInput = {
  educationCreditIDs: Array<Scalars['ID']['input']>;
  surveyAnswers: Array<CreateCertificateSurveyAnswerInput>;
};

/**
 * CreateCertificateSurveyAnswerInput is used for create CertificateSurveyAnswer object.
 * Input was generated by ent.
 */
export type CreateCertificateSurveyAnswerInput = {
  /** The answer to the question. */
  answer: Scalars['String']['input'];
  certificateID?: InputMaybe<Scalars['ID']['input']>;
  certificateSurveyQuestionID?: InputMaybe<Scalars['ID']['input']>;
  choiceID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateCertificateSurveyQuestionChoiceInput is used for create CertificateSurveyQuestionChoice object.
 * Input was generated by ent.
 */
export type CreateCertificateSurveyQuestionChoiceInput = {
  /** The emoji for the choice. */
  emoji: Scalars['String']['input'];
  /** The label for the choice. */
  label: Scalars['String']['input'];
  questionID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateCertificateSurveyQuestionInput is used for create CertificateSurveyQuestion object.
 * Input was generated by ent.
 */
export type CreateCertificateSurveyQuestionInput = {
  choiceIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  learningObjectiveID?: InputMaybe<Scalars['ID']['input']>;
  /** The question to ask the user. */
  question: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateCertifyingBoardInput is used for create CertifyingBoard object.
 * Input was generated by ent.
 */
export type CreateCertifyingBoardInput = {
  /** Name of the certifying board */
  name: Scalars['String']['input'];
};

/**
 * CreateCollectionInput is used for create Collection object.
 * Input was generated by ent.
 */
export type CreateCollectionInput = {
  coverID?: InputMaybe<Scalars['ID']['input']>;
  /** The description of the collection. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the collection. */
  name: Scalars['String']['input'];
  postcollectionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  /** The total duration of all the posts in the collection. */
  totalDuration?: InputMaybe<Scalars['Int']['input']>;
  /** The total number of posts in the collection. */
  totalPosts?: InputMaybe<Scalars['Int']['input']>;
  userCompletionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * CreateCommentInput is used for create Comment object.
 * Input was generated by ent.
 */
export type CreateCommentInput = {
  authorID?: InputMaybe<Scalars['ID']['input']>;
  /** Body of the comment */
  body: Scalars['String']['input'];
  commentNamedEntityIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Whether or not the credit was approved */
  creditWasApproved?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not the user earned credits for this comment */
  didEarnCredits?: InputMaybe<Scalars['Boolean']['input']>;
  educationCreditID?: InputMaybe<Scalars['ID']['input']>;
  likedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  parentID?: InputMaybe<Scalars['ID']['input']>;
  postID?: InputMaybe<Scalars['ID']['input']>;
  reflectionAnalysisID?: InputMaybe<Scalars['ID']['input']>;
  /** The reflection prompt the user chose for this comment */
  reflectionPrompt?: InputMaybe<Scalars['String']['input']>;
  /**
   * The version of the reflection analysis algorithm used to analyze this comment.
   *
   * Version 1 is the original version, and is synchronous and the results are available immediately.
   *  - DidEarnCredits is set to true if the comment is approved.
   *  - ReflectionAnalysisResults is set to the results of the analysis.
   *
   * Version 2 is the newest version, and is asynchronous. Poll completedAt on the ReflectionAnalysis field to see if the comment was approved.
   *  - DidEarnCredits is set to true if the comment is approved.
   *           - ReflectionAnalysisResults is NOT set
   *           - See the ReflectionAnalysis field for details on the analysis.
   *  - If the comment was not approved, use the linked SparkyChat to continue the reflective process.
   */
  reflectionVersion?: InputMaybe<Scalars['Int']['input']>;
  replyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  reviewedByID?: InputMaybe<Scalars['ID']['input']>;
  /** Whether or not the user should earn credits for this comment */
  shouldEarnCredits?: InputMaybe<Scalars['Boolean']['input']>;
  sparkyChatID?: InputMaybe<Scalars['ID']['input']>;
  sparkyConversationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The total number of likes this comment has */
  totalLikes?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateCommentLikeInput is used for create CommentLike object.
 * Input was generated by ent.
 */
export type CreateCommentLikeInput = {
  commentID: Scalars['ID']['input'];
  /** The time that the user liked the comment.  */
  likedAt?: InputMaybe<Scalars['Time']['input']>;
  userID: Scalars['ID']['input'];
};

/**
 * CreateCourseInput is used for create Course object.
 * Input was generated by ent.
 */
export type CreateCourseInput = {
  authorID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  creditHours?: InputMaybe<Scalars['Float']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  disclosure?: InputMaybe<Scalars['String']['input']>;
  facultyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  isRaceApproved?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  price?: InputMaybe<Scalars['Float']['input']>;
  reviewedAt?: InputMaybe<Scalars['Time']['input']>;
  reviewedByID?: InputMaybe<Scalars['ID']['input']>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  status?: InputMaybe<CourseStatus>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  type?: InputMaybe<CourseType>;
  videoID?: InputMaybe<Scalars['ID']['input']>;
  website?: InputMaybe<Scalars['String']['input']>;
};

/**
 * CreateDashboardInput is used for create Dashboard object.
 * Input was generated by ent.
 */
export type CreateDashboardInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  defaultOrderBy?: InputMaybe<Scalars['String']['input']>;
  defaultOrderDirection?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  query: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateEducationCreditInput is used for create EducationCredit object.
 * Input was generated by ent.
 */
export type CreateEducationCreditInput = {
  certificateID?: InputMaybe<Scalars['ID']['input']>;
  commentID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The time that the credit was deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedByID?: InputMaybe<Scalars['ID']['input']>;
  /** The reason that the credit was deleted. */
  deletedReason?: InputMaybe<Scalars['String']['input']>;
  learningObjectiveID?: InputMaybe<Scalars['ID']['input']>;
  postID?: InputMaybe<Scalars['ID']['input']>;
  /** The time that the credit was redeemed. */
  redeemedAt?: InputMaybe<Scalars['Time']['input']>;
  sparkyConversationID?: InputMaybe<Scalars['ID']['input']>;
  /** The survey for the credit. */
  survey?: InputMaybe<Scalars['Map']['input']>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  /** The type of the credit. */
  type?: InputMaybe<EducationCreditType>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userCollectionCompletionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  userID: Scalars['ID']['input'];
  /** The value of the credit. */
  value: Scalars['Float']['input'];
  /** The version of the credit. */
  version?: InputMaybe<EducationCreditVersion>;
};

/**
 * CreateEducationHistoryInput is used for create EducationHistory object.
 * Input was generated by ent.
 */
export type CreateEducationHistoryInput = {
  /** The degree attained for this education history entry. */
  degree?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  /** The institution/school name for this education history entry. */
  institution: Scalars['String']['input'];
  /** The major for this education history entry. */
  major?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  type?: InputMaybe<EducationHistoryType>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateEducationRequirementInput is used for create EducationRequirement object.
 * Input was generated by ent.
 */
export type CreateEducationRequirementInput = {
  countryCode: Scalars['String']['input'];
  periodInYears?: InputMaybe<Scalars['Int']['input']>;
  profession?: InputMaybe<Scalars['String']['input']>;
  referenceURL?: InputMaybe<Scalars['String']['input']>;
  stateCode: Scalars['String']['input'];
  totalCmeCategoryOneRequired: Scalars['Int']['input'];
  totalCmeRequired: Scalars['Int']['input'];
};

/**
 * CreateFinancialDisclosureInput is used for create FinancialDisclosure object.
 * Input was generated by ent.
 */
export type CreateFinancialDisclosureInput = {
  /** The name of the company the user is declaring this financial disclosure for */
  companyName: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** If true, the relationship with the company has ended */
  hasEnded?: InputMaybe<Scalars['Boolean']['input']>;
  roleID: Scalars['ID']['input'];
  statementID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateFinancialDisclosurePrintTemplateInput is used for create FinancialDisclosurePrintTemplate object.
 * Input was generated by ent.
 */
export type CreateFinancialDisclosurePrintTemplateInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  template?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateFinancialDisclosureRoleInput is used for create FinancialDisclosureRole object.
 * Input was generated by ent.
 */
export type CreateFinancialDisclosureRoleInput = {
  /** If true, financial disclosures with this role will be rejected automatically */
  automaticallyReject?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  name: Scalars['String']['input'];
  /** (DEPRECATED) this value is ignored */
  requiresApproval?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateFinancialDisclosureStatementInput is used for create FinancialDisclosureStatement object.
 * Input was generated by ent.
 */
export type CreateFinancialDisclosureStatementInput = {
  /** If true, the user agrees to disclose unlabeled/unapproved users of drugs or products */
  agreesToDisclose?: InputMaybe<Scalars['Boolean']['input']>;
  /** The date the financial disclosure statement was approved (Admin Only) */
  approvedAt?: InputMaybe<Scalars['Time']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** The date the financial disclosure statement was denied (Admin Only) */
  deniedAt?: InputMaybe<Scalars['Time']['input']>;
  /** If true, the user attests that the information provided is true and accurate */
  doesAttest?: InputMaybe<Scalars['Boolean']['input']>;
  /** If true, the user has financial relationships */
  hasFinancialRelationships?: InputMaybe<Scalars['Boolean']['input']>;
  /** The initials of the user */
  initials: Scalars['String']['input'];
  relationshipIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Input for creating a relationship with a company. */
  relationships?: InputMaybe<Array<FinancialDisclosureInput>>;
  /** If true, at least one of the relationships has a role requiring approval (Admin Only) */
  requiresApproval?: InputMaybe<Scalars['Boolean']['input']>;
  /** The date the user signed the financial disclosure statement */
  signatureDate: Scalars['Time']['input'];
  /** The status of the financial disclosure statement (Admin Only) */
  status?: InputMaybe<FinancialDisclosureStatementStatus>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateGoogleDriveFileInput is used for create GoogleDriveFile object.
 * Input was generated by ent.
 */
export type CreateGoogleDriveFileInput = {
  copyCompletedAt?: InputMaybe<Scalars['Time']['input']>;
  copyErrorMessage?: InputMaybe<Scalars['String']['input']>;
  copyStartedAt?: InputMaybe<Scalars['Time']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdTime?: InputMaybe<Scalars['Time']['input']>;
  driveID: Scalars['String']['input'];
  durationMillis?: InputMaybe<Scalars['Int']['input']>;
  fileID: Scalars['String']['input'];
  folder?: InputMaybe<Scalars['String']['input']>;
  mimeType: Scalars['String']['input'];
  originalFilename: Scalars['String']['input'];
  parents?: InputMaybe<Array<Scalars['String']['input']>>;
  size?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  videoID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateLearningObjectiveInput is used for create LearningObjective object.
 * Input was generated by ent.
 */
export type CreateLearningObjectiveInput = {
  certificateSurveyQuestionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  educationCreditIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  name: Scalars['String']['input'];
  postIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  surveyQuestion?: InputMaybe<Scalars['String']['input']>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  videoIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * CreateLicenseHistoryInput is used for create LicenseHistory object.
 * Input was generated by ent.
 */
export type CreateLicenseHistoryInput = {
  endDate?: InputMaybe<Scalars['Time']['input']>;
  /** The institution that issued the license. */
  institution?: InputMaybe<Scalars['String']['input']>;
  /** The license number. */
  licenseNumber?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  /** The state in which the license was issued. */
  state?: InputMaybe<Scalars['String']['input']>;
  /** The title of the license. */
  title: Scalars['String']['input'];
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateLikeInput is used for create Like object.
 * Input was generated by ent.
 */
export type CreateLikeInput = {
  /** The time that the user liked the post.  */
  likedAt?: InputMaybe<Scalars['Time']['input']>;
  postID: Scalars['ID']['input'];
  userID: Scalars['ID']['input'];
};

/**
 * CreateMediaItemInput is used for create MediaItem object.
 * Input was generated by ent.
 */
export type CreateMediaItemInput = {
  /** The size of the media item in bytes. */
  bytes: Scalars['Int']['input'];
  /** The duration of the media item in seconds. */
  duration?: InputMaybe<Scalars['Int']['input']>;
  /** The format of the media item. ie jpg, png, gif, etc. */
  format: Scalars['String']['input'];
  /** The height of the media item in pixels. */
  height: Scalars['Int']['input'];
  /** The type of media item. Will be image or video */
  mediaType: Scalars['String']['input'];
  ordinal?: InputMaybe<Scalars['Int']['input']>;
  /** The original filename of the media item. */
  originalFilename: Scalars['String']['input'];
  postID?: InputMaybe<Scalars['ID']['input']>;
  /** [Deprecated] The public ID in Cloudinary of the media item. */
  publicID: Scalars['String']['input'];
  /** The URL of the media item. */
  url: Scalars['String']['input'];
  /** The width of the media item in pixels. */
  width: Scalars['Int']['input'];
};

/**
 * CreateNotificationConfigInput is used for create NotificationConfig object.
 * Input was generated by ent.
 */
export type CreateNotificationConfigInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The message template for follow notifications. */
  followUserMessage: Scalars['String']['input'];
  /** The message template for like notifications. */
  likedPostMessage: Scalars['String']['input'];
  /** The message template for comment notifications. */
  reflectedPostMessage: Scalars['String']['input'];
  /** The message template for reflection approved notifications. */
  reflectionApproved: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateNotificationInput is used for create Notification object.
 * Input was generated by ent.
 */
export type CreateNotificationInput = {
  /**
   * The body of the notification. This is the fully rendered message minus the user's name
   * ie. liked your post "Test Post"
   * or  reflected on your post "Test Post"
   */
  body?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  fromID?: InputMaybe<Scalars['ID']['input']>;
  imageID?: InputMaybe<Scalars['ID']['input']>;
  /** (DEPRECATED - Use body instead) The message of the notification. */
  message: Scalars['String']['input'];
  /** The type of notification. */
  notificationType?: InputMaybe<NotificationNotificationType>;
  pushSentAt?: InputMaybe<Scalars['Time']['input']>;
  /** The time that the notification was read. */
  readAt?: InputMaybe<Scalars['Time']['input']>;
  /** The ID of the resource that the notification is for. */
  resourceID: Scalars['String']['input'];
  /** The type of resource that the notification is for. */
  resourceType: Scalars['String']['input'];
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateNpiTaxonomyInput is used for create NpiTaxonomy object.
 * Input was generated by ent.
 */
export type CreateNpiTaxonomyInput = {
  audienceIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  classification: Scalars['String']['input'];
  code: Scalars['String']['input'];
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  displayName: Scalars['String']['input'];
  grouping: Scalars['String']['input'];
  specialization?: InputMaybe<Scalars['String']['input']>;
  topicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateOfficeInput is used for create Office object.
 * Input was generated by ent.
 */
export type CreateOfficeInput = {
  /** The first line of the address. Typically the street address or PO Box number. */
  address1: Scalars['String']['input'];
  /** The second line of the address. Typically the number of the apartment, suite, or unit. */
  address2?: InputMaybe<Scalars['String']['input']>;
  /** The city of the office */
  city: Scalars['String']['input'];
  /** The two-letter code for the country of the address. For example US for United States. */
  countryCode?: InputMaybe<Scalars['String']['input']>;
  /** The email address for the office */
  email?: InputMaybe<Scalars['String']['input']>;
  /** The fax number of the office. Formatted using E.164 standard. */
  fax?: InputMaybe<Scalars['String']['input']>;
  /** The phone number of the office, Formatted using E.164 standard. */
  phone?: InputMaybe<Scalars['String']['input']>;
  /** Whether the office is the primary office location. */
  primary?: InputMaybe<Scalars['Boolean']['input']>;
  /** The two-letter code for the region. For example CA for California. */
  stateCode: Scalars['String']['input'];
  userID?: InputMaybe<Scalars['ID']['input']>;
  /** The zip or postal code of the address. */
  zip: Scalars['String']['input'];
};

/** The field used to create a new PollAnswer. */
export type CreatePollAnswerInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  pollID: Scalars['ID']['input'];
  questionID: Scalars['ID']['input'];
  userID: Scalars['ID']['input'];
};

/** The field used to create a new PollAnswer. */
export type CreatePollQuestionInput = {
  pollID?: InputMaybe<Scalars['ID']['input']>;
  /** The question to ask the user. */
  question: Scalars['String']['input'];
  totalVotes?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * CreatePostCitationInput is used for create PostCitation object.
 * Input was generated by ent.
 */
export type CreatePostCitationInput = {
  /** The name of the citation. */
  name: Scalars['String']['input'];
  postID?: InputMaybe<Scalars['ID']['input']>;
  /** The url of the citation. */
  url: Scalars['String']['input'];
};

/** The field used to create a new Post. */
export type CreatePostInput = {
  accreditedLearningObjectiveID?: InputMaybe<Scalars['ID']['input']>;
  audienceIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  authorID?: InputMaybe<Scalars['ID']['input']>;
  /** Body of the post. Tags (starting with a #) and Mentions (starting with an @) are allowed */
  body: Scalars['String']['input'];
  bookmarkedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Whether this post is accredited for CE credits */
  ce?: InputMaybe<Scalars['Boolean']['input']>;
  /** The disclosure statements for this post */
  ceDisclosureStatements?: InputMaybe<Scalars['String']['input']>;
  citationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  commentIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  coverImageID?: InputMaybe<Scalars['ID']['input']>;
  /** Create a Citation for the post */
  createCitations?: InputMaybe<Array<CreatePostCitationInput>>;
  /** Create a Poll for the post */
  createPollQuestions?: InputMaybe<Array<CreatePollQuestionInput>>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The number of CE credits this post is accredited for */
  creditHours?: InputMaybe<Scalars['Float']['input']>;
  /** The main discussion points for this post. If the post has an attached sourceArticle, the discussionPoints have been copied from there and are identical.  */
  discussionPoints?: InputMaybe<Array<Scalars['String']['input']>>;
  educationCreditIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  embeddingIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Whether this post should be excluded from the feed */
  excludeFromFeed?: InputMaybe<Scalars['Boolean']['input']>;
  /** The external URL for this post. This is used for articles and other external content */
  externalURL?: InputMaybe<Scalars['String']['input']>;
  /** Whether this post is featured */
  featured?: InputMaybe<Scalars['Boolean']['input']>;
  feedHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  imageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  learningObjectiveIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  likedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  mediaItemIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  mentionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  pollID?: InputMaybe<Scalars['ID']['input']>;
  postCollectionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  postReportIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  postTagIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  reflectiveNudges?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The URL to use in the share sheet, social media or other sharing mechanisms */
  shareURL?: InputMaybe<Scalars['String']['input']>;
  sortKey?: InputMaybe<Scalars['Int']['input']>;
  sourceArticleID?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The status of the post.
   * - draft: The post is in draft mode and is only visible to the post author.
   * - published: The post is published and visible in the feed and searchable.
   * - archived: The post is archived and not visible to anyone except an admin.
   * - deleted: The post is deleted and not visible to anyone except an admin.
   * - processing: The post is being processed and is only visible to the post author.
   */
  status?: InputMaybe<PostStatus>;
  syntheticSuggestedSearches?: InputMaybe<Array<Scalars['String']['input']>>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  termFrequencies?: InputMaybe<Scalars['Map']['input']>;
  terms?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Title of the post */
  title: Scalars['String']['input'];
  topicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The trending boost of the post. */
  trendingBoost?: InputMaybe<Scalars['Float']['input']>;
  /** The type of the post */
  type?: InputMaybe<PostType>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  videoIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  wordcloud?: InputMaybe<Scalars['String']['input']>;
};

/**
 * CreatePostReactionInput is used for create PostReaction object.
 * Input was generated by ent.
 */
export type CreatePostReactionInput = {
  postID: Scalars['ID']['input'];
  /** The time that the user reacted to the post. */
  reactedAt?: InputMaybe<Scalars['Time']['input']>;
  userID: Scalars['ID']['input'];
  /** The text value of the reaction. */
  value: Scalars['String']['input'];
};

/**
 * CreatePostReportInput is used for create PostReport object.
 * Input was generated by ent.
 */
export type CreatePostReportInput = {
  authorID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The description of the user report */
  description?: InputMaybe<Scalars['String']['input']>;
  reportReasonID?: InputMaybe<Scalars['ID']['input']>;
  reportedPostID?: InputMaybe<Scalars['ID']['input']>;
  /** The time the report was reviewed */
  reviewedAt?: InputMaybe<Scalars['Time']['input']>;
  reviewedByID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreatePubmedTopicClusterInput is used for create PubmedTopicCluster object.
 * Input was generated by ent.
 */
export type CreatePubmedTopicClusterInput = {
  clusterID: Scalars['Int']['input'];
  clusterLabel: Scalars['String']['input'];
  clusterWords: Array<Scalars['String']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  pubmedArticleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  topicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * CreateReflectionCriteriaGroupInput is used for create ReflectionCriteriaGroup object.
 * Input was generated by ent.
 */
export type CreateReflectionCriteriaGroupInput = {
  criteriaIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  expression?: InputMaybe<Scalars['String']['input']>;
  facetKey?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  promptFooter?: InputMaybe<Scalars['String']['input']>;
  promptHeader?: InputMaybe<Scalars['String']['input']>;
  responseFormat?: InputMaybe<Scalars['String']['input']>;
};

/**
 * CreateReflectionCriteriaInput is used for create ReflectionCriteria object.
 * Input was generated by ent.
 */
export type CreateReflectionCriteriaInput = {
  /** The footer from the group edge, if it exists */
  cachedFooter?: InputMaybe<Scalars['String']['input']>;
  /** The header from the group edge, if it exists */
  cachedHeader?: InputMaybe<Scalars['String']['input']>;
  childIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  criteria: Scalars['String']['input'];
  criteriaAbbreviation?: InputMaybe<Scalars['String']['input']>;
  experimentID?: InputMaybe<Scalars['ID']['input']>;
  /** The facet of the criteria. Ie AACME, Oog, Developing Reflective Practice */
  facet?: InputMaybe<Scalars['String']['input']>;
  groupID?: InputMaybe<Scalars['ID']['input']>;
  /** The models for the criteria should run on. Leave empty to run on all models. */
  models?: InputMaybe<Array<Scalars['String']['input']>>;
  parentID?: InputMaybe<Scalars['ID']['input']>;
  prompt?: InputMaybe<Scalars['String']['input']>;
  /** The rubric for the criteria */
  rubric?: InputMaybe<Array<Scalars['String']['input']>>;
  scoreIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * CreateReportReasonInput is used for create ReportReason object.
 * Input was generated by ent.
 */
export type CreateReportReasonInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
};

/**
 * CreateSparkyChatConfigInput is used for create SparkyChatConfig object.
 * Input was generated by ent.
 */
export type CreateSparkyChatConfigInput = {
  copiedFromIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  copiesID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  isDefault?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  reflectionGradingExpression?: InputMaybe<Scalars['String']['input']>;
  reflectionNudgePrompt: Scalars['String']['input'];
  ruleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  suggestReflectionPrompt: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateSparkyChatInput is used for create SparkyChat object.
 * Input was generated by ent.
 */
export type CreateSparkyChatInput = {
  analysisID?: InputMaybe<Scalars['ID']['input']>;
  /** The type of chat this is. Determine how messages will be processed */
  chattype?: InputMaybe<SparkyChatChatType>;
  /** Whether or not this chat is closed. Closed chats cannot process new messages. */
  closed?: InputMaybe<Scalars['Boolean']['input']>;
  commentID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The ID of the entity this chat is associated with. */
  entityid?: InputMaybe<Scalars['Int']['input']>;
  /** The type of entity this chat is associated with. */
  entitytype?: InputMaybe<Scalars['String']['input']>;
  messageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID: Scalars['ID']['input'];
};

/**
 * CreateSparkyChatMessageInput is used for create SparkyChatMessage object.
 * Input was generated by ent.
 */
export type CreateSparkyChatMessageInput = {
  body: Scalars['String']['input'];
  chatID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  handler?: InputMaybe<Scalars['String']['input']>;
  sentBySparky: Scalars['Boolean']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * CreateSparkyConversationInput is used for create SparkyConversation object.
 * Input was generated by ent.
 */
export type CreateSparkyConversationInput = {
  /** The clinically relevant terms extracted from the conversation. */
  clinicalTerms?: InputMaybe<Scalars['Map']['input']>;
  /** The word cloud image of the clinically relevant terms extracted from the conversation. */
  clinicalTermsWordcloudURL?: InputMaybe<Scalars['String']['input']>;
  collectionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  commentID?: InputMaybe<Scalars['ID']['input']>;
  configID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Whether this is a demo conversation. */
  demo?: InputMaybe<Scalars['Boolean']['input']>;
  educationCreditID?: InputMaybe<Scalars['ID']['input']>;
  experimentRunIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  initialNudge?: InputMaybe<Scalars['String']['input']>;
  /** The medical dictionary terms extracted from the conversation. */
  medicalTerms?: InputMaybe<Scalars['Map']['input']>;
  /** The word cloud image of the medical terms extracted from the conversation. */
  medicalTermsWordcloudURL?: InputMaybe<Scalars['String']['input']>;
  messageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  postID?: InputMaybe<Scalars['ID']['input']>;
  reflectableID?: InputMaybe<Scalars['Int']['input']>;
  reflectableType?: InputMaybe<Scalars['String']['input']>;
  scoreIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The entity this conversation was started from. Used to determine which entity to link to when displaying the conversation. */
  startedFrom?: InputMaybe<SparkyConversationStartedFrom>;
  targetConversationID?: InputMaybe<Scalars['ID']['input']>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID: Scalars['ID']['input'];
  videoID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateSparkyPromptInput is used for create SparkyPrompt object.
 * Input was generated by ent.
 */
export type CreateSparkyPromptInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  isDefault?: InputMaybe<Scalars['Boolean']['input']>;
  key: Scalars['String']['input'];
  label: Scalars['String']['input'];
  prompt: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateSparkyRuleConditionInput is used for create SparkyRuleCondition object.
 * Input was generated by ent.
 */
export type CreateSparkyRuleConditionInput = {
  name: Scalars['String']['input'];
  operator: SparkyRuleConditionOperator;
  ruleID?: InputMaybe<Scalars['ID']['input']>;
  type: SparkyRuleConditionType;
  value: Scalars['String']['input'];
};

/**
 * CreateSparkyRuleInput is used for create SparkyRule object.
 * Input was generated by ent.
 */
export type CreateSparkyRuleInput = {
  conditionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  configID?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/**
 * CreateTagInput is used for create Tag object.
 * Input was generated by ent.
 */
export type CreateTagInput = {
  /** The number of posts that have this tag. */
  count?: InputMaybe<Scalars['Int']['input']>;
  taggedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The text value of the tag. */
  value: Scalars['String']['input'];
};

/**
 * CreateTopicClusterInput is used for create TopicCluster object.
 * Input was generated by ent.
 */
export type CreateTopicClusterInput = {
  clusterID: Scalars['Int']['input'];
  clusterLabel: Scalars['String']['input'];
  generatedLabel?: InputMaybe<Scalars['String']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  modelID: Scalars['String']['input'];
  wordFrequencies?: InputMaybe<Scalars['Map']['input']>;
  words: Array<Scalars['String']['input']>;
};

/**
 * CreateTopicInput is used for create Topic object.
 * Input was generated by ent.
 */
export type CreateTopicInput = {
  articleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  childIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  classificationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clusterID?: InputMaybe<Scalars['Int']['input']>;
  clusterLabel?: InputMaybe<Scalars['String']['input']>;
  coverID?: InputMaybe<Scalars['ID']['input']>;
  coverImageID?: InputMaybe<Scalars['ID']['input']>;
  generatedLabel?: InputMaybe<Scalars['String']['input']>;
  modelID?: InputMaybe<Scalars['String']['input']>;
  modelVersion?: InputMaybe<Scalars['String']['input']>;
  /** The name of the topic. */
  name?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The ordinal of the topic. */
  ordinal?: InputMaybe<Scalars['Int']['input']>;
  parentID?: InputMaybe<Scalars['ID']['input']>;
  postIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  pubmedArticleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  pubmedTopicClusterIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  /** The total number of posts that are tagged with the topic. */
  totalPosts?: InputMaybe<Scalars['Int']['input']>;
  /** The trending boost of the topic. */
  trendingBoost?: InputMaybe<Scalars['Float']['input']>;
  /** The type of the topic. */
  type?: InputMaybe<TopicType>;
  userIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  wordFrequencies?: InputMaybe<Scalars['Map']['input']>;
  words?: InputMaybe<Array<Scalars['String']['input']>>;
};

/**
 * CreateUploadInput is used for create Upload object.
 * Input was generated by ent.
 */
export type CreateUploadInput = {
  bucket: Scalars['String']['input'];
  contentType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  key: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/**
 * CreateUserBlockInput is used for create UserBlock object.
 * Input was generated by ent.
 */
export type CreateUserBlockInput = {
  blockedUserID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  ownerID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateUserCohortInput is used for create UserCohort object.
 * Input was generated by ent.
 */
export type CreateUserCohortInput = {
  name: Scalars['String']['input'];
  userIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export type CreateUserInput = {
  accountConnectionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  apiTokenIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  avatarID?: InputMaybe<Scalars['ID']['input']>;
  /** The bio of the user */
  bio?: InputMaybe<Scalars['String']['input']>;
  blockedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  boardCertificationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  bookmarkedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The city the user is located in */
  city?: InputMaybe<Scalars['String']['input']>;
  /** The CME goal date of the user */
  cmeGoalDate?: InputMaybe<Scalars['Time']['input']>;
  /** The CME goal value of the user */
  cmeGoalValue?: InputMaybe<Scalars['String']['input']>;
  cohortIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  commentIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The country the user is located in, as a 2 digit ISO code */
  country?: InputMaybe<Scalars['String']['input']>;
  coursesCreatedIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  coursesFacultyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  coursesReviewedIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The credential of the user, ie MD, DO, PA, NP, etc. Note: Credentials are normalized to uppercase and any periods are removed. */
  credential?: InputMaybe<Scalars['String']['input']>;
  /** (Deprecated, use status instead) Whether the user is disabled */
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The date of birth of the user */
  dob?: InputMaybe<Scalars['Time']['input']>;
  educationCreditIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  educationHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The email address of the user */
  email?: InputMaybe<Scalars['String']['input']>;
  feedHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  feedID?: InputMaybe<Scalars['ID']['input']>;
  financialDisclosureStatementID?: InputMaybe<Scalars['ID']['input']>;
  /** The financial disclosures for the user */
  financialDisclosures?: InputMaybe<Scalars['String']['input']>;
  /** The first name of the user */
  firstName?: InputMaybe<Scalars['String']['input']>;
  followerIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  followingIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Whether the user has disclosures needing review */
  hasDisclosuresNeedingReview?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user has submitted a disclosure */
  hasSubmittedDisclosure?: InputMaybe<Scalars['Boolean']['input']>;
  importedVideoIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Whether the user is an oog staff user */
  isStaff?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user is a student */
  isStudent?: InputMaybe<Scalars['Boolean']['input']>;
  /** The last time the user logged in */
  lastLoginAt?: InputMaybe<Scalars['Time']['input']>;
  /** The last name of the user */
  lastName?: InputMaybe<Scalars['String']['input']>;
  licenseHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  likedCommentIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  likedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The limited roles of the user. Null or Empty array means no limited roles. */
  limitedRoles?: InputMaybe<Array<Scalars['String']['input']>>;
  linkIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  mentionedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  mutedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  notificationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  notificationTokenIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The NPI number of the user */
  npiNumber?: InputMaybe<Scalars['String']['input']>;
  /** The NPI taxonomy code of the user */
  npiTaxonomyCode?: InputMaybe<Scalars['String']['input']>;
  /** The NPI taxonomy description of the user */
  npiTaxonomyDescription?: InputMaybe<Scalars['String']['input']>;
  officeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  outgoingNotificationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The password of the user, stored as a bcrypt hash */
  password?: InputMaybe<Scalars['String']['input']>;
  /** The phone number of the user, stored in E.164 format */
  phone?: InputMaybe<Scalars['String']['input']>;
  postIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  postReportIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The start date of the professional experience of the user */
  professionalExperienceStartDate?: InputMaybe<Scalars['Time']['input']>;
  profileImageID?: InputMaybe<Scalars['ID']['input']>;
  /** Whether reflections are disabled on posts authored by this user */
  reflectionsOnAuthoredPostsDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  reportedByIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The role of the user */
  role?: InputMaybe<UserRole>;
  searchIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  specialtyID?: InputMaybe<Scalars['ID']['input']>;
  /** The state or province the user is located in, as a 2 digit ISO code */
  state?: InputMaybe<Scalars['String']['input']>;
  /** The status of the user */
  status?: InputMaybe<UserStatus>;
  /** Whether the user has should appear in the suggested users list */
  suggested?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user is synthetic ie. not a human user */
  synthetic?: InputMaybe<Scalars['Boolean']['input']>;
  tenantIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  topicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The total CME earned by the user */
  totalCmeEarned?: InputMaybe<Scalars['Float']['input']>;
  /** The total number of followers the user has */
  totalFollowers?: InputMaybe<Scalars['Int']['input']>;
  /** The total number of users the user is following */
  totalFollowing?: InputMaybe<Scalars['Int']['input']>;
  /** The trending boost of the user. */
  trendingBoost?: InputMaybe<Scalars['Float']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userCompletionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  userReportIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The username of the user */
  username?: InputMaybe<Scalars['String']['input']>;
  workHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * CreateUserLinkInput is used for create UserLink object.
 * Input was generated by ent.
 */
export type CreateUserLinkInput = {
  /** The ordinal of the link. */
  ordinal?: InputMaybe<Scalars['Int']['input']>;
  /** The title of the link. */
  title: Scalars['String']['input'];
  /** The url of the link. */
  url: Scalars['String']['input'];
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateUserMuteInput is used for create UserMute object.
 * Input was generated by ent.
 */
export type CreateUserMuteInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  mutedUserID?: InputMaybe<Scalars['ID']['input']>;
  ownerID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateUserNotificationTokenInput is used for create UserNotificationToken object.
 * Input was generated by ent.
 */
export type CreateUserNotificationTokenInput = {
  /** The platform of the notification token was generated on. */
  platform: Scalars['String']['input'];
  /** The token of the notification token. */
  token: Scalars['String']['input'];
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateUserReportInput is used for create UserReport object.
 * Input was generated by ent.
 */
export type CreateUserReportInput = {
  authorID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The description of the user report */
  description?: InputMaybe<Scalars['String']['input']>;
  reportReasonID?: InputMaybe<Scalars['ID']['input']>;
  reportedUserID?: InputMaybe<Scalars['ID']['input']>;
  /** The time the report was reviewed */
  reviewedAt?: InputMaybe<Scalars['Time']['input']>;
  reviewedByID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * CreateVerificationRequestInput is used for create VerificationRequest object.
 * Input was generated by ent.
 */
export type CreateVerificationRequestInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  dob?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<VerificationRequestStatus>;
  storageKey: Scalars['String']['input'];
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  url: Scalars['String']['input'];
  userID: Scalars['ID']['input'];
  zip?: InputMaybe<Scalars['String']['input']>;
};

/**
 * CreateVideoInput is used for create Video object.
 * Input was generated by ent.
 */
export type CreateVideoInput = {
  /** The processing status of the video. */
  cloudflareUploadStatus?: InputMaybe<VideoCloudflareUploadStatus>;
  courseIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The URL of the DASH stream of the video. */
  dashURL?: InputMaybe<Scalars['String']['input']>;
  /** The duration of the video in seconds. */
  duration?: InputMaybe<Scalars['Int']['input']>;
  faceDetectionRequestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  frameIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The processing status of the video. */
  generateInsightsStatus?: InputMaybe<VideoGenerateInsightsStatus>;
  googleDriveFileID?: InputMaybe<Scalars['ID']['input']>;
  /** The height of the video in pixels. */
  height?: InputMaybe<Scalars['Int']['input']>;
  /** The URL of the HLS stream of the video. */
  hlsURL?: InputMaybe<Scalars['String']['input']>;
  imageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  importedVideoID?: InputMaybe<Scalars['ID']['input']>;
  /** The likely audience for this video */
  likelyAudience?: InputMaybe<Scalars['String']['input']>;
  postID?: InputMaybe<Scalars['ID']['input']>;
  /** The size of the video in bytes */
  size?: InputMaybe<Scalars['Int']['input']>;
  /** The media ID of the video in SpeakAI */
  speakMediaID?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the video. */
  status?: InputMaybe<VideoStatus>;
  /** The storage key of the video. */
  storageKey?: InputMaybe<Scalars['String']['input']>;
  suggestedLearningObjectiveIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  termFrequencies?: InputMaybe<Scalars['Map']['input']>;
  terms?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The number of terms per minute in the video */
  termsPerMinute?: InputMaybe<Scalars['Float']['input']>;
  /** The URL of the thumbnail image of the video. */
  thumbnailURL?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the video. */
  transcodeStatus?: InputMaybe<VideoTranscodeStatus>;
  /** The processing status of the video. */
  transcribeStatus?: InputMaybe<VideoTranscribeStatus>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userVideoEventIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The vertical DASH URL of the video. */
  verticalDashURL?: InputMaybe<Scalars['String']['input']>;
  /** The vertical height of the video in pixels. */
  verticalHeight?: InputMaybe<Scalars['Int']['input']>;
  /** The vertical HLS URL of the video. */
  verticalHlsURL?: InputMaybe<Scalars['String']['input']>;
  /** The vertical thumbnail URL of the video. */
  verticalThumbnailURL?: InputMaybe<Scalars['String']['input']>;
  /** The vertical UID of the video. */
  verticalUID?: InputMaybe<Scalars['String']['input']>;
  /** The vertical width of the video in pixels. */
  verticalWidth?: InputMaybe<Scalars['Int']['input']>;
  /** The width of the video in pixels. */
  width?: InputMaybe<Scalars['Int']['input']>;
  wordcloud?: InputMaybe<Scalars['String']['input']>;
  workflowID?: InputMaybe<Scalars['String']['input']>;
  workflowRunID?: InputMaybe<Scalars['String']['input']>;
};

/**
 * CreateWorkExperienceInput is used for create WorkExperience object.
 * Input was generated by ent.
 */
export type CreateWorkExperienceInput = {
  /** The city of the work experience. */
  city: Scalars['String']['input'];
  /** The employment type of the work experience. */
  employment?: InputMaybe<WorkExperienceEmployment>;
  /** The end date of the work experience. */
  endDate?: InputMaybe<Scalars['Time']['input']>;
  /** The institution of the work experience. */
  institution: Scalars['String']['input'];
  /** The specialty of the work experience. */
  specialty: Scalars['String']['input'];
  /** The start date of the work experience. */
  startDate?: InputMaybe<Scalars['Time']['input']>;
  /** The state of the work experience. */
  state: Scalars['String']['input'];
  /** The title of the work experience. */
  title?: InputMaybe<Scalars['String']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

export type Dashboard = Node & {
  __typename?: 'Dashboard';
  createdAt: Scalars['Time']['output'];
  defaultOrderBy?: Maybe<Scalars['String']['output']>;
  defaultOrderDirection?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  query: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type DashboardConnection = {
  __typename?: 'DashboardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DashboardEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DashboardEdge = {
  __typename?: 'DashboardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Dashboard>;
};

/**
 * DashboardWhereInput is used for filtering Dashboard objects.
 * Input was generated by ent.
 */
export type DashboardWhereInput = {
  and?: InputMaybe<Array<DashboardWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** default_order_by field predicates */
  defaultOrderBy?: InputMaybe<Scalars['String']['input']>;
  defaultOrderByContains?: InputMaybe<Scalars['String']['input']>;
  defaultOrderByContainsFold?: InputMaybe<Scalars['String']['input']>;
  defaultOrderByEqualFold?: InputMaybe<Scalars['String']['input']>;
  defaultOrderByGT?: InputMaybe<Scalars['String']['input']>;
  defaultOrderByGTE?: InputMaybe<Scalars['String']['input']>;
  defaultOrderByHasPrefix?: InputMaybe<Scalars['String']['input']>;
  defaultOrderByHasSuffix?: InputMaybe<Scalars['String']['input']>;
  defaultOrderByIn?: InputMaybe<Array<Scalars['String']['input']>>;
  defaultOrderByIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  defaultOrderByLT?: InputMaybe<Scalars['String']['input']>;
  defaultOrderByLTE?: InputMaybe<Scalars['String']['input']>;
  defaultOrderByNEQ?: InputMaybe<Scalars['String']['input']>;
  defaultOrderByNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  defaultOrderByNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** default_order_direction field predicates */
  defaultOrderDirection?: InputMaybe<Scalars['String']['input']>;
  defaultOrderDirectionContains?: InputMaybe<Scalars['String']['input']>;
  defaultOrderDirectionContainsFold?: InputMaybe<Scalars['String']['input']>;
  defaultOrderDirectionEqualFold?: InputMaybe<Scalars['String']['input']>;
  defaultOrderDirectionGT?: InputMaybe<Scalars['String']['input']>;
  defaultOrderDirectionGTE?: InputMaybe<Scalars['String']['input']>;
  defaultOrderDirectionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  defaultOrderDirectionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  defaultOrderDirectionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  defaultOrderDirectionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  defaultOrderDirectionLT?: InputMaybe<Scalars['String']['input']>;
  defaultOrderDirectionLTE?: InputMaybe<Scalars['String']['input']>;
  defaultOrderDirectionNEQ?: InputMaybe<Scalars['String']['input']>;
  defaultOrderDirectionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  defaultOrderDirectionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<DashboardWhereInput>;
  or?: InputMaybe<Array<DashboardWhereInput>>;
  /** query field predicates */
  query?: InputMaybe<Scalars['String']['input']>;
  queryContains?: InputMaybe<Scalars['String']['input']>;
  queryContainsFold?: InputMaybe<Scalars['String']['input']>;
  queryEqualFold?: InputMaybe<Scalars['String']['input']>;
  queryGT?: InputMaybe<Scalars['String']['input']>;
  queryGTE?: InputMaybe<Scalars['String']['input']>;
  queryHasPrefix?: InputMaybe<Scalars['String']['input']>;
  queryHasSuffix?: InputMaybe<Scalars['String']['input']>;
  queryIn?: InputMaybe<Array<Scalars['String']['input']>>;
  queryLT?: InputMaybe<Scalars['String']['input']>;
  queryLTE?: InputMaybe<Scalars['String']['input']>;
  queryNEQ?: InputMaybe<Scalars['String']['input']>;
  queryNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type DownloadFinancialDisclosureStatement = {
  __typename?: 'DownloadFinancialDisclosureStatement';
  url: Scalars['String']['output'];
};

export type DriveImportData = {
  __typename?: 'DriveImportData';
  driveId: Scalars['String']['output'];
  durationMillis: Scalars['Int']['output'];
  id: Scalars['String']['output'];
  mimeType: Scalars['String']['output'];
  originalFilename: Scalars['String']['output'];
  parents: Array<Scalars['String']['output']>;
};

export type EducationCredit = Node & {
  __typename?: 'EducationCredit';
  /** The certificate that the credit was redeemed for. */
  certificate?: Maybe<Certificate>;
  /** The comment that the credit was created on. */
  comment?: Maybe<Comment>;
  commentID?: Maybe<Scalars['ID']['output']>;
  createdAt: Scalars['Time']['output'];
  /** The time that the credit was deleted. */
  deletedAt?: Maybe<Scalars['Time']['output']>;
  /** The user that deleted the credit. */
  deletedBy?: Maybe<User>;
  /** The reason that the credit was deleted. */
  deletedReason?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The learning objective that the credit was for. */
  learningObjective?: Maybe<LearningObjective>;
  /** The post that the credit was created on. */
  post?: Maybe<Post>;
  postID?: Maybe<Scalars['ID']['output']>;
  /** The time that the credit was redeemed. */
  redeemedAt?: Maybe<Scalars['Time']['output']>;
  sparkyConversation?: Maybe<SparkyConversation>;
  sparkyConversationID?: Maybe<Scalars['ID']['output']>;
  /** The survey for the credit. */
  survey?: Maybe<Scalars['Map']['output']>;
  /** The tenant that the topic belongs to. */
  tenant?: Maybe<Tenant>;
  /** The type of the credit. */
  type: EducationCreditType;
  updatedAt: Scalars['Time']['output'];
  /** The user that created/earned the credit. */
  user: User;
  /** The collections the user redeemed for this credit */
  userCollectionCompletions?: Maybe<Array<UserCollectionCompletion>>;
  userID: Scalars['ID']['output'];
  /** The value of the credit. */
  value: Scalars['Float']['output'];
  /** The version of the credit. */
  version: EducationCreditVersion;
};

/** A connection to a list of items. */
export type EducationCreditConnection = {
  __typename?: 'EducationCreditConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EducationCreditEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type EducationCreditEdge = {
  __typename?: 'EducationCreditEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EducationCredit>;
};

/** Ordering options for EducationCredit connections */
export type EducationCreditOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order EducationCredits. */
  field: EducationCreditOrderField;
};

/** Properties by which EducationCredit connections can be ordered. */
export enum EducationCreditOrderField {
  CreatedAt = 'CREATED_AT'
}

/** EducationCreditType is enum for the field type */
export enum EducationCreditType {
  AccreditedContent = 'accredited_content',
  Other = 'other',
  Reflection = 'reflection'
}

/** EducationCreditVersion is enum for the field version */
export enum EducationCreditVersion {
  V1 = 'v1',
  V2 = 'v2'
}

/**
 * EducationCreditWhereInput is used for filtering EducationCredit objects.
 * Input was generated by ent.
 */
export type EducationCreditWhereInput = {
  and?: InputMaybe<Array<EducationCreditWhereInput>>;
  /** comment_id field predicates */
  commentID?: InputMaybe<Scalars['ID']['input']>;
  commentIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  commentIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  commentIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  commentIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  commentIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** deleted_reason field predicates */
  deletedReason?: InputMaybe<Scalars['String']['input']>;
  deletedReasonContains?: InputMaybe<Scalars['String']['input']>;
  deletedReasonContainsFold?: InputMaybe<Scalars['String']['input']>;
  deletedReasonEqualFold?: InputMaybe<Scalars['String']['input']>;
  deletedReasonGT?: InputMaybe<Scalars['String']['input']>;
  deletedReasonGTE?: InputMaybe<Scalars['String']['input']>;
  deletedReasonHasPrefix?: InputMaybe<Scalars['String']['input']>;
  deletedReasonHasSuffix?: InputMaybe<Scalars['String']['input']>;
  deletedReasonIn?: InputMaybe<Array<Scalars['String']['input']>>;
  deletedReasonIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedReasonLT?: InputMaybe<Scalars['String']['input']>;
  deletedReasonLTE?: InputMaybe<Scalars['String']['input']>;
  deletedReasonNEQ?: InputMaybe<Scalars['String']['input']>;
  deletedReasonNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  deletedReasonNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** certificate edge predicates */
  hasCertificate?: InputMaybe<Scalars['Boolean']['input']>;
  hasCertificateWith?: InputMaybe<Array<CertificateWhereInput>>;
  /** comment edge predicates */
  hasComment?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommentWith?: InputMaybe<Array<CommentWhereInput>>;
  /** deleted_by edge predicates */
  hasDeletedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasDeletedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** learning_objective edge predicates */
  hasLearningObjective?: InputMaybe<Scalars['Boolean']['input']>;
  hasLearningObjectiveWith?: InputMaybe<Array<LearningObjectiveWhereInput>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** sparky_conversation edge predicates */
  hasSparkyConversation?: InputMaybe<Scalars['Boolean']['input']>;
  hasSparkyConversationWith?: InputMaybe<Array<SparkyConversationWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']['input']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  /** user_collection_completions edge predicates */
  hasUserCollectionCompletions?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserCollectionCompletionsWith?: InputMaybe<Array<UserCollectionCompletionWhereInput>>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<EducationCreditWhereInput>;
  or?: InputMaybe<Array<EducationCreditWhereInput>>;
  /** post_id field predicates */
  postID?: InputMaybe<Scalars['ID']['input']>;
  postIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  postIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  postIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  postIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  postIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** redeemed_at field predicates */
  redeemedAt?: InputMaybe<Scalars['Time']['input']>;
  redeemedAtGT?: InputMaybe<Scalars['Time']['input']>;
  redeemedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  redeemedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  redeemedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  redeemedAtLT?: InputMaybe<Scalars['Time']['input']>;
  redeemedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  redeemedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  redeemedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  redeemedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** sparky_conversation_id field predicates */
  sparkyConversationID?: InputMaybe<Scalars['ID']['input']>;
  sparkyConversationIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  sparkyConversationIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  sparkyConversationIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  sparkyConversationIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  sparkyConversationIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** type field predicates */
  type?: InputMaybe<EducationCreditType>;
  typeIn?: InputMaybe<Array<EducationCreditType>>;
  typeNEQ?: InputMaybe<EducationCreditType>;
  typeNotIn?: InputMaybe<Array<EducationCreditType>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** value field predicates */
  value?: InputMaybe<Scalars['Float']['input']>;
  valueGT?: InputMaybe<Scalars['Float']['input']>;
  valueGTE?: InputMaybe<Scalars['Float']['input']>;
  valueIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  valueLT?: InputMaybe<Scalars['Float']['input']>;
  valueLTE?: InputMaybe<Scalars['Float']['input']>;
  valueNEQ?: InputMaybe<Scalars['Float']['input']>;
  valueNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** version field predicates */
  version?: InputMaybe<EducationCreditVersion>;
  versionIn?: InputMaybe<Array<EducationCreditVersion>>;
  versionNEQ?: InputMaybe<EducationCreditVersion>;
  versionNotIn?: InputMaybe<Array<EducationCreditVersion>>;
};

export type EducationHistory = Node & {
  __typename?: 'EducationHistory';
  /** The degree attained for this education history entry. */
  degree?: Maybe<Scalars['String']['output']>;
  endDate?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  /** The institution/school name for this education history entry. */
  institution: Scalars['String']['output'];
  /** The major for this education history entry. */
  major?: Maybe<Scalars['String']['output']>;
  startDate?: Maybe<Scalars['Time']['output']>;
  type: EducationHistoryType;
  /** Education history for a user. */
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type EducationHistoryConnection = {
  __typename?: 'EducationHistoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EducationHistoryEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type EducationHistoryEdge = {
  __typename?: 'EducationHistoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EducationHistory>;
};

/** EducationHistoryType is enum for the field type */
export enum EducationHistoryType {
  Education = 'education',
  Training = 'training',
  Unknown = 'unknown'
}

/**
 * EducationHistoryWhereInput is used for filtering EducationHistory objects.
 * Input was generated by ent.
 */
export type EducationHistoryWhereInput = {
  and?: InputMaybe<Array<EducationHistoryWhereInput>>;
  /** degree field predicates */
  degree?: InputMaybe<Scalars['String']['input']>;
  degreeContains?: InputMaybe<Scalars['String']['input']>;
  degreeContainsFold?: InputMaybe<Scalars['String']['input']>;
  degreeEqualFold?: InputMaybe<Scalars['String']['input']>;
  degreeGT?: InputMaybe<Scalars['String']['input']>;
  degreeGTE?: InputMaybe<Scalars['String']['input']>;
  degreeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  degreeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  degreeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  degreeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  degreeLT?: InputMaybe<Scalars['String']['input']>;
  degreeLTE?: InputMaybe<Scalars['String']['input']>;
  degreeNEQ?: InputMaybe<Scalars['String']['input']>;
  degreeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  degreeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** end_date field predicates */
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endDateGT?: InputMaybe<Scalars['Time']['input']>;
  endDateGTE?: InputMaybe<Scalars['Time']['input']>;
  endDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  endDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  endDateLT?: InputMaybe<Scalars['Time']['input']>;
  endDateLTE?: InputMaybe<Scalars['Time']['input']>;
  endDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  endDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  endDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** institution field predicates */
  institution?: InputMaybe<Scalars['String']['input']>;
  institutionContains?: InputMaybe<Scalars['String']['input']>;
  institutionContainsFold?: InputMaybe<Scalars['String']['input']>;
  institutionEqualFold?: InputMaybe<Scalars['String']['input']>;
  institutionGT?: InputMaybe<Scalars['String']['input']>;
  institutionGTE?: InputMaybe<Scalars['String']['input']>;
  institutionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  institutionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  institutionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  institutionLT?: InputMaybe<Scalars['String']['input']>;
  institutionLTE?: InputMaybe<Scalars['String']['input']>;
  institutionNEQ?: InputMaybe<Scalars['String']['input']>;
  institutionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** major field predicates */
  major?: InputMaybe<Scalars['String']['input']>;
  majorContains?: InputMaybe<Scalars['String']['input']>;
  majorContainsFold?: InputMaybe<Scalars['String']['input']>;
  majorEqualFold?: InputMaybe<Scalars['String']['input']>;
  majorGT?: InputMaybe<Scalars['String']['input']>;
  majorGTE?: InputMaybe<Scalars['String']['input']>;
  majorHasPrefix?: InputMaybe<Scalars['String']['input']>;
  majorHasSuffix?: InputMaybe<Scalars['String']['input']>;
  majorIn?: InputMaybe<Array<Scalars['String']['input']>>;
  majorIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  majorLT?: InputMaybe<Scalars['String']['input']>;
  majorLTE?: InputMaybe<Scalars['String']['input']>;
  majorNEQ?: InputMaybe<Scalars['String']['input']>;
  majorNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  majorNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<EducationHistoryWhereInput>;
  or?: InputMaybe<Array<EducationHistoryWhereInput>>;
  /** start_date field predicates */
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startDateGT?: InputMaybe<Scalars['Time']['input']>;
  startDateGTE?: InputMaybe<Scalars['Time']['input']>;
  startDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  startDateLT?: InputMaybe<Scalars['Time']['input']>;
  startDateLTE?: InputMaybe<Scalars['Time']['input']>;
  startDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  startDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** type field predicates */
  type?: InputMaybe<EducationHistoryType>;
  typeIn?: InputMaybe<Array<EducationHistoryType>>;
  typeNEQ?: InputMaybe<EducationHistoryType>;
  typeNotIn?: InputMaybe<Array<EducationHistoryType>>;
};

export type EducationRequirement = Node & {
  __typename?: 'EducationRequirement';
  countryCode: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  periodInYears: Scalars['Int']['output'];
  profession?: Maybe<Scalars['String']['output']>;
  referenceURL?: Maybe<Scalars['String']['output']>;
  stateCode: Scalars['String']['output'];
  totalCmeCategoryOneRequired: Scalars['Int']['output'];
  totalCmeRequired: Scalars['Int']['output'];
};

/** A connection to a list of items. */
export type EducationRequirementConnection = {
  __typename?: 'EducationRequirementConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EducationRequirementEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type EducationRequirementEdge = {
  __typename?: 'EducationRequirementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<EducationRequirement>;
};

/**
 * EducationRequirementWhereInput is used for filtering EducationRequirement objects.
 * Input was generated by ent.
 */
export type EducationRequirementWhereInput = {
  and?: InputMaybe<Array<EducationRequirementWhereInput>>;
  /** country_code field predicates */
  countryCode?: InputMaybe<Scalars['String']['input']>;
  countryCodeContains?: InputMaybe<Scalars['String']['input']>;
  countryCodeContainsFold?: InputMaybe<Scalars['String']['input']>;
  countryCodeEqualFold?: InputMaybe<Scalars['String']['input']>;
  countryCodeGT?: InputMaybe<Scalars['String']['input']>;
  countryCodeGTE?: InputMaybe<Scalars['String']['input']>;
  countryCodeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  countryCodeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  countryCodeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  countryCodeLT?: InputMaybe<Scalars['String']['input']>;
  countryCodeLTE?: InputMaybe<Scalars['String']['input']>;
  countryCodeNEQ?: InputMaybe<Scalars['String']['input']>;
  countryCodeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<EducationRequirementWhereInput>;
  or?: InputMaybe<Array<EducationRequirementWhereInput>>;
  /** period_in_years field predicates */
  periodInYears?: InputMaybe<Scalars['Int']['input']>;
  periodInYearsGT?: InputMaybe<Scalars['Int']['input']>;
  periodInYearsGTE?: InputMaybe<Scalars['Int']['input']>;
  periodInYearsIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  periodInYearsLT?: InputMaybe<Scalars['Int']['input']>;
  periodInYearsLTE?: InputMaybe<Scalars['Int']['input']>;
  periodInYearsNEQ?: InputMaybe<Scalars['Int']['input']>;
  periodInYearsNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** profession field predicates */
  profession?: InputMaybe<Scalars['String']['input']>;
  professionContains?: InputMaybe<Scalars['String']['input']>;
  professionContainsFold?: InputMaybe<Scalars['String']['input']>;
  professionEqualFold?: InputMaybe<Scalars['String']['input']>;
  professionGT?: InputMaybe<Scalars['String']['input']>;
  professionGTE?: InputMaybe<Scalars['String']['input']>;
  professionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  professionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  professionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  professionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  professionLT?: InputMaybe<Scalars['String']['input']>;
  professionLTE?: InputMaybe<Scalars['String']['input']>;
  professionNEQ?: InputMaybe<Scalars['String']['input']>;
  professionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  professionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** reference_url field predicates */
  referenceURL?: InputMaybe<Scalars['String']['input']>;
  referenceURLContains?: InputMaybe<Scalars['String']['input']>;
  referenceURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  referenceURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  referenceURLGT?: InputMaybe<Scalars['String']['input']>;
  referenceURLGTE?: InputMaybe<Scalars['String']['input']>;
  referenceURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  referenceURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  referenceURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  referenceURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  referenceURLLT?: InputMaybe<Scalars['String']['input']>;
  referenceURLLTE?: InputMaybe<Scalars['String']['input']>;
  referenceURLNEQ?: InputMaybe<Scalars['String']['input']>;
  referenceURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  referenceURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** state_code field predicates */
  stateCode?: InputMaybe<Scalars['String']['input']>;
  stateCodeContains?: InputMaybe<Scalars['String']['input']>;
  stateCodeContainsFold?: InputMaybe<Scalars['String']['input']>;
  stateCodeEqualFold?: InputMaybe<Scalars['String']['input']>;
  stateCodeGT?: InputMaybe<Scalars['String']['input']>;
  stateCodeGTE?: InputMaybe<Scalars['String']['input']>;
  stateCodeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  stateCodeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  stateCodeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  stateCodeLT?: InputMaybe<Scalars['String']['input']>;
  stateCodeLTE?: InputMaybe<Scalars['String']['input']>;
  stateCodeNEQ?: InputMaybe<Scalars['String']['input']>;
  stateCodeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** total_cme_category_one_required field predicates */
  totalCmeCategoryOneRequired?: InputMaybe<Scalars['Int']['input']>;
  totalCmeCategoryOneRequiredGT?: InputMaybe<Scalars['Int']['input']>;
  totalCmeCategoryOneRequiredGTE?: InputMaybe<Scalars['Int']['input']>;
  totalCmeCategoryOneRequiredIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalCmeCategoryOneRequiredLT?: InputMaybe<Scalars['Int']['input']>;
  totalCmeCategoryOneRequiredLTE?: InputMaybe<Scalars['Int']['input']>;
  totalCmeCategoryOneRequiredNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalCmeCategoryOneRequiredNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** total_cme_required field predicates */
  totalCmeRequired?: InputMaybe<Scalars['Int']['input']>;
  totalCmeRequiredGT?: InputMaybe<Scalars['Int']['input']>;
  totalCmeRequiredGTE?: InputMaybe<Scalars['Int']['input']>;
  totalCmeRequiredIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalCmeRequiredLT?: InputMaybe<Scalars['Int']['input']>;
  totalCmeRequiredLTE?: InputMaybe<Scalars['Int']['input']>;
  totalCmeRequiredNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalCmeRequiredNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type FaceDetectRequest = Node & {
  __typename?: 'FaceDetectRequest';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  jobID: Scalars['String']['output'];
  response?: Maybe<Scalars['Map']['output']>;
  status: Scalars['String']['output'];
  storageKey: Scalars['String']['output'];
  video?: Maybe<Video>;
};

/**
 * FaceDetectRequestWhereInput is used for filtering FaceDetectRequest objects.
 * Input was generated by ent.
 */
export type FaceDetectRequestWhereInput = {
  and?: InputMaybe<Array<FaceDetectRequestWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** video edge predicates */
  hasVideo?: InputMaybe<Scalars['Boolean']['input']>;
  hasVideoWith?: InputMaybe<Array<VideoWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** job_id field predicates */
  jobID?: InputMaybe<Scalars['String']['input']>;
  jobIDContains?: InputMaybe<Scalars['String']['input']>;
  jobIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  jobIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  jobIDGT?: InputMaybe<Scalars['String']['input']>;
  jobIDGTE?: InputMaybe<Scalars['String']['input']>;
  jobIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  jobIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  jobIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  jobIDLT?: InputMaybe<Scalars['String']['input']>;
  jobIDLTE?: InputMaybe<Scalars['String']['input']>;
  jobIDNEQ?: InputMaybe<Scalars['String']['input']>;
  jobIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<FaceDetectRequestWhereInput>;
  or?: InputMaybe<Array<FaceDetectRequestWhereInput>>;
  /** status field predicates */
  status?: InputMaybe<Scalars['String']['input']>;
  statusContains?: InputMaybe<Scalars['String']['input']>;
  statusContainsFold?: InputMaybe<Scalars['String']['input']>;
  statusEqualFold?: InputMaybe<Scalars['String']['input']>;
  statusGT?: InputMaybe<Scalars['String']['input']>;
  statusGTE?: InputMaybe<Scalars['String']['input']>;
  statusHasPrefix?: InputMaybe<Scalars['String']['input']>;
  statusHasSuffix?: InputMaybe<Scalars['String']['input']>;
  statusIn?: InputMaybe<Array<Scalars['String']['input']>>;
  statusLT?: InputMaybe<Scalars['String']['input']>;
  statusLTE?: InputMaybe<Scalars['String']['input']>;
  statusNEQ?: InputMaybe<Scalars['String']['input']>;
  statusNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** storage_key field predicates */
  storageKey?: InputMaybe<Scalars['String']['input']>;
  storageKeyContains?: InputMaybe<Scalars['String']['input']>;
  storageKeyContainsFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyEqualFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyGT?: InputMaybe<Scalars['String']['input']>;
  storageKeyGTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  storageKeyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  storageKeyLT?: InputMaybe<Scalars['String']['input']>;
  storageKeyLTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyNEQ?: InputMaybe<Scalars['String']['input']>;
  storageKeyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type FeedConnection = {
  __typename?: 'FeedConnection';
  edges: Array<PostEdge>;
  pageInfo: FeedPageInfo;
};

export type FeedPageInfo = {
  __typename?: 'FeedPageInfo';
  /** The cursor corresponding to the last elements of the list. */
  endCursor: Scalars['String']['output'];
  hasNextPage: Scalars['Boolean']['output'];
  /** (WARNING) Due to a naming error this value is the same as endCursor. Please use endCursor instead, and this will be removed in a future release. */
  startCursor: Scalars['String']['output'];
};

export enum FeedType {
  Following = 'FOLLOWING',
  ForYou = 'FOR_YOU',
  ForYouV2 = 'FOR_YOU_V2',
  V2 = 'V2'
}

export type FileUploadResponse = {
  __typename?: 'FileUploadResponse';
  file: Upload;
  url: Scalars['String']['output'];
};

export type FinancialDisclosure = Node & {
  __typename?: 'FinancialDisclosure';
  /** The name of the company the user is declaring this financial disclosure for */
  companyName: Scalars['String']['output'];
  createdAt: Scalars['Time']['output'];
  deletedAt?: Maybe<Scalars['Time']['output']>;
  /** If true, the relationship with the company has ended */
  hasEnded: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** The role the user has at the declared company */
  role: FinancialDisclosureRole;
  statement?: Maybe<FinancialDisclosureStatement>;
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type FinancialDisclosureConnection = {
  __typename?: 'FinancialDisclosureConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<FinancialDisclosureEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type FinancialDisclosureEdge = {
  __typename?: 'FinancialDisclosureEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<FinancialDisclosure>;
};

export type FinancialDisclosureInput = {
  /** The name of the company the user is declaring this financial disclosure for */
  companyName: Scalars['String']['input'];
  /** If true, the relationship with the company has ended */
  hasEnded?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The ID for the role the user has in the company */
  roleID: Scalars['ID']['input'];
};

/** Ordering options for FinancialDisclosure connections */
export type FinancialDisclosureOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order FinancialDisclosures. */
  field: FinancialDisclosureOrderField;
};

/** Properties by which FinancialDisclosure connections can be ordered. */
export enum FinancialDisclosureOrderField {
  CreatedAt = 'CREATED_AT'
}

export type FinancialDisclosurePrintTemplate = Node & {
  __typename?: 'FinancialDisclosurePrintTemplate';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  template?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type FinancialDisclosurePrintTemplateConnection = {
  __typename?: 'FinancialDisclosurePrintTemplateConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<FinancialDisclosurePrintTemplateEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type FinancialDisclosurePrintTemplateEdge = {
  __typename?: 'FinancialDisclosurePrintTemplateEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<FinancialDisclosurePrintTemplate>;
};

/** Ordering options for FinancialDisclosurePrintTemplate connections */
export type FinancialDisclosurePrintTemplateOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order FinancialDisclosurePrintTemplates. */
  field: FinancialDisclosurePrintTemplateOrderField;
};

/** Properties by which FinancialDisclosurePrintTemplate connections can be ordered. */
export enum FinancialDisclosurePrintTemplateOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * FinancialDisclosurePrintTemplateWhereInput is used for filtering FinancialDisclosurePrintTemplate objects.
 * Input was generated by ent.
 */
export type FinancialDisclosurePrintTemplateWhereInput = {
  and?: InputMaybe<Array<FinancialDisclosurePrintTemplateWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<FinancialDisclosurePrintTemplateWhereInput>;
  or?: InputMaybe<Array<FinancialDisclosurePrintTemplateWhereInput>>;
  /** template field predicates */
  template?: InputMaybe<Scalars['String']['input']>;
  templateContains?: InputMaybe<Scalars['String']['input']>;
  templateContainsFold?: InputMaybe<Scalars['String']['input']>;
  templateEqualFold?: InputMaybe<Scalars['String']['input']>;
  templateGT?: InputMaybe<Scalars['String']['input']>;
  templateGTE?: InputMaybe<Scalars['String']['input']>;
  templateHasPrefix?: InputMaybe<Scalars['String']['input']>;
  templateHasSuffix?: InputMaybe<Scalars['String']['input']>;
  templateIn?: InputMaybe<Array<Scalars['String']['input']>>;
  templateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  templateLT?: InputMaybe<Scalars['String']['input']>;
  templateLTE?: InputMaybe<Scalars['String']['input']>;
  templateNEQ?: InputMaybe<Scalars['String']['input']>;
  templateNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  templateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type FinancialDisclosureRole = Node & {
  __typename?: 'FinancialDisclosureRole';
  /** If true, financial disclosures with this role will be rejected automatically */
  automaticallyReject: Scalars['Boolean']['output'];
  createdAt: Scalars['Time']['output'];
  deletedAt?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  /** (DEPRECATED) this value is ignored */
  requiresApproval: Scalars['Boolean']['output'];
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type FinancialDisclosureRoleConnection = {
  __typename?: 'FinancialDisclosureRoleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<FinancialDisclosureRoleEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type FinancialDisclosureRoleEdge = {
  __typename?: 'FinancialDisclosureRoleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<FinancialDisclosureRole>;
};

/** Ordering options for FinancialDisclosureRole connections */
export type FinancialDisclosureRoleOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order FinancialDisclosureRoles. */
  field: FinancialDisclosureRoleOrderField;
};

/** Properties by which FinancialDisclosureRole connections can be ordered. */
export enum FinancialDisclosureRoleOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * FinancialDisclosureRoleWhereInput is used for filtering FinancialDisclosureRole objects.
 * Input was generated by ent.
 */
export type FinancialDisclosureRoleWhereInput = {
  and?: InputMaybe<Array<FinancialDisclosureRoleWhereInput>>;
  /** automatically_reject field predicates */
  automaticallyReject?: InputMaybe<Scalars['Boolean']['input']>;
  automaticallyRejectNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<FinancialDisclosureRoleWhereInput>;
  or?: InputMaybe<Array<FinancialDisclosureRoleWhereInput>>;
  /** requires_approval field predicates */
  requiresApproval?: InputMaybe<Scalars['Boolean']['input']>;
  requiresApprovalNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type FinancialDisclosureStatement = Node & {
  __typename?: 'FinancialDisclosureStatement';
  /** If true, the user agrees to disclose unlabeled/unapproved users of drugs or products */
  agreesToDisclose: Scalars['Boolean']['output'];
  /** The date the financial disclosure statement was approved (Admin Only) */
  approvedAt?: Maybe<Scalars['Time']['output']>;
  createdAt: Scalars['Time']['output'];
  deletedAt?: Maybe<Scalars['Time']['output']>;
  /** The date the financial disclosure statement was denied (Admin Only) */
  deniedAt?: Maybe<Scalars['Time']['output']>;
  /** If true, the user attests that the information provided is true and accurate */
  doesAttest: Scalars['Boolean']['output'];
  /** If true, the user has financial relationships */
  hasFinancialRelationships: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** The initials of the user */
  initials: Scalars['String']['output'];
  relationships?: Maybe<Array<FinancialDisclosure>>;
  /** If true, at least one of the relationships has a role requiring approval (Admin Only) */
  requiresApproval: Scalars['Boolean']['output'];
  /** The date the user signed the financial disclosure statement */
  signatureDate: Scalars['Time']['output'];
  /** The status of the financial disclosure statement (Admin Only) */
  status: FinancialDisclosureStatementStatus;
  updatedAt: Scalars['Time']['output'];
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type FinancialDisclosureStatementConnection = {
  __typename?: 'FinancialDisclosureStatementConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<FinancialDisclosureStatementEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type FinancialDisclosureStatementEdge = {
  __typename?: 'FinancialDisclosureStatementEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<FinancialDisclosureStatement>;
};

/** Ordering options for FinancialDisclosureStatement connections */
export type FinancialDisclosureStatementOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order FinancialDisclosureStatements. */
  field: FinancialDisclosureStatementOrderField;
};

/** Properties by which FinancialDisclosureStatement connections can be ordered. */
export enum FinancialDisclosureStatementOrderField {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/** FinancialDisclosureStatementStatus is enum for the field status */
export enum FinancialDisclosureStatementStatus {
  Approved = 'approved',
  Denied = 'denied',
  Pending = 'pending'
}

/**
 * FinancialDisclosureStatementWhereInput is used for filtering FinancialDisclosureStatement objects.
 * Input was generated by ent.
 */
export type FinancialDisclosureStatementWhereInput = {
  /** agrees_to_disclose field predicates */
  agreesToDisclose?: InputMaybe<Scalars['Boolean']['input']>;
  agreesToDiscloseNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  and?: InputMaybe<Array<FinancialDisclosureStatementWhereInput>>;
  /** approved_at field predicates */
  approvedAt?: InputMaybe<Scalars['Time']['input']>;
  approvedAtGT?: InputMaybe<Scalars['Time']['input']>;
  approvedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  approvedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  approvedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  approvedAtLT?: InputMaybe<Scalars['Time']['input']>;
  approvedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  approvedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  approvedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  approvedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** denied_at field predicates */
  deniedAt?: InputMaybe<Scalars['Time']['input']>;
  deniedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deniedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deniedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deniedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deniedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deniedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deniedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deniedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deniedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** does_attest field predicates */
  doesAttest?: InputMaybe<Scalars['Boolean']['input']>;
  doesAttestNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_financial_relationships field predicates */
  hasFinancialRelationships?: InputMaybe<Scalars['Boolean']['input']>;
  hasFinancialRelationshipsNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** relationships edge predicates */
  hasRelationships?: InputMaybe<Scalars['Boolean']['input']>;
  hasRelationshipsWith?: InputMaybe<Array<FinancialDisclosureWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** initials field predicates */
  initials?: InputMaybe<Scalars['String']['input']>;
  initialsContains?: InputMaybe<Scalars['String']['input']>;
  initialsContainsFold?: InputMaybe<Scalars['String']['input']>;
  initialsEqualFold?: InputMaybe<Scalars['String']['input']>;
  initialsGT?: InputMaybe<Scalars['String']['input']>;
  initialsGTE?: InputMaybe<Scalars['String']['input']>;
  initialsHasPrefix?: InputMaybe<Scalars['String']['input']>;
  initialsHasSuffix?: InputMaybe<Scalars['String']['input']>;
  initialsIn?: InputMaybe<Array<Scalars['String']['input']>>;
  initialsLT?: InputMaybe<Scalars['String']['input']>;
  initialsLTE?: InputMaybe<Scalars['String']['input']>;
  initialsNEQ?: InputMaybe<Scalars['String']['input']>;
  initialsNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<FinancialDisclosureStatementWhereInput>;
  or?: InputMaybe<Array<FinancialDisclosureStatementWhereInput>>;
  /** requires_approval field predicates */
  requiresApproval?: InputMaybe<Scalars['Boolean']['input']>;
  requiresApprovalNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** signature_date field predicates */
  signatureDate?: InputMaybe<Scalars['Time']['input']>;
  signatureDateGT?: InputMaybe<Scalars['Time']['input']>;
  signatureDateGTE?: InputMaybe<Scalars['Time']['input']>;
  signatureDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  signatureDateLT?: InputMaybe<Scalars['Time']['input']>;
  signatureDateLTE?: InputMaybe<Scalars['Time']['input']>;
  signatureDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  signatureDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** status field predicates */
  status?: InputMaybe<FinancialDisclosureStatementStatus>;
  statusIn?: InputMaybe<Array<FinancialDisclosureStatementStatus>>;
  statusNEQ?: InputMaybe<FinancialDisclosureStatementStatus>;
  statusNotIn?: InputMaybe<Array<FinancialDisclosureStatementStatus>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * FinancialDisclosureWhereInput is used for filtering FinancialDisclosure objects.
 * Input was generated by ent.
 */
export type FinancialDisclosureWhereInput = {
  and?: InputMaybe<Array<FinancialDisclosureWhereInput>>;
  /** company_name field predicates */
  companyName?: InputMaybe<Scalars['String']['input']>;
  companyNameContains?: InputMaybe<Scalars['String']['input']>;
  companyNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  companyNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  companyNameGT?: InputMaybe<Scalars['String']['input']>;
  companyNameGTE?: InputMaybe<Scalars['String']['input']>;
  companyNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  companyNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  companyNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  companyNameLT?: InputMaybe<Scalars['String']['input']>;
  companyNameLTE?: InputMaybe<Scalars['String']['input']>;
  companyNameNEQ?: InputMaybe<Scalars['String']['input']>;
  companyNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** deleted_at field predicates */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  deletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  deletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  deletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  deletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** has_ended field predicates */
  hasEnded?: InputMaybe<Scalars['Boolean']['input']>;
  hasEndedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** role edge predicates */
  hasRole?: InputMaybe<Scalars['Boolean']['input']>;
  hasRoleWith?: InputMaybe<Array<FinancialDisclosureRoleWhereInput>>;
  /** statement edge predicates */
  hasStatement?: InputMaybe<Scalars['Boolean']['input']>;
  hasStatementWith?: InputMaybe<Array<FinancialDisclosureStatementWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<FinancialDisclosureWhereInput>;
  or?: InputMaybe<Array<FinancialDisclosureWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type GiblibVideo = Node & {
  __typename?: 'GiblibVideo';
  createdAt: Scalars['Time']['output'];
  externalID: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  mirroredAudioURL?: Maybe<Scalars['String']['output']>;
  mirroredVideoURL?: Maybe<Scalars['String']['output']>;
  post?: Maybe<Post>;
  posterURL?: Maybe<Scalars['String']['output']>;
  publishedAt?: Maybe<Scalars['Time']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Time']['output'];
  videoURL?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of items. */
export type GiblibVideoConnection = {
  __typename?: 'GiblibVideoConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GiblibVideoEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type GiblibVideoEdge = {
  __typename?: 'GiblibVideoEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GiblibVideo>;
};

/** Ordering options for GiblibVideo connections */
export type GiblibVideoOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order GiblibVideos. */
  field: GiblibVideoOrderField;
};

/** Properties by which GiblibVideo connections can be ordered. */
export enum GiblibVideoOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * GiblibVideoWhereInput is used for filtering GiblibVideo objects.
 * Input was generated by ent.
 */
export type GiblibVideoWhereInput = {
  and?: InputMaybe<Array<GiblibVideoWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** external_id field predicates */
  externalID?: InputMaybe<Scalars['Int']['input']>;
  externalIDGT?: InputMaybe<Scalars['Int']['input']>;
  externalIDGTE?: InputMaybe<Scalars['Int']['input']>;
  externalIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  externalIDLT?: InputMaybe<Scalars['Int']['input']>;
  externalIDLTE?: InputMaybe<Scalars['Int']['input']>;
  externalIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  externalIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** mirrored_audio_url field predicates */
  mirroredAudioURL?: InputMaybe<Scalars['String']['input']>;
  mirroredAudioURLContains?: InputMaybe<Scalars['String']['input']>;
  mirroredAudioURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  mirroredAudioURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  mirroredAudioURLGT?: InputMaybe<Scalars['String']['input']>;
  mirroredAudioURLGTE?: InputMaybe<Scalars['String']['input']>;
  mirroredAudioURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  mirroredAudioURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  mirroredAudioURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  mirroredAudioURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  mirroredAudioURLLT?: InputMaybe<Scalars['String']['input']>;
  mirroredAudioURLLTE?: InputMaybe<Scalars['String']['input']>;
  mirroredAudioURLNEQ?: InputMaybe<Scalars['String']['input']>;
  mirroredAudioURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  mirroredAudioURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** mirrored_video_url field predicates */
  mirroredVideoURL?: InputMaybe<Scalars['String']['input']>;
  mirroredVideoURLContains?: InputMaybe<Scalars['String']['input']>;
  mirroredVideoURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  mirroredVideoURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  mirroredVideoURLGT?: InputMaybe<Scalars['String']['input']>;
  mirroredVideoURLGTE?: InputMaybe<Scalars['String']['input']>;
  mirroredVideoURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  mirroredVideoURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  mirroredVideoURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  mirroredVideoURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  mirroredVideoURLLT?: InputMaybe<Scalars['String']['input']>;
  mirroredVideoURLLTE?: InputMaybe<Scalars['String']['input']>;
  mirroredVideoURLNEQ?: InputMaybe<Scalars['String']['input']>;
  mirroredVideoURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  mirroredVideoURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<GiblibVideoWhereInput>;
  or?: InputMaybe<Array<GiblibVideoWhereInput>>;
  /** poster_url field predicates */
  posterURL?: InputMaybe<Scalars['String']['input']>;
  posterURLContains?: InputMaybe<Scalars['String']['input']>;
  posterURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  posterURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  posterURLGT?: InputMaybe<Scalars['String']['input']>;
  posterURLGTE?: InputMaybe<Scalars['String']['input']>;
  posterURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  posterURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  posterURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  posterURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  posterURLLT?: InputMaybe<Scalars['String']['input']>;
  posterURLLTE?: InputMaybe<Scalars['String']['input']>;
  posterURLNEQ?: InputMaybe<Scalars['String']['input']>;
  posterURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  posterURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** published_at field predicates */
  publishedAt?: InputMaybe<Scalars['Time']['input']>;
  publishedAtGT?: InputMaybe<Scalars['Time']['input']>;
  publishedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  publishedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  publishedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  publishedAtLT?: InputMaybe<Scalars['Time']['input']>;
  publishedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  publishedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  publishedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  publishedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** video_url field predicates */
  videoURL?: InputMaybe<Scalars['String']['input']>;
  videoURLContains?: InputMaybe<Scalars['String']['input']>;
  videoURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  videoURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  videoURLGT?: InputMaybe<Scalars['String']['input']>;
  videoURLGTE?: InputMaybe<Scalars['String']['input']>;
  videoURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  videoURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  videoURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  videoURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  videoURLLT?: InputMaybe<Scalars['String']['input']>;
  videoURLLTE?: InputMaybe<Scalars['String']['input']>;
  videoURLNEQ?: InputMaybe<Scalars['String']['input']>;
  videoURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  videoURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type GoogleDriveFile = Node & {
  __typename?: 'GoogleDriveFile';
  copyCompletedAt?: Maybe<Scalars['Time']['output']>;
  copyErrorMessage?: Maybe<Scalars['String']['output']>;
  copyStartedAt?: Maybe<Scalars['Time']['output']>;
  createdAt: Scalars['Time']['output'];
  createdTime?: Maybe<Scalars['Time']['output']>;
  driveID: Scalars['String']['output'];
  durationMillis?: Maybe<Scalars['Int']['output']>;
  fileID: Scalars['String']['output'];
  folder?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  mimeType: Scalars['String']['output'];
  originalFilename: Scalars['String']['output'];
  parents?: Maybe<Array<Scalars['String']['output']>>;
  size?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['Time']['output'];
  video?: Maybe<Video>;
};

/** A connection to a list of items. */
export type GoogleDriveFileConnection = {
  __typename?: 'GoogleDriveFileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GoogleDriveFileEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type GoogleDriveFileEdge = {
  __typename?: 'GoogleDriveFileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<GoogleDriveFile>;
};

/** Ordering options for GoogleDriveFile connections */
export type GoogleDriveFileOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order GoogleDriveFiles. */
  field: GoogleDriveFileOrderField;
};

/** Properties by which GoogleDriveFile connections can be ordered. */
export enum GoogleDriveFileOrderField {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * GoogleDriveFileWhereInput is used for filtering GoogleDriveFile objects.
 * Input was generated by ent.
 */
export type GoogleDriveFileWhereInput = {
  and?: InputMaybe<Array<GoogleDriveFileWhereInput>>;
  /** copy_completed_at field predicates */
  copyCompletedAt?: InputMaybe<Scalars['Time']['input']>;
  copyCompletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  copyCompletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  copyCompletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  copyCompletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  copyCompletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  copyCompletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  copyCompletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  copyCompletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  copyCompletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** copy_error_message field predicates */
  copyErrorMessage?: InputMaybe<Scalars['String']['input']>;
  copyErrorMessageContains?: InputMaybe<Scalars['String']['input']>;
  copyErrorMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  copyErrorMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  copyErrorMessageGT?: InputMaybe<Scalars['String']['input']>;
  copyErrorMessageGTE?: InputMaybe<Scalars['String']['input']>;
  copyErrorMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  copyErrorMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  copyErrorMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  copyErrorMessageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  copyErrorMessageLT?: InputMaybe<Scalars['String']['input']>;
  copyErrorMessageLTE?: InputMaybe<Scalars['String']['input']>;
  copyErrorMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  copyErrorMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  copyErrorMessageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** copy_started_at field predicates */
  copyStartedAt?: InputMaybe<Scalars['Time']['input']>;
  copyStartedAtGT?: InputMaybe<Scalars['Time']['input']>;
  copyStartedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  copyStartedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  copyStartedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  copyStartedAtLT?: InputMaybe<Scalars['Time']['input']>;
  copyStartedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  copyStartedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  copyStartedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  copyStartedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_time field predicates */
  createdTime?: InputMaybe<Scalars['Time']['input']>;
  createdTimeGT?: InputMaybe<Scalars['Time']['input']>;
  createdTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  createdTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdTimeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  createdTimeLT?: InputMaybe<Scalars['Time']['input']>;
  createdTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  createdTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdTimeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** drive_id field predicates */
  driveID?: InputMaybe<Scalars['String']['input']>;
  driveIDContains?: InputMaybe<Scalars['String']['input']>;
  driveIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  driveIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  driveIDGT?: InputMaybe<Scalars['String']['input']>;
  driveIDGTE?: InputMaybe<Scalars['String']['input']>;
  driveIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  driveIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  driveIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  driveIDLT?: InputMaybe<Scalars['String']['input']>;
  driveIDLTE?: InputMaybe<Scalars['String']['input']>;
  driveIDNEQ?: InputMaybe<Scalars['String']['input']>;
  driveIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** duration_millis field predicates */
  durationMillis?: InputMaybe<Scalars['Int']['input']>;
  durationMillisGT?: InputMaybe<Scalars['Int']['input']>;
  durationMillisGTE?: InputMaybe<Scalars['Int']['input']>;
  durationMillisIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  durationMillisIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  durationMillisLT?: InputMaybe<Scalars['Int']['input']>;
  durationMillisLTE?: InputMaybe<Scalars['Int']['input']>;
  durationMillisNEQ?: InputMaybe<Scalars['Int']['input']>;
  durationMillisNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  durationMillisNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** file_id field predicates */
  fileID?: InputMaybe<Scalars['String']['input']>;
  fileIDContains?: InputMaybe<Scalars['String']['input']>;
  fileIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  fileIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  fileIDGT?: InputMaybe<Scalars['String']['input']>;
  fileIDGTE?: InputMaybe<Scalars['String']['input']>;
  fileIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  fileIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  fileIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  fileIDLT?: InputMaybe<Scalars['String']['input']>;
  fileIDLTE?: InputMaybe<Scalars['String']['input']>;
  fileIDNEQ?: InputMaybe<Scalars['String']['input']>;
  fileIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** folder field predicates */
  folder?: InputMaybe<Scalars['String']['input']>;
  folderContains?: InputMaybe<Scalars['String']['input']>;
  folderContainsFold?: InputMaybe<Scalars['String']['input']>;
  folderEqualFold?: InputMaybe<Scalars['String']['input']>;
  folderGT?: InputMaybe<Scalars['String']['input']>;
  folderGTE?: InputMaybe<Scalars['String']['input']>;
  folderHasPrefix?: InputMaybe<Scalars['String']['input']>;
  folderHasSuffix?: InputMaybe<Scalars['String']['input']>;
  folderIn?: InputMaybe<Array<Scalars['String']['input']>>;
  folderIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  folderLT?: InputMaybe<Scalars['String']['input']>;
  folderLTE?: InputMaybe<Scalars['String']['input']>;
  folderNEQ?: InputMaybe<Scalars['String']['input']>;
  folderNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  folderNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** video edge predicates */
  hasVideo?: InputMaybe<Scalars['Boolean']['input']>;
  hasVideoWith?: InputMaybe<Array<VideoWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** mime_type field predicates */
  mimeType?: InputMaybe<Scalars['String']['input']>;
  mimeTypeContains?: InputMaybe<Scalars['String']['input']>;
  mimeTypeContainsFold?: InputMaybe<Scalars['String']['input']>;
  mimeTypeEqualFold?: InputMaybe<Scalars['String']['input']>;
  mimeTypeGT?: InputMaybe<Scalars['String']['input']>;
  mimeTypeGTE?: InputMaybe<Scalars['String']['input']>;
  mimeTypeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  mimeTypeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  mimeTypeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  mimeTypeLT?: InputMaybe<Scalars['String']['input']>;
  mimeTypeLTE?: InputMaybe<Scalars['String']['input']>;
  mimeTypeNEQ?: InputMaybe<Scalars['String']['input']>;
  mimeTypeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<GoogleDriveFileWhereInput>;
  or?: InputMaybe<Array<GoogleDriveFileWhereInput>>;
  /** original_filename field predicates */
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  originalFilenameContains?: InputMaybe<Scalars['String']['input']>;
  originalFilenameContainsFold?: InputMaybe<Scalars['String']['input']>;
  originalFilenameEqualFold?: InputMaybe<Scalars['String']['input']>;
  originalFilenameGT?: InputMaybe<Scalars['String']['input']>;
  originalFilenameGTE?: InputMaybe<Scalars['String']['input']>;
  originalFilenameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  originalFilenameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  originalFilenameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  originalFilenameLT?: InputMaybe<Scalars['String']['input']>;
  originalFilenameLTE?: InputMaybe<Scalars['String']['input']>;
  originalFilenameNEQ?: InputMaybe<Scalars['String']['input']>;
  originalFilenameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** size field predicates */
  size?: InputMaybe<Scalars['Int']['input']>;
  sizeGT?: InputMaybe<Scalars['Int']['input']>;
  sizeGTE?: InputMaybe<Scalars['Int']['input']>;
  sizeIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  sizeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  sizeLT?: InputMaybe<Scalars['Int']['input']>;
  sizeLTE?: InputMaybe<Scalars['Int']['input']>;
  sizeNEQ?: InputMaybe<Scalars['Int']['input']>;
  sizeNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  sizeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type GptLog = Node & {
  __typename?: 'GptLog';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  prompt: Scalars['String']['output'];
  response?: Maybe<Scalars['Map']['output']>;
  tags?: Maybe<Array<Scalars['String']['output']>>;
};

/**
 * GptLogWhereInput is used for filtering GptLog objects.
 * Input was generated by ent.
 */
export type GptLogWhereInput = {
  and?: InputMaybe<Array<GptLogWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<GptLogWhereInput>;
  or?: InputMaybe<Array<GptLogWhereInput>>;
  /** prompt field predicates */
  prompt?: InputMaybe<Scalars['String']['input']>;
  promptContains?: InputMaybe<Scalars['String']['input']>;
  promptContainsFold?: InputMaybe<Scalars['String']['input']>;
  promptEqualFold?: InputMaybe<Scalars['String']['input']>;
  promptGT?: InputMaybe<Scalars['String']['input']>;
  promptGTE?: InputMaybe<Scalars['String']['input']>;
  promptHasPrefix?: InputMaybe<Scalars['String']['input']>;
  promptHasSuffix?: InputMaybe<Scalars['String']['input']>;
  promptIn?: InputMaybe<Array<Scalars['String']['input']>>;
  promptLT?: InputMaybe<Scalars['String']['input']>;
  promptLTE?: InputMaybe<Scalars['String']['input']>;
  promptNEQ?: InputMaybe<Scalars['String']['input']>;
  promptNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GradeResult = {
  __typename?: 'GradeResult';
  relevanceNudge?: Maybe<Scalars['String']['output']>;
  relevancePoints?: Maybe<Scalars['Int']['output']>;
  toolkitNudge?: Maybe<Scalars['String']['output']>;
  toolkitPoints?: Maybe<Scalars['Int']['output']>;
};

export type Grant = {
  __typename?: 'Grant';
  acronym?: Maybe<Scalars['String']['output']>;
  agency?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  grantId?: Maybe<Scalars['String']['output']>;
};

export type HumanOntologyNode = Node & {
  __typename?: 'HumanOntologyNode';
  definition: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  nodeID: Scalars['String']['output'];
  synonyms: Array<Scalars['String']['output']>;
  type: Scalars['String']['output'];
};

/**
 * HumanOntologyNodeWhereInput is used for filtering HumanOntologyNode objects.
 * Input was generated by ent.
 */
export type HumanOntologyNodeWhereInput = {
  and?: InputMaybe<Array<HumanOntologyNodeWhereInput>>;
  /** definition field predicates */
  definition?: InputMaybe<Scalars['String']['input']>;
  definitionContains?: InputMaybe<Scalars['String']['input']>;
  definitionContainsFold?: InputMaybe<Scalars['String']['input']>;
  definitionEqualFold?: InputMaybe<Scalars['String']['input']>;
  definitionGT?: InputMaybe<Scalars['String']['input']>;
  definitionGTE?: InputMaybe<Scalars['String']['input']>;
  definitionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  definitionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  definitionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  definitionLT?: InputMaybe<Scalars['String']['input']>;
  definitionLTE?: InputMaybe<Scalars['String']['input']>;
  definitionNEQ?: InputMaybe<Scalars['String']['input']>;
  definitionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** node_id field predicates */
  nodeID?: InputMaybe<Scalars['String']['input']>;
  nodeIDContains?: InputMaybe<Scalars['String']['input']>;
  nodeIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  nodeIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  nodeIDGT?: InputMaybe<Scalars['String']['input']>;
  nodeIDGTE?: InputMaybe<Scalars['String']['input']>;
  nodeIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nodeIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nodeIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nodeIDLT?: InputMaybe<Scalars['String']['input']>;
  nodeIDLTE?: InputMaybe<Scalars['String']['input']>;
  nodeIDNEQ?: InputMaybe<Scalars['String']['input']>;
  nodeIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<HumanOntologyNodeWhereInput>;
  or?: InputMaybe<Array<HumanOntologyNodeWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<Scalars['String']['input']>;
  typeContains?: InputMaybe<Scalars['String']['input']>;
  typeContainsFold?: InputMaybe<Scalars['String']['input']>;
  typeEqualFold?: InputMaybe<Scalars['String']['input']>;
  typeGT?: InputMaybe<Scalars['String']['input']>;
  typeGTE?: InputMaybe<Scalars['String']['input']>;
  typeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  typeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  typeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  typeLT?: InputMaybe<Scalars['String']['input']>;
  typeLTE?: InputMaybe<Scalars['String']['input']>;
  typeNEQ?: InputMaybe<Scalars['String']['input']>;
  typeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type Image = Node & {
  __typename?: 'Image';
  completed: Scalars['Boolean']['output'];
  /** The height of the image. */
  height?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  metadata?: Maybe<Scalars['Map']['output']>;
  /** The storage key of the image. */
  storageKey?: Maybe<Scalars['String']['output']>;
  /** The url of the image. */
  url?: Maybe<Scalars['String']['output']>;
  /** Used to identify the variant of the image. */
  variantKey?: Maybe<Scalars['String']['output']>;
  /** The video that this image belongs to. */
  video?: Maybe<Video>;
  /** The width of the image. */
  width?: Maybe<Scalars['Int']['output']>;
};

export type ImageUploadResponse = {
  __typename?: 'ImageUploadResponse';
  image: Image;
  url: Scalars['String']['output'];
};

/**
 * ImageWhereInput is used for filtering Image objects.
 * Input was generated by ent.
 */
export type ImageWhereInput = {
  and?: InputMaybe<Array<ImageWhereInput>>;
  /** completed field predicates */
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  completedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** video edge predicates */
  hasVideo?: InputMaybe<Scalars['Boolean']['input']>;
  hasVideoWith?: InputMaybe<Array<VideoWhereInput>>;
  /** height field predicates */
  height?: InputMaybe<Scalars['Int']['input']>;
  heightGT?: InputMaybe<Scalars['Int']['input']>;
  heightGTE?: InputMaybe<Scalars['Int']['input']>;
  heightIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  heightIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  heightLT?: InputMaybe<Scalars['Int']['input']>;
  heightLTE?: InputMaybe<Scalars['Int']['input']>;
  heightNEQ?: InputMaybe<Scalars['Int']['input']>;
  heightNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  heightNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<ImageWhereInput>;
  or?: InputMaybe<Array<ImageWhereInput>>;
  /** storage_key field predicates */
  storageKey?: InputMaybe<Scalars['String']['input']>;
  storageKeyContains?: InputMaybe<Scalars['String']['input']>;
  storageKeyContainsFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyEqualFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyGT?: InputMaybe<Scalars['String']['input']>;
  storageKeyGTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  storageKeyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  storageKeyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  storageKeyLT?: InputMaybe<Scalars['String']['input']>;
  storageKeyLTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyNEQ?: InputMaybe<Scalars['String']['input']>;
  storageKeyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  storageKeyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']['input']>;
  urlContains?: InputMaybe<Scalars['String']['input']>;
  urlContainsFold?: InputMaybe<Scalars['String']['input']>;
  urlEqualFold?: InputMaybe<Scalars['String']['input']>;
  urlGT?: InputMaybe<Scalars['String']['input']>;
  urlGTE?: InputMaybe<Scalars['String']['input']>;
  urlHasPrefix?: InputMaybe<Scalars['String']['input']>;
  urlHasSuffix?: InputMaybe<Scalars['String']['input']>;
  urlIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  urlLT?: InputMaybe<Scalars['String']['input']>;
  urlLTE?: InputMaybe<Scalars['String']['input']>;
  urlNEQ?: InputMaybe<Scalars['String']['input']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** variant_key field predicates */
  variantKey?: InputMaybe<Scalars['String']['input']>;
  variantKeyContains?: InputMaybe<Scalars['String']['input']>;
  variantKeyContainsFold?: InputMaybe<Scalars['String']['input']>;
  variantKeyEqualFold?: InputMaybe<Scalars['String']['input']>;
  variantKeyGT?: InputMaybe<Scalars['String']['input']>;
  variantKeyGTE?: InputMaybe<Scalars['String']['input']>;
  variantKeyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  variantKeyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  variantKeyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  variantKeyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  variantKeyLT?: InputMaybe<Scalars['String']['input']>;
  variantKeyLTE?: InputMaybe<Scalars['String']['input']>;
  variantKeyNEQ?: InputMaybe<Scalars['String']['input']>;
  variantKeyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  variantKeyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** width field predicates */
  width?: InputMaybe<Scalars['Int']['input']>;
  widthGT?: InputMaybe<Scalars['Int']['input']>;
  widthGTE?: InputMaybe<Scalars['Int']['input']>;
  widthIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  widthIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  widthLT?: InputMaybe<Scalars['Int']['input']>;
  widthLTE?: InputMaybe<Scalars['Int']['input']>;
  widthNEQ?: InputMaybe<Scalars['Int']['input']>;
  widthNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  widthNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ImportedVideo = Node & {
  __typename?: 'ImportedVideo';
  /** The account connection that owns the imported video */
  accountConnection: AccountConnection;
  accountConnectionID: Scalars['ID']['output'];
  accountID?: Maybe<Scalars['String']['output']>;
  /** The body/caption of the video. */
  body?: Maybe<Scalars['String']['output']>;
  /** The bucket of the video. */
  bucket?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Time']['output'];
  /** The status of the export to post */
  exportStatus?: Maybe<ImportedVideoExportStatus>;
  /** The time the video was exported to a post */
  exportedAt?: Maybe<Scalars['Time']['output']>;
  exportedVideo?: Maybe<Video>;
  id: Scalars['ID']['output'];
  /** If the user has marked the video as ignored */
  ignored: Scalars['Boolean']['output'];
  /** The status of the import from external network */
  importStatus: ImportedVideoImportStatus;
  /** The time the video was created on the source platform */
  sourceCreatedAt?: Maybe<Scalars['Time']['output']>;
  /** The storage key of the video. */
  storageKey?: Maybe<Scalars['String']['output']>;
  /** The title of the video. */
  title?: Maybe<Scalars['String']['output']>;
  /** The source of the import */
  type: ImportedVideoType;
  updatedAt: Scalars['Time']['output'];
  /** The user that owns the imported video */
  user: User;
  userID: Scalars['ID']['output'];
  videoID?: Maybe<Scalars['String']['output']>;
  workflowID?: Maybe<Scalars['String']['output']>;
  workflowRunID?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of items. */
export type ImportedVideoConnection = {
  __typename?: 'ImportedVideoConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ImportedVideoEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ImportedVideoEdge = {
  __typename?: 'ImportedVideoEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ImportedVideo>;
};

/** ImportedVideoExportStatus is enum for the field export_status */
export enum ImportedVideoExportStatus {
  Complete = 'complete',
  Failed = 'failed',
  Pending = 'pending',
  Processing = 'processing'
}

/** ImportedVideoImportStatus is enum for the field import_status */
export enum ImportedVideoImportStatus {
  Complete = 'complete',
  Failed = 'failed',
  Pending = 'pending',
  Processing = 'processing'
}

/** Ordering options for ImportedVideo connections */
export type ImportedVideoOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order ImportedVideos. */
  field: ImportedVideoOrderField;
};

/** Properties by which ImportedVideo connections can be ordered. */
export enum ImportedVideoOrderField {
  CreatedAt = 'CREATED_AT',
  SourceCreatedAt = 'SOURCE_CREATED_AT'
}

/** ImportedVideoType is enum for the field type */
export enum ImportedVideoType {
  Drive = 'drive',
  Instagram = 'instagram',
  Tiktok = 'tiktok',
  Youtube = 'youtube'
}

/**
 * ImportedVideoWhereInput is used for filtering ImportedVideo objects.
 * Input was generated by ent.
 */
export type ImportedVideoWhereInput = {
  /** account_connection_id field predicates */
  accountConnectionID?: InputMaybe<Scalars['ID']['input']>;
  accountConnectionIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  accountConnectionIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  accountConnectionIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** account_id field predicates */
  accountID?: InputMaybe<Scalars['String']['input']>;
  accountIDContains?: InputMaybe<Scalars['String']['input']>;
  accountIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  accountIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  accountIDGT?: InputMaybe<Scalars['String']['input']>;
  accountIDGTE?: InputMaybe<Scalars['String']['input']>;
  accountIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  accountIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  accountIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  accountIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  accountIDLT?: InputMaybe<Scalars['String']['input']>;
  accountIDLTE?: InputMaybe<Scalars['String']['input']>;
  accountIDNEQ?: InputMaybe<Scalars['String']['input']>;
  accountIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  accountIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  and?: InputMaybe<Array<ImportedVideoWhereInput>>;
  /** body field predicates */
  body?: InputMaybe<Scalars['String']['input']>;
  bodyContains?: InputMaybe<Scalars['String']['input']>;
  bodyContainsFold?: InputMaybe<Scalars['String']['input']>;
  bodyEqualFold?: InputMaybe<Scalars['String']['input']>;
  bodyGT?: InputMaybe<Scalars['String']['input']>;
  bodyGTE?: InputMaybe<Scalars['String']['input']>;
  bodyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bodyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bodyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bodyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bodyLT?: InputMaybe<Scalars['String']['input']>;
  bodyLTE?: InputMaybe<Scalars['String']['input']>;
  bodyNEQ?: InputMaybe<Scalars['String']['input']>;
  bodyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bodyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** bucket field predicates */
  bucket?: InputMaybe<Scalars['String']['input']>;
  bucketContains?: InputMaybe<Scalars['String']['input']>;
  bucketContainsFold?: InputMaybe<Scalars['String']['input']>;
  bucketEqualFold?: InputMaybe<Scalars['String']['input']>;
  bucketGT?: InputMaybe<Scalars['String']['input']>;
  bucketGTE?: InputMaybe<Scalars['String']['input']>;
  bucketHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bucketHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bucketIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bucketIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bucketLT?: InputMaybe<Scalars['String']['input']>;
  bucketLTE?: InputMaybe<Scalars['String']['input']>;
  bucketNEQ?: InputMaybe<Scalars['String']['input']>;
  bucketNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bucketNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** export_status field predicates */
  exportStatus?: InputMaybe<ImportedVideoExportStatus>;
  exportStatusIn?: InputMaybe<Array<ImportedVideoExportStatus>>;
  exportStatusIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  exportStatusNEQ?: InputMaybe<ImportedVideoExportStatus>;
  exportStatusNotIn?: InputMaybe<Array<ImportedVideoExportStatus>>;
  exportStatusNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** exported_at field predicates */
  exportedAt?: InputMaybe<Scalars['Time']['input']>;
  exportedAtGT?: InputMaybe<Scalars['Time']['input']>;
  exportedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  exportedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  exportedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  exportedAtLT?: InputMaybe<Scalars['Time']['input']>;
  exportedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  exportedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  exportedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  exportedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** account_connection edge predicates */
  hasAccountConnection?: InputMaybe<Scalars['Boolean']['input']>;
  hasAccountConnectionWith?: InputMaybe<Array<AccountConnectionWhereInput>>;
  /** exported_video edge predicates */
  hasExportedVideo?: InputMaybe<Scalars['Boolean']['input']>;
  hasExportedVideoWith?: InputMaybe<Array<VideoWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** ignored field predicates */
  ignored?: InputMaybe<Scalars['Boolean']['input']>;
  ignoredNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** import_status field predicates */
  importStatus?: InputMaybe<ImportedVideoImportStatus>;
  importStatusIn?: InputMaybe<Array<ImportedVideoImportStatus>>;
  importStatusNEQ?: InputMaybe<ImportedVideoImportStatus>;
  importStatusNotIn?: InputMaybe<Array<ImportedVideoImportStatus>>;
  not?: InputMaybe<ImportedVideoWhereInput>;
  or?: InputMaybe<Array<ImportedVideoWhereInput>>;
  /** source_created_at field predicates */
  sourceCreatedAt?: InputMaybe<Scalars['Time']['input']>;
  sourceCreatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  sourceCreatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  sourceCreatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  sourceCreatedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  sourceCreatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  sourceCreatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  sourceCreatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  sourceCreatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  sourceCreatedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** storage_key field predicates */
  storageKey?: InputMaybe<Scalars['String']['input']>;
  storageKeyContains?: InputMaybe<Scalars['String']['input']>;
  storageKeyContainsFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyEqualFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyGT?: InputMaybe<Scalars['String']['input']>;
  storageKeyGTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  storageKeyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  storageKeyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  storageKeyLT?: InputMaybe<Scalars['String']['input']>;
  storageKeyLTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyNEQ?: InputMaybe<Scalars['String']['input']>;
  storageKeyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  storageKeyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** type field predicates */
  type?: InputMaybe<ImportedVideoType>;
  typeIn?: InputMaybe<Array<ImportedVideoType>>;
  typeNEQ?: InputMaybe<ImportedVideoType>;
  typeNotIn?: InputMaybe<Array<ImportedVideoType>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** video_id field predicates */
  videoID?: InputMaybe<Scalars['String']['input']>;
  videoIDContains?: InputMaybe<Scalars['String']['input']>;
  videoIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  videoIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  videoIDGT?: InputMaybe<Scalars['String']['input']>;
  videoIDGTE?: InputMaybe<Scalars['String']['input']>;
  videoIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  videoIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  videoIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  videoIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  videoIDLT?: InputMaybe<Scalars['String']['input']>;
  videoIDLTE?: InputMaybe<Scalars['String']['input']>;
  videoIDNEQ?: InputMaybe<Scalars['String']['input']>;
  videoIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  videoIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** workflow_id field predicates */
  workflowID?: InputMaybe<Scalars['String']['input']>;
  workflowIDContains?: InputMaybe<Scalars['String']['input']>;
  workflowIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  workflowIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  workflowIDGT?: InputMaybe<Scalars['String']['input']>;
  workflowIDGTE?: InputMaybe<Scalars['String']['input']>;
  workflowIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  workflowIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  workflowIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  workflowIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  workflowIDLT?: InputMaybe<Scalars['String']['input']>;
  workflowIDLTE?: InputMaybe<Scalars['String']['input']>;
  workflowIDNEQ?: InputMaybe<Scalars['String']['input']>;
  workflowIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  workflowIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** workflow_run_id field predicates */
  workflowRunID?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDContains?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDGT?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDGTE?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  workflowRunIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  workflowRunIDLT?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDLTE?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDNEQ?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  workflowRunIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export enum InsightRefreshType {
  DiscussionPoints = 'DiscussionPoints',
  LearningObjectives = 'LearningObjectives',
  SuggestTitleAndBody = 'SuggestTitleAndBody',
  SuggestTopics = 'SuggestTopics'
}

export type InsightRequest = Node & {
  __typename?: 'InsightRequest';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  insightType?: Maybe<Scalars['String']['output']>;
  insightValue?: Maybe<Scalars['String']['output']>;
  storageKey: Scalars['String']['output'];
};

/**
 * InsightRequestWhereInput is used for filtering InsightRequest objects.
 * Input was generated by ent.
 */
export type InsightRequestWhereInput = {
  and?: InputMaybe<Array<InsightRequestWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** insight_type field predicates */
  insightType?: InputMaybe<Scalars['String']['input']>;
  insightTypeContains?: InputMaybe<Scalars['String']['input']>;
  insightTypeContainsFold?: InputMaybe<Scalars['String']['input']>;
  insightTypeEqualFold?: InputMaybe<Scalars['String']['input']>;
  insightTypeGT?: InputMaybe<Scalars['String']['input']>;
  insightTypeGTE?: InputMaybe<Scalars['String']['input']>;
  insightTypeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  insightTypeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  insightTypeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  insightTypeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  insightTypeLT?: InputMaybe<Scalars['String']['input']>;
  insightTypeLTE?: InputMaybe<Scalars['String']['input']>;
  insightTypeNEQ?: InputMaybe<Scalars['String']['input']>;
  insightTypeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  insightTypeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** insight_value field predicates */
  insightValue?: InputMaybe<Scalars['String']['input']>;
  insightValueContains?: InputMaybe<Scalars['String']['input']>;
  insightValueContainsFold?: InputMaybe<Scalars['String']['input']>;
  insightValueEqualFold?: InputMaybe<Scalars['String']['input']>;
  insightValueGT?: InputMaybe<Scalars['String']['input']>;
  insightValueGTE?: InputMaybe<Scalars['String']['input']>;
  insightValueHasPrefix?: InputMaybe<Scalars['String']['input']>;
  insightValueHasSuffix?: InputMaybe<Scalars['String']['input']>;
  insightValueIn?: InputMaybe<Array<Scalars['String']['input']>>;
  insightValueIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  insightValueLT?: InputMaybe<Scalars['String']['input']>;
  insightValueLTE?: InputMaybe<Scalars['String']['input']>;
  insightValueNEQ?: InputMaybe<Scalars['String']['input']>;
  insightValueNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  insightValueNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<InsightRequestWhereInput>;
  or?: InputMaybe<Array<InsightRequestWhereInput>>;
  /** storage_key field predicates */
  storageKey?: InputMaybe<Scalars['String']['input']>;
  storageKeyContains?: InputMaybe<Scalars['String']['input']>;
  storageKeyContainsFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyEqualFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyGT?: InputMaybe<Scalars['String']['input']>;
  storageKeyGTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  storageKeyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  storageKeyLT?: InputMaybe<Scalars['String']['input']>;
  storageKeyLTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyNEQ?: InputMaybe<Scalars['String']['input']>;
  storageKeyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type InstagramScrapeLog = Node & {
  __typename?: 'InstagramScrapeLog';
  accountConnection: AccountConnection;
  accountConnectionID: Scalars['ID']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  /** The data from the scrape */
  request?: Maybe<Scalars['Map']['output']>;
  /** The data from the scrape */
  response?: Maybe<Scalars['Map']['output']>;
  workflowID?: Maybe<Scalars['String']['output']>;
  workflowRunID?: Maybe<Scalars['String']['output']>;
};

/**
 * InstagramScrapeLogWhereInput is used for filtering InstagramScrapeLog objects.
 * Input was generated by ent.
 */
export type InstagramScrapeLogWhereInput = {
  /** account_connection_id field predicates */
  accountConnectionID?: InputMaybe<Scalars['ID']['input']>;
  accountConnectionIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  accountConnectionIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  accountConnectionIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  and?: InputMaybe<Array<InstagramScrapeLogWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** account_connection edge predicates */
  hasAccountConnection?: InputMaybe<Scalars['Boolean']['input']>;
  hasAccountConnectionWith?: InputMaybe<Array<AccountConnectionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<InstagramScrapeLogWhereInput>;
  or?: InputMaybe<Array<InstagramScrapeLogWhereInput>>;
  /** workflow_id field predicates */
  workflowID?: InputMaybe<Scalars['String']['input']>;
  workflowIDContains?: InputMaybe<Scalars['String']['input']>;
  workflowIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  workflowIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  workflowIDGT?: InputMaybe<Scalars['String']['input']>;
  workflowIDGTE?: InputMaybe<Scalars['String']['input']>;
  workflowIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  workflowIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  workflowIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  workflowIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  workflowIDLT?: InputMaybe<Scalars['String']['input']>;
  workflowIDLTE?: InputMaybe<Scalars['String']['input']>;
  workflowIDNEQ?: InputMaybe<Scalars['String']['input']>;
  workflowIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  workflowIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** workflow_run_id field predicates */
  workflowRunID?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDContains?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDGT?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDGTE?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  workflowRunIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  workflowRunIDLT?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDLTE?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDNEQ?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  workflowRunIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type JobHistory = Node & {
  __typename?: 'JobHistory';
  /** The time the job ended */
  endedAt?: Maybe<Scalars['Time']['output']>;
  /** The ID of the entity the job is processing */
  entityID?: Maybe<Scalars['Int']['output']>;
  /** The type of entity the job is processing */
  entityType?: Maybe<Scalars['String']['output']>;
  /** The error message if the job failed */
  error?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** Job Name */
  jobName: Scalars['String']['output'];
  /** The time the job started */
  startedAt: Scalars['Time']['output'];
  /** Status of the job */
  status: JobHistoryStatus;
};

/** A connection to a list of items. */
export type JobHistoryConnection = {
  __typename?: 'JobHistoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<JobHistoryEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type JobHistoryEdge = {
  __typename?: 'JobHistoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<JobHistory>;
};

/** JobHistoryStatus is enum for the field status */
export enum JobHistoryStatus {
  Failed = 'failed',
  Running = 'running',
  Success = 'success'
}

/**
 * JobHistoryWhereInput is used for filtering JobHistory objects.
 * Input was generated by ent.
 */
export type JobHistoryWhereInput = {
  and?: InputMaybe<Array<JobHistoryWhereInput>>;
  /** ended_at field predicates */
  endedAt?: InputMaybe<Scalars['Time']['input']>;
  endedAtGT?: InputMaybe<Scalars['Time']['input']>;
  endedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  endedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  endedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  endedAtLT?: InputMaybe<Scalars['Time']['input']>;
  endedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  endedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  endedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  endedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** entity_id field predicates */
  entityID?: InputMaybe<Scalars['Int']['input']>;
  entityIDGT?: InputMaybe<Scalars['Int']['input']>;
  entityIDGTE?: InputMaybe<Scalars['Int']['input']>;
  entityIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  entityIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  entityIDLT?: InputMaybe<Scalars['Int']['input']>;
  entityIDLTE?: InputMaybe<Scalars['Int']['input']>;
  entityIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  entityIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  entityIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** entity_type field predicates */
  entityType?: InputMaybe<Scalars['String']['input']>;
  entityTypeContains?: InputMaybe<Scalars['String']['input']>;
  entityTypeContainsFold?: InputMaybe<Scalars['String']['input']>;
  entityTypeEqualFold?: InputMaybe<Scalars['String']['input']>;
  entityTypeGT?: InputMaybe<Scalars['String']['input']>;
  entityTypeGTE?: InputMaybe<Scalars['String']['input']>;
  entityTypeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  entityTypeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  entityTypeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  entityTypeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  entityTypeLT?: InputMaybe<Scalars['String']['input']>;
  entityTypeLTE?: InputMaybe<Scalars['String']['input']>;
  entityTypeNEQ?: InputMaybe<Scalars['String']['input']>;
  entityTypeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  entityTypeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** error field predicates */
  error?: InputMaybe<Scalars['String']['input']>;
  errorContains?: InputMaybe<Scalars['String']['input']>;
  errorContainsFold?: InputMaybe<Scalars['String']['input']>;
  errorEqualFold?: InputMaybe<Scalars['String']['input']>;
  errorGT?: InputMaybe<Scalars['String']['input']>;
  errorGTE?: InputMaybe<Scalars['String']['input']>;
  errorHasPrefix?: InputMaybe<Scalars['String']['input']>;
  errorHasSuffix?: InputMaybe<Scalars['String']['input']>;
  errorIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  errorLT?: InputMaybe<Scalars['String']['input']>;
  errorLTE?: InputMaybe<Scalars['String']['input']>;
  errorNEQ?: InputMaybe<Scalars['String']['input']>;
  errorNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** job_name field predicates */
  jobName?: InputMaybe<Scalars['String']['input']>;
  jobNameContains?: InputMaybe<Scalars['String']['input']>;
  jobNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  jobNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  jobNameGT?: InputMaybe<Scalars['String']['input']>;
  jobNameGTE?: InputMaybe<Scalars['String']['input']>;
  jobNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  jobNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  jobNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  jobNameLT?: InputMaybe<Scalars['String']['input']>;
  jobNameLTE?: InputMaybe<Scalars['String']['input']>;
  jobNameNEQ?: InputMaybe<Scalars['String']['input']>;
  jobNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<JobHistoryWhereInput>;
  or?: InputMaybe<Array<JobHistoryWhereInput>>;
  /** started_at field predicates */
  startedAt?: InputMaybe<Scalars['Time']['input']>;
  startedAtGT?: InputMaybe<Scalars['Time']['input']>;
  startedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  startedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startedAtLT?: InputMaybe<Scalars['Time']['input']>;
  startedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  startedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  startedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** status field predicates */
  status?: InputMaybe<JobHistoryStatus>;
  statusIn?: InputMaybe<Array<JobHistoryStatus>>;
  statusNEQ?: InputMaybe<JobHistoryStatus>;
  statusNotIn?: InputMaybe<Array<JobHistoryStatus>>;
};

export type JoinWaitListInput = {
  email?: InputMaybe<Scalars['String']['input']>;
  firstName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
  npiNumber?: InputMaybe<Scalars['String']['input']>;
  phone: Scalars['String']['input'];
};

export type Journal = {
  __typename?: 'Journal';
  isoAbbreviation?: Maybe<Scalars['String']['output']>;
  issn?: Maybe<Scalars['String']['output']>;
  issue?: Maybe<Scalars['String']['output']>;
  pubDate?: Maybe<Scalars['Time']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  volume?: Maybe<Scalars['String']['output']>;
};

export type KeyIndicator = {
  __typename?: 'KeyIndicator';
  deltaFromLastWeek: Scalars['String']['output'];
  name: Scalars['String']['output'];
  value: Scalars['String']['output'];
};

export type LanguageModelLog = Node & {
  __typename?: 'LanguageModelLog';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  model: Scalars['String']['output'];
  provider: Scalars['String']['output'];
  request: Scalars['String']['output'];
  response: Scalars['String']['output'];
  statusCode: Scalars['Int']['output'];
};

/** Ordering options for LanguageModelLog connections */
export type LanguageModelLogOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order LanguageModelLogs. */
  field: LanguageModelLogOrderField;
};

/** Properties by which LanguageModelLog connections can be ordered. */
export enum LanguageModelLogOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * LanguageModelLogWhereInput is used for filtering LanguageModelLog objects.
 * Input was generated by ent.
 */
export type LanguageModelLogWhereInput = {
  and?: InputMaybe<Array<LanguageModelLogWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** model field predicates */
  model?: InputMaybe<Scalars['String']['input']>;
  modelContains?: InputMaybe<Scalars['String']['input']>;
  modelContainsFold?: InputMaybe<Scalars['String']['input']>;
  modelEqualFold?: InputMaybe<Scalars['String']['input']>;
  modelGT?: InputMaybe<Scalars['String']['input']>;
  modelGTE?: InputMaybe<Scalars['String']['input']>;
  modelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  modelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  modelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelLT?: InputMaybe<Scalars['String']['input']>;
  modelLTE?: InputMaybe<Scalars['String']['input']>;
  modelNEQ?: InputMaybe<Scalars['String']['input']>;
  modelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<LanguageModelLogWhereInput>;
  or?: InputMaybe<Array<LanguageModelLogWhereInput>>;
  /** provider field predicates */
  provider?: InputMaybe<Scalars['String']['input']>;
  providerContains?: InputMaybe<Scalars['String']['input']>;
  providerContainsFold?: InputMaybe<Scalars['String']['input']>;
  providerEqualFold?: InputMaybe<Scalars['String']['input']>;
  providerGT?: InputMaybe<Scalars['String']['input']>;
  providerGTE?: InputMaybe<Scalars['String']['input']>;
  providerHasPrefix?: InputMaybe<Scalars['String']['input']>;
  providerHasSuffix?: InputMaybe<Scalars['String']['input']>;
  providerIn?: InputMaybe<Array<Scalars['String']['input']>>;
  providerLT?: InputMaybe<Scalars['String']['input']>;
  providerLTE?: InputMaybe<Scalars['String']['input']>;
  providerNEQ?: InputMaybe<Scalars['String']['input']>;
  providerNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** request field predicates */
  request?: InputMaybe<Scalars['String']['input']>;
  requestContains?: InputMaybe<Scalars['String']['input']>;
  requestContainsFold?: InputMaybe<Scalars['String']['input']>;
  requestEqualFold?: InputMaybe<Scalars['String']['input']>;
  requestGT?: InputMaybe<Scalars['String']['input']>;
  requestGTE?: InputMaybe<Scalars['String']['input']>;
  requestHasPrefix?: InputMaybe<Scalars['String']['input']>;
  requestHasSuffix?: InputMaybe<Scalars['String']['input']>;
  requestIn?: InputMaybe<Array<Scalars['String']['input']>>;
  requestLT?: InputMaybe<Scalars['String']['input']>;
  requestLTE?: InputMaybe<Scalars['String']['input']>;
  requestNEQ?: InputMaybe<Scalars['String']['input']>;
  requestNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** response field predicates */
  response?: InputMaybe<Scalars['String']['input']>;
  responseContains?: InputMaybe<Scalars['String']['input']>;
  responseContainsFold?: InputMaybe<Scalars['String']['input']>;
  responseEqualFold?: InputMaybe<Scalars['String']['input']>;
  responseGT?: InputMaybe<Scalars['String']['input']>;
  responseGTE?: InputMaybe<Scalars['String']['input']>;
  responseHasPrefix?: InputMaybe<Scalars['String']['input']>;
  responseHasSuffix?: InputMaybe<Scalars['String']['input']>;
  responseIn?: InputMaybe<Array<Scalars['String']['input']>>;
  responseLT?: InputMaybe<Scalars['String']['input']>;
  responseLTE?: InputMaybe<Scalars['String']['input']>;
  responseNEQ?: InputMaybe<Scalars['String']['input']>;
  responseNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** status_code field predicates */
  statusCode?: InputMaybe<Scalars['Int']['input']>;
  statusCodeGT?: InputMaybe<Scalars['Int']['input']>;
  statusCodeGTE?: InputMaybe<Scalars['Int']['input']>;
  statusCodeIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  statusCodeLT?: InputMaybe<Scalars['Int']['input']>;
  statusCodeLTE?: InputMaybe<Scalars['Int']['input']>;
  statusCodeNEQ?: InputMaybe<Scalars['Int']['input']>;
  statusCodeNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type LanguageModelResponse = Node & {
  __typename?: 'LanguageModelResponse';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  model: Scalars['String']['output'];
  response: Scalars['Map']['output'];
  sparkyMessage?: Maybe<SparkyMessage>;
};

/**
 * LanguageModelResponseWhereInput is used for filtering LanguageModelResponse objects.
 * Input was generated by ent.
 */
export type LanguageModelResponseWhereInput = {
  and?: InputMaybe<Array<LanguageModelResponseWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** sparky_message edge predicates */
  hasSparkyMessage?: InputMaybe<Scalars['Boolean']['input']>;
  hasSparkyMessageWith?: InputMaybe<Array<SparkyMessageWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** model field predicates */
  model?: InputMaybe<Scalars['String']['input']>;
  modelContains?: InputMaybe<Scalars['String']['input']>;
  modelContainsFold?: InputMaybe<Scalars['String']['input']>;
  modelEqualFold?: InputMaybe<Scalars['String']['input']>;
  modelGT?: InputMaybe<Scalars['String']['input']>;
  modelGTE?: InputMaybe<Scalars['String']['input']>;
  modelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  modelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  modelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelLT?: InputMaybe<Scalars['String']['input']>;
  modelLTE?: InputMaybe<Scalars['String']['input']>;
  modelNEQ?: InputMaybe<Scalars['String']['input']>;
  modelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<LanguageModelResponseWhereInput>;
  or?: InputMaybe<Array<LanguageModelResponseWhereInput>>;
};

export type LearningObjective = Node & {
  __typename?: 'LearningObjective';
  /** The survey questions that have this learning objective. */
  certificateSurveyQuestions?: Maybe<Array<CertificateSurveyQuestion>>;
  /** The credits that have this learning objective. */
  educationCredits?: Maybe<Array<EducationCredit>>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  postlearningobjectives?: Maybe<Array<PostLearningObjective>>;
  /** The posts that have this learning objective. */
  posts?: Maybe<Array<Post>>;
  surveyQuestion?: Maybe<Scalars['String']['output']>;
  /** The tenant that the topic belongs to. */
  tenant?: Maybe<Tenant>;
  videos?: Maybe<Array<Video>>;
};

/** A connection to a list of items. */
export type LearningObjectiveConnection = {
  __typename?: 'LearningObjectiveConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LearningObjectiveEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type LearningObjectiveEdge = {
  __typename?: 'LearningObjectiveEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<LearningObjective>;
};

/**
 * LearningObjectiveWhereInput is used for filtering LearningObjective objects.
 * Input was generated by ent.
 */
export type LearningObjectiveWhereInput = {
  and?: InputMaybe<Array<LearningObjectiveWhereInput>>;
  /** certificate_survey_questions edge predicates */
  hasCertificateSurveyQuestions?: InputMaybe<Scalars['Boolean']['input']>;
  hasCertificateSurveyQuestionsWith?: InputMaybe<Array<CertificateSurveyQuestionWhereInput>>;
  /** education_credits edge predicates */
  hasEducationCredits?: InputMaybe<Scalars['Boolean']['input']>;
  hasEducationCreditsWith?: InputMaybe<Array<EducationCreditWhereInput>>;
  /** postlearningobjectives edge predicates */
  hasPostlearningobjectives?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostlearningobjectivesWith?: InputMaybe<Array<PostLearningObjectiveWhereInput>>;
  /** posts edge predicates */
  hasPosts?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']['input']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** videos edge predicates */
  hasVideos?: InputMaybe<Scalars['Boolean']['input']>;
  hasVideosWith?: InputMaybe<Array<VideoWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<LearningObjectiveWhereInput>;
  or?: InputMaybe<Array<LearningObjectiveWhereInput>>;
  /** survey_question field predicates */
  surveyQuestion?: InputMaybe<Scalars['String']['input']>;
  surveyQuestionContains?: InputMaybe<Scalars['String']['input']>;
  surveyQuestionContainsFold?: InputMaybe<Scalars['String']['input']>;
  surveyQuestionEqualFold?: InputMaybe<Scalars['String']['input']>;
  surveyQuestionGT?: InputMaybe<Scalars['String']['input']>;
  surveyQuestionGTE?: InputMaybe<Scalars['String']['input']>;
  surveyQuestionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  surveyQuestionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  surveyQuestionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  surveyQuestionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  surveyQuestionLT?: InputMaybe<Scalars['String']['input']>;
  surveyQuestionLTE?: InputMaybe<Scalars['String']['input']>;
  surveyQuestionNEQ?: InputMaybe<Scalars['String']['input']>;
  surveyQuestionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  surveyQuestionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type LicenseHistory = Node & {
  __typename?: 'LicenseHistory';
  endDate?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  /** The institution that issued the license. */
  institution?: Maybe<Scalars['String']['output']>;
  /** The license number. */
  licenseNumber?: Maybe<Scalars['String']['output']>;
  startDate?: Maybe<Scalars['Time']['output']>;
  /** The state in which the license was issued. */
  state?: Maybe<Scalars['String']['output']>;
  /** The title of the license. */
  title: Scalars['String']['output'];
  /** License history for a user. */
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type LicenseHistoryConnection = {
  __typename?: 'LicenseHistoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LicenseHistoryEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type LicenseHistoryEdge = {
  __typename?: 'LicenseHistoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<LicenseHistory>;
};

/**
 * LicenseHistoryWhereInput is used for filtering LicenseHistory objects.
 * Input was generated by ent.
 */
export type LicenseHistoryWhereInput = {
  and?: InputMaybe<Array<LicenseHistoryWhereInput>>;
  /** end_date field predicates */
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endDateGT?: InputMaybe<Scalars['Time']['input']>;
  endDateGTE?: InputMaybe<Scalars['Time']['input']>;
  endDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  endDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  endDateLT?: InputMaybe<Scalars['Time']['input']>;
  endDateLTE?: InputMaybe<Scalars['Time']['input']>;
  endDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  endDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  endDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** institution field predicates */
  institution?: InputMaybe<Scalars['String']['input']>;
  institutionContains?: InputMaybe<Scalars['String']['input']>;
  institutionContainsFold?: InputMaybe<Scalars['String']['input']>;
  institutionEqualFold?: InputMaybe<Scalars['String']['input']>;
  institutionGT?: InputMaybe<Scalars['String']['input']>;
  institutionGTE?: InputMaybe<Scalars['String']['input']>;
  institutionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  institutionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  institutionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  institutionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  institutionLT?: InputMaybe<Scalars['String']['input']>;
  institutionLTE?: InputMaybe<Scalars['String']['input']>;
  institutionNEQ?: InputMaybe<Scalars['String']['input']>;
  institutionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  institutionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** license_number field predicates */
  licenseNumber?: InputMaybe<Scalars['String']['input']>;
  licenseNumberContains?: InputMaybe<Scalars['String']['input']>;
  licenseNumberContainsFold?: InputMaybe<Scalars['String']['input']>;
  licenseNumberEqualFold?: InputMaybe<Scalars['String']['input']>;
  licenseNumberGT?: InputMaybe<Scalars['String']['input']>;
  licenseNumberGTE?: InputMaybe<Scalars['String']['input']>;
  licenseNumberHasPrefix?: InputMaybe<Scalars['String']['input']>;
  licenseNumberHasSuffix?: InputMaybe<Scalars['String']['input']>;
  licenseNumberIn?: InputMaybe<Array<Scalars['String']['input']>>;
  licenseNumberIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  licenseNumberLT?: InputMaybe<Scalars['String']['input']>;
  licenseNumberLTE?: InputMaybe<Scalars['String']['input']>;
  licenseNumberNEQ?: InputMaybe<Scalars['String']['input']>;
  licenseNumberNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  licenseNumberNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<LicenseHistoryWhereInput>;
  or?: InputMaybe<Array<LicenseHistoryWhereInput>>;
  /** start_date field predicates */
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startDateGT?: InputMaybe<Scalars['Time']['input']>;
  startDateGTE?: InputMaybe<Scalars['Time']['input']>;
  startDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  startDateLT?: InputMaybe<Scalars['Time']['input']>;
  startDateLTE?: InputMaybe<Scalars['Time']['input']>;
  startDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  startDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** state field predicates */
  state?: InputMaybe<Scalars['String']['input']>;
  stateContains?: InputMaybe<Scalars['String']['input']>;
  stateContainsFold?: InputMaybe<Scalars['String']['input']>;
  stateEqualFold?: InputMaybe<Scalars['String']['input']>;
  stateGT?: InputMaybe<Scalars['String']['input']>;
  stateGTE?: InputMaybe<Scalars['String']['input']>;
  stateHasPrefix?: InputMaybe<Scalars['String']['input']>;
  stateHasSuffix?: InputMaybe<Scalars['String']['input']>;
  stateIn?: InputMaybe<Array<Scalars['String']['input']>>;
  stateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  stateLT?: InputMaybe<Scalars['String']['input']>;
  stateLTE?: InputMaybe<Scalars['String']['input']>;
  stateNEQ?: InputMaybe<Scalars['String']['input']>;
  stateNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  stateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type LicenseSuggestion = {
  __typename?: 'LicenseSuggestion';
  licenseNumber: Scalars['String']['output'];
  state: Scalars['String']['output'];
};

export type LicenseSuggestionRoot = {
  __typename?: 'LicenseSuggestionRoot';
  boards: Array<CertifyingBoard>;
  licenses: Array<LicenseHistory>;
};

export type Like = Node & {
  __typename?: 'Like';
  id: Scalars['ID']['output'];
  /** The time that the user liked the post.  */
  likedAt: Scalars['Time']['output'];
  /** The post that the user liked. */
  post: Post;
  postID: Scalars['ID']['output'];
  /** The user that created this like. */
  user: User;
  userID: Scalars['ID']['output'];
};

export type LikeCommentInput = {
  commentId: Scalars['ID']['input'];
};

/** A connection to a list of items. */
export type LikeConnection = {
  __typename?: 'LikeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LikeEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type LikeEdge = {
  __typename?: 'LikeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Like>;
};

/** Ordering options for Like connections */
export type LikeOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Likes. */
  field: LikeOrderField;
};

/** Properties by which Like connections can be ordered. */
export enum LikeOrderField {
  LikedAt = 'LIKED_AT'
}

export type LikePostInput = {
  postId: Scalars['ID']['input'];
};

/**
 * LikeWhereInput is used for filtering Like objects.
 * Input was generated by ent.
 */
export type LikeWhereInput = {
  and?: InputMaybe<Array<LikeWhereInput>>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** liked_at field predicates */
  likedAt?: InputMaybe<Scalars['Time']['input']>;
  likedAtGT?: InputMaybe<Scalars['Time']['input']>;
  likedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  likedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  likedAtLT?: InputMaybe<Scalars['Time']['input']>;
  likedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  likedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  likedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  not?: InputMaybe<LikeWhereInput>;
  or?: InputMaybe<Array<LikeWhereInput>>;
};

export type LoginResponse = {
  __typename?: 'LoginResponse';
  expiresAt?: Maybe<Scalars['Time']['output']>;
  /** A signed JWT token with the user's ID and Name as the payload. Used in the GRPC api */
  jwt?: Maybe<Scalars['String']['output']>;
  /** The value to use as the bearer token with the graphql api */
  token: Scalars['String']['output'];
  user: User;
};

export type MarkNotificationsAsRead = {
  ids: Array<Scalars['ID']['input']>;
};

export type MediaItem = Node & {
  __typename?: 'MediaItem';
  /** The size of the media item in bytes. */
  bytes: Scalars['Int']['output'];
  /** The duration of the media item in seconds. */
  duration?: Maybe<Scalars['Int']['output']>;
  /** The format of the media item. ie jpg, png, gif, etc. */
  format: Scalars['String']['output'];
  /** The height of the media item in pixels. */
  height: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  /** The type of media item. Will be image or video */
  mediaType: Scalars['String']['output'];
  ordinal: Scalars['Int']['output'];
  /** The original filename of the media item. */
  originalFilename: Scalars['String']['output'];
  /** The post that the media item belongs to. */
  post?: Maybe<Post>;
  /** [Deprecated] The public ID in Cloudinary of the media item. */
  publicID: Scalars['String']['output'];
  /** The URL of the media item. */
  url: Scalars['String']['output'];
  /** The width of the media item in pixels. */
  width: Scalars['Int']['output'];
};

/** A connection to a list of items. */
export type MediaItemConnection = {
  __typename?: 'MediaItemConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MediaItemEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type MediaItemEdge = {
  __typename?: 'MediaItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<MediaItem>;
};

/**
 * MediaItemWhereInput is used for filtering MediaItem objects.
 * Input was generated by ent.
 */
export type MediaItemWhereInput = {
  and?: InputMaybe<Array<MediaItemWhereInput>>;
  /** bytes field predicates */
  bytes?: InputMaybe<Scalars['Int']['input']>;
  bytesGT?: InputMaybe<Scalars['Int']['input']>;
  bytesGTE?: InputMaybe<Scalars['Int']['input']>;
  bytesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  bytesLT?: InputMaybe<Scalars['Int']['input']>;
  bytesLTE?: InputMaybe<Scalars['Int']['input']>;
  bytesNEQ?: InputMaybe<Scalars['Int']['input']>;
  bytesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** duration field predicates */
  duration?: InputMaybe<Scalars['Int']['input']>;
  durationGT?: InputMaybe<Scalars['Int']['input']>;
  durationGTE?: InputMaybe<Scalars['Int']['input']>;
  durationIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  durationIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  durationLT?: InputMaybe<Scalars['Int']['input']>;
  durationLTE?: InputMaybe<Scalars['Int']['input']>;
  durationNEQ?: InputMaybe<Scalars['Int']['input']>;
  durationNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  durationNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** format field predicates */
  format?: InputMaybe<Scalars['String']['input']>;
  formatContains?: InputMaybe<Scalars['String']['input']>;
  formatContainsFold?: InputMaybe<Scalars['String']['input']>;
  formatEqualFold?: InputMaybe<Scalars['String']['input']>;
  formatGT?: InputMaybe<Scalars['String']['input']>;
  formatGTE?: InputMaybe<Scalars['String']['input']>;
  formatHasPrefix?: InputMaybe<Scalars['String']['input']>;
  formatHasSuffix?: InputMaybe<Scalars['String']['input']>;
  formatIn?: InputMaybe<Array<Scalars['String']['input']>>;
  formatLT?: InputMaybe<Scalars['String']['input']>;
  formatLTE?: InputMaybe<Scalars['String']['input']>;
  formatNEQ?: InputMaybe<Scalars['String']['input']>;
  formatNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** height field predicates */
  height?: InputMaybe<Scalars['Int']['input']>;
  heightGT?: InputMaybe<Scalars['Int']['input']>;
  heightGTE?: InputMaybe<Scalars['Int']['input']>;
  heightIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  heightLT?: InputMaybe<Scalars['Int']['input']>;
  heightLTE?: InputMaybe<Scalars['Int']['input']>;
  heightNEQ?: InputMaybe<Scalars['Int']['input']>;
  heightNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** media_type field predicates */
  mediaType?: InputMaybe<Scalars['String']['input']>;
  mediaTypeContains?: InputMaybe<Scalars['String']['input']>;
  mediaTypeContainsFold?: InputMaybe<Scalars['String']['input']>;
  mediaTypeEqualFold?: InputMaybe<Scalars['String']['input']>;
  mediaTypeGT?: InputMaybe<Scalars['String']['input']>;
  mediaTypeGTE?: InputMaybe<Scalars['String']['input']>;
  mediaTypeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  mediaTypeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  mediaTypeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  mediaTypeLT?: InputMaybe<Scalars['String']['input']>;
  mediaTypeLTE?: InputMaybe<Scalars['String']['input']>;
  mediaTypeNEQ?: InputMaybe<Scalars['String']['input']>;
  mediaTypeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<MediaItemWhereInput>;
  or?: InputMaybe<Array<MediaItemWhereInput>>;
  /** ordinal field predicates */
  ordinal?: InputMaybe<Scalars['Int']['input']>;
  ordinalGT?: InputMaybe<Scalars['Int']['input']>;
  ordinalGTE?: InputMaybe<Scalars['Int']['input']>;
  ordinalIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  ordinalLT?: InputMaybe<Scalars['Int']['input']>;
  ordinalLTE?: InputMaybe<Scalars['Int']['input']>;
  ordinalNEQ?: InputMaybe<Scalars['Int']['input']>;
  ordinalNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** original_filename field predicates */
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  originalFilenameContains?: InputMaybe<Scalars['String']['input']>;
  originalFilenameContainsFold?: InputMaybe<Scalars['String']['input']>;
  originalFilenameEqualFold?: InputMaybe<Scalars['String']['input']>;
  originalFilenameGT?: InputMaybe<Scalars['String']['input']>;
  originalFilenameGTE?: InputMaybe<Scalars['String']['input']>;
  originalFilenameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  originalFilenameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  originalFilenameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  originalFilenameLT?: InputMaybe<Scalars['String']['input']>;
  originalFilenameLTE?: InputMaybe<Scalars['String']['input']>;
  originalFilenameNEQ?: InputMaybe<Scalars['String']['input']>;
  originalFilenameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** public_id field predicates */
  publicID?: InputMaybe<Scalars['String']['input']>;
  publicIDContains?: InputMaybe<Scalars['String']['input']>;
  publicIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  publicIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  publicIDGT?: InputMaybe<Scalars['String']['input']>;
  publicIDGTE?: InputMaybe<Scalars['String']['input']>;
  publicIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  publicIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  publicIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  publicIDLT?: InputMaybe<Scalars['String']['input']>;
  publicIDLTE?: InputMaybe<Scalars['String']['input']>;
  publicIDNEQ?: InputMaybe<Scalars['String']['input']>;
  publicIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']['input']>;
  urlContains?: InputMaybe<Scalars['String']['input']>;
  urlContainsFold?: InputMaybe<Scalars['String']['input']>;
  urlEqualFold?: InputMaybe<Scalars['String']['input']>;
  urlGT?: InputMaybe<Scalars['String']['input']>;
  urlGTE?: InputMaybe<Scalars['String']['input']>;
  urlHasPrefix?: InputMaybe<Scalars['String']['input']>;
  urlHasSuffix?: InputMaybe<Scalars['String']['input']>;
  urlIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlLT?: InputMaybe<Scalars['String']['input']>;
  urlLTE?: InputMaybe<Scalars['String']['input']>;
  urlNEQ?: InputMaybe<Scalars['String']['input']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** width field predicates */
  width?: InputMaybe<Scalars['Int']['input']>;
  widthGT?: InputMaybe<Scalars['Int']['input']>;
  widthGTE?: InputMaybe<Scalars['Int']['input']>;
  widthIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  widthLT?: InputMaybe<Scalars['Int']['input']>;
  widthLTE?: InputMaybe<Scalars['Int']['input']>;
  widthNEQ?: InputMaybe<Scalars['Int']['input']>;
  widthNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type MedicalDictionaryDefinition = {
  __typename?: 'MedicalDictionaryDefinition';
  definition: Scalars['String']['output'];
  source: Scalars['String']['output'];
  word: Scalars['String']['output'];
};

export type MedicalDictionaryMatch = {
  __typename?: 'MedicalDictionaryMatch';
  word: Scalars['String']['output'];
};

export type MedicalDictionarySearchResult = {
  __typename?: 'MedicalDictionarySearchResult';
  source: Scalars['String']['output'];
  word: Scalars['String']['output'];
};

export type MedicalHealthTerm = Node & {
  __typename?: 'MedicalHealthTerm';
  definition: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  term: Scalars['String']['output'];
};

/**
 * MedicalHealthTermWhereInput is used for filtering MedicalHealthTerm objects.
 * Input was generated by ent.
 */
export type MedicalHealthTermWhereInput = {
  and?: InputMaybe<Array<MedicalHealthTermWhereInput>>;
  /** definition field predicates */
  definition?: InputMaybe<Scalars['String']['input']>;
  definitionContains?: InputMaybe<Scalars['String']['input']>;
  definitionContainsFold?: InputMaybe<Scalars['String']['input']>;
  definitionEqualFold?: InputMaybe<Scalars['String']['input']>;
  definitionGT?: InputMaybe<Scalars['String']['input']>;
  definitionGTE?: InputMaybe<Scalars['String']['input']>;
  definitionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  definitionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  definitionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  definitionLT?: InputMaybe<Scalars['String']['input']>;
  definitionLTE?: InputMaybe<Scalars['String']['input']>;
  definitionNEQ?: InputMaybe<Scalars['String']['input']>;
  definitionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<MedicalHealthTermWhereInput>;
  or?: InputMaybe<Array<MedicalHealthTermWhereInput>>;
  /** term field predicates */
  term?: InputMaybe<Scalars['String']['input']>;
  termContains?: InputMaybe<Scalars['String']['input']>;
  termContainsFold?: InputMaybe<Scalars['String']['input']>;
  termEqualFold?: InputMaybe<Scalars['String']['input']>;
  termGT?: InputMaybe<Scalars['String']['input']>;
  termGTE?: InputMaybe<Scalars['String']['input']>;
  termHasPrefix?: InputMaybe<Scalars['String']['input']>;
  termHasSuffix?: InputMaybe<Scalars['String']['input']>;
  termIn?: InputMaybe<Array<Scalars['String']['input']>>;
  termLT?: InputMaybe<Scalars['String']['input']>;
  termLTE?: InputMaybe<Scalars['String']['input']>;
  termNEQ?: InputMaybe<Scalars['String']['input']>;
  termNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type MedicalNreResult = {
  __typename?: 'MedicalNreResult';
  end?: Maybe<Scalars['Int']['output']>;
  entityGroup?: Maybe<Scalars['String']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
  start?: Maybe<Scalars['Int']['output']>;
  word?: Maybe<Scalars['String']['output']>;
};

export type MedicalSearchEvent = {
  __typename?: 'MedicalSearchEvent';
  citation?: Maybe<OpenEvidenceReference>;
  eventType: Scalars['String']['output'];
  reference?: Maybe<OpenGraphReference>;
  text: Scalars['String']['output'];
};

export type MedicalSubjectHeading = Node & {
  __typename?: 'MedicalSubjectHeading';
  descriptorUI: Scalars['String']['output'];
  entryTerms: Array<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  scopeNote?: Maybe<Scalars['String']['output']>;
  treeNumbers: Array<Scalars['String']['output']>;
};

/**
 * MedicalSubjectHeadingWhereInput is used for filtering MedicalSubjectHeading objects.
 * Input was generated by ent.
 */
export type MedicalSubjectHeadingWhereInput = {
  and?: InputMaybe<Array<MedicalSubjectHeadingWhereInput>>;
  /** descriptor_ui field predicates */
  descriptorUI?: InputMaybe<Scalars['String']['input']>;
  descriptorUIContains?: InputMaybe<Scalars['String']['input']>;
  descriptorUIContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptorUIEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptorUIGT?: InputMaybe<Scalars['String']['input']>;
  descriptorUIGTE?: InputMaybe<Scalars['String']['input']>;
  descriptorUIHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptorUIHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptorUIIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptorUILT?: InputMaybe<Scalars['String']['input']>;
  descriptorUILTE?: InputMaybe<Scalars['String']['input']>;
  descriptorUINEQ?: InputMaybe<Scalars['String']['input']>;
  descriptorUINotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<MedicalSubjectHeadingWhereInput>;
  or?: InputMaybe<Array<MedicalSubjectHeadingWhereInput>>;
  /** scope_note field predicates */
  scopeNote?: InputMaybe<Scalars['String']['input']>;
  scopeNoteContains?: InputMaybe<Scalars['String']['input']>;
  scopeNoteContainsFold?: InputMaybe<Scalars['String']['input']>;
  scopeNoteEqualFold?: InputMaybe<Scalars['String']['input']>;
  scopeNoteGT?: InputMaybe<Scalars['String']['input']>;
  scopeNoteGTE?: InputMaybe<Scalars['String']['input']>;
  scopeNoteHasPrefix?: InputMaybe<Scalars['String']['input']>;
  scopeNoteHasSuffix?: InputMaybe<Scalars['String']['input']>;
  scopeNoteIn?: InputMaybe<Array<Scalars['String']['input']>>;
  scopeNoteIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  scopeNoteLT?: InputMaybe<Scalars['String']['input']>;
  scopeNoteLTE?: InputMaybe<Scalars['String']['input']>;
  scopeNoteNEQ?: InputMaybe<Scalars['String']['input']>;
  scopeNoteNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  scopeNoteNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type MeshHeading = {
  __typename?: 'MeshHeading';
  descriptorName?: Maybe<Scalars['String']['output']>;
  descriptorUI?: Maybe<Scalars['String']['output']>;
  qualifierName?: Maybe<Scalars['String']['output']>;
  qualifierUI?: Maybe<Scalars['String']['output']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  addPostToCollection: Collection;
  adminAddTaxonomyToTopic: Scalars['Boolean']['output'];
  adminAnalyzeComment: ReflectionResult;
  adminAnalyzeText: SparkyInsights;
  adminApproveEducationCredit: Scalars['Boolean']['output'];
  adminApproveFinancialDisclosure: Scalars['Boolean']['output'];
  adminAssignUserCohorts: Scalars['Boolean']['output'];
  adminBoostTrendingPosts: Array<Post>;
  adminBoostTrendingTopics: Array<Topic>;
  adminBoostTrendingUsers: Array<User>;
  adminCreateAnatomicalModel: AnatomicalModel;
  adminCreateCertifyingBoard: CertifyingBoard;
  adminCreateConversation: SparkyConversation;
  adminCreateConversationFromConversation: SparkyConversation;
  /** Identical to createConversationFromPost, but allows the admin to specify a config id */
  adminCreateConversationFromPost: SparkyConversation;
  adminCreateFinancialDisclosureRole: FinancialDisclosureRole;
  adminCreateInstagramConnection?: Maybe<AccountConnection>;
  adminCreatePostFromImportedVideo?: Maybe<Post>;
  /** Creates a new draft post from the uploaded file, represented by the given storage key. */
  adminCreatePostFromUploader: Post;
  /** Download a video from a URL and create a post from it, attributed to the user with the given ID. */
  adminCreatePostFromVideo: Post;
  adminCreateReflectionCriteria: ReflectionCriteria;
  /** Identical to createReply, but allows the admin to specify a config id */
  adminCreateReply: SparkyMessage;
  adminCreateReportReason: ReportReason;
  adminCreateSparkyChatConfig: SparkyChatConfig;
  adminCreateTiktokConnection?: Maybe<AccountConnection>;
  /** Create a Video from an uploaded file, represented by the given storage key. */
  adminCreateVideoFromUploader: Video;
  adminCreateYoutubeConnection?: Maybe<AccountConnection>;
  adminDeleteAnatomicalModel: AnatomicalModel;
  adminDeleteBookmark: Scalars['Boolean']['output'];
  adminDeleteCertifyingBoard: CertifyingBoard;
  adminDeleteComment: Scalars['Boolean']['output'];
  adminDeleteFinancialDisclosureRole: Scalars['Boolean']['output'];
  adminDeleteLike: Scalars['Boolean']['output'];
  adminDeleteNotification: Scalars['Boolean']['output'];
  adminDeleteReportReason: ReportReason;
  adminDeleteUser: User;
  adminDeleteUserCohort: Scalars['Boolean']['output'];
  adminDenyEducationCredit: Scalars['Boolean']['output'];
  adminDisableUser: User;
  adminDownloadFinancialDisclosureStatement: DownloadFinancialDisclosureStatement;
  adminEnableUser: User;
  adminIcebreakerSandbox: Scalars['String']['output'];
  adminImportImageFromURL: Image;
  /** Authenticates an admin user and returns a JWT auth token */
  adminLogin?: Maybe<LoginResponse>;
  adminRefreshInsights: Scalars['Boolean']['output'];
  adminRemoveReflectionCriteria: Scalars['Boolean']['output'];
  adminRemoveSparkyChatConfig: Scalars['Boolean']['output'];
  adminRemoveTaxonomyFromTopic: Scalars['Boolean']['output'];
  adminRevokeFinancialDisclosure: Scalars['Boolean']['output'];
  adminSparkySandbox: SparkySandboxOutput;
  adminTestSparkyRules: SparkyTestRuleResult;
  adminUnAssignUserCohorts: Scalars['Boolean']['output'];
  adminUnfollowUser: Scalars['Boolean']['output'];
  adminUpdateAnatomicalModel: AnatomicalModel;
  adminUpdateCertifyingBoard: CertifyingBoard;
  adminUpdateFinancialDisclosurePrintTemplate: FinancialDisclosurePrintTemplate;
  adminUpdateFinancialDisclosureRole: FinancialDisclosureRole;
  adminUpdateNotificationConfig: Scalars['Boolean']['output'];
  adminUpdatePostReport: PostReport;
  adminUpdateReflectionCriteria: ReflectionCriteria;
  adminUpdateReflectionCriteriaGroup: ReflectionCriteriaGroup;
  adminUpdateReportReason: ReportReason;
  adminUpdateSparkyChatConfig: SparkyChatConfig;
  adminUpdateSparkyChatConfigRules: SparkyChatConfig;
  adminUpdateUserReport: UserReport;
  /** Update a verification request for the specified user. Only admins can do this. */
  adminUpdateVerificationRequest: VerificationRequest;
  adminUpsertUserCohort: UserCohort;
  askSparky: SparkyQuery;
  /**
   * Blocks the specified user for the current user.
   * Blocking a user will hide their posts from the current user's feed.
   * Blocked users won't be able to follow, view or interact with the current user.
   */
  blockUser: UserBlock;
  /** Creates a Bookmark for the specified post and current user */
  bookmarkPost: Bookmark;
  createAudience: Audience;
  createBoardCertification: BoardCertification;
  createCertificate: Certificate;
  createCertificateForReflections: Certificate;
  createCertificateSurveyQuestion: CertificateSurveyQuestion;
  createCertificateSurveyQuestionChoice: CertificateSurveyQuestionChoice;
  createCollection: Collection;
  /** Create a new comment. Comments are owned by the currently authenticated user, the authorID field can only be set by admins */
  createComment: Comment;
  /** Creates a new comment, and kicks off a reflection analysis in the background. Also creates a linked SparkyChat to track the conversation. */
  createCommentV2: Comment;
  /** Creates a new conversation with the specified model and an optional initial message. */
  createConversation: SparkyConversation;
  /** Creates a new sparky conversation using the given comment id (and parent post0 for context. */
  createConversationFromComment: SparkyConversation;
  /**
   * Creates a new sparky conversation using the given conversation id for context.
   * The targeted conversation cannot be a reflective conversation. (ie. should be open evidence, perplexity, etc.)
   */
  createConversationFromConversation: SparkyConversation;
  /** Creates a new sparky conversation using the given post id for context. */
  createConversationFromPost: SparkyConversation;
  createConversationFromVideo: SparkyConversation;
  createCourse: Course;
  createCreditFromCompletion: EducationCredit;
  /** Creates a new EducationHistory entry for the current user */
  createEducationHistory: EducationHistory;
  /** Creates a new financial disclosure statement for the current user. If a statement already exists, and error will be returned. */
  createFinancialDisclosureStatement: FinancialDisclosureStatement;
  createImportSocialLoginURL: Scalars['String']['output'];
  createInstagramConnection?: Maybe<AccountConnection>;
  createLearningObjective: LearningObjective;
  /** Creates a new LicenseHistory entry for the current user */
  createLicenseHistory: LicenseHistory;
  /** Creates a MediaItem entry representing a file store in Cloudinary */
  createMedia: MediaItem;
  createOffice: Office;
  /** Creates a post for the current user */
  createPost: Post;
  createPostFromImportedVideo?: Maybe<Post>;
  /** Creates a PostReaction for the specified post and current user */
  createPostReaction: PostReaction;
  createPostsFromConnection?: Maybe<Scalars['String']['output']>;
  createPostsFromImportedVideos?: Maybe<Scalars['Boolean']['output']>;
  createPubmedTopicCluster?: Maybe<PubmedTopicCluster>;
  createReply: SparkyMessage;
  /** Creates a SearchConversion for a SearchResult. This is used to track when a user clicks on a search result. */
  createSearchConversion: Scalars['Boolean']['output'];
  createShortcode: Article;
  createTiktokConnection?: Maybe<AccountConnection>;
  createTopic: Topic;
  /** Creates a new user. Can be an admin or a regular user */
  createUser: User;
  /** Creates a new link for the current users bio */
  createUserLink: UserLink;
  /** Create a pending verification request for the current user. Returns an upload URL to upload the verification document to, and a VerificationRequest object in a waiting state. */
  createVerificationRequest: VerificationRequestResult;
  createVideoCompletion: EducationCredit;
  /** Send START and END events for tracking video completions to earn CE credits. */
  createVideoEvent: Scalars['Boolean']['output'];
  /** Creates a new WorkExperience entry for the current user */
  createWorkExperience: WorkExperience;
  createYoutubeConnection?: Maybe<AccountConnection>;
  deleteBoardCertification: BoardCertification;
  deleteCertificateSurveyQuestionChoice: Scalars['Boolean']['output'];
  deleteCollection: Scalars['Boolean']['output'];
  /** Delete a comment by ID. Admins can delete any comment, users can only delete their own comments */
  deleteComment: Scalars['Boolean']['output'];
  deleteCourse: Scalars['Boolean']['output'];
  /** Deletes a EducationHistory entry for the current user */
  deleteEducationHistory: EducationHistory;
  deleteFinancialDisclosureStatement: Scalars['Boolean']['output'];
  deleteInstagramConnection?: Maybe<AccountConnection>;
  /** Deletes a LicenseHistory entry for the current user */
  deleteLicenseHistory: LicenseHistory;
  deletePost: Scalars['Boolean']['output'];
  deletePubmedTopicCluster?: Maybe<PubmedTopicCluster>;
  deleteTiktokConnection?: Maybe<AccountConnection>;
  deleteTopic: Scalars['Boolean']['output'];
  /** Deletes a link for the current users bio */
  deleteUserLink: UserLink;
  deleteWaitListEntry: Scalars['Boolean']['output'];
  /** Deletes a WorkExperience entry for the current user */
  deleteWorkExperience: WorkExperience;
  deleteYoutubeConnection?: Maybe<AccountConnection>;
  flagMessageHelpful: Scalars['Boolean']['output'];
  flagMessageNotHelpful: Scalars['Boolean']['output'];
  /** Follow a single Topic */
  followTopic: Topic;
  /** Follow multiple topics */
  followTopics?: Maybe<Array<Topic>>;
  /** Follows a user */
  followUser: User;
  generateFileReplaceURL: FileUploadResponse;
  /** Generate a URL that can be used to upload a file to S3, for admins only. */
  generateFileUploadURL: FileUploadResponse;
  /** Generates a URL that can be used to upload an image to Cloudflare */
  generateImageUploadURL: ImageUploadResponse;
  /**
   * Generates a URL that can be used to upload a video to Cloudflare (https://developers.cloudflare.com/stream/uploading-videos/direct-creator-uploads#basic-upload-flow-for-small-videos)
   * Also returns a draft Video object with a status of "waiting". After the video has been uploaded and ready to stream, the status will change to "ready".
   */
  generateVideoUploadURL: VideoUploadResponse;
  joinWaitList?: Maybe<WaitlistEntry>;
  /** Creates a Like for the specified comment and current user. If the user has already liked the comment, this will return the existing like. */
  likeComment: CommentLike;
  /** Creates a Like for the specified post and current user. If the user has already liked the post, this will return the existing like. */
  likePost: Like;
  /** Returns an Auth token and the current user for the given phone verification token */
  login: LoginResponse;
  /** Return an Auth token and the current user for the given phone number and OTP */
  loginWithOTP: LoginResponse;
  /** Marks all Notifications as read, for the current user */
  markAllNotificationsAsRead: Scalars['Boolean']['output'];
  /** Marks a Notification as read, for the current user */
  markNotificationsAsRead: Scalars['Boolean']['output'];
  /**
   * Mutes the specified user for the current user.
   * Muting a user will hide their posts from the current user's feed. Muted users won't know they are muted.
   */
  muteUser: UserMute;
  /** Converts a "medical search" conversation into a reflective conversation */
  reflectOnConversation: SparkyConversation;
  refreshInstagramConnection?: Maybe<AccountConnection>;
  refreshTiktokConnection?: Maybe<AccountConnection>;
  refreshYoutubeConnection?: Maybe<AccountConnection>;
  /** Registers a device token for push notifications for the current user */
  registerNotificationToken: Scalars['Boolean']['output'];
  removeAudience: Scalars['Boolean']['output'];
  /** Removes a Bookmark for the specified post and current user */
  removeBookmark: Scalars['Boolean']['output'];
  removeOffice: Scalars['Boolean']['output'];
  removePostFromCollection: Collection;
  /** Reports a post specified by ID */
  reportPost: PostReport;
  /** Reports a user specified by ID */
  reportUser: UserReport;
  sendChatMessage: SparkyChatMessage;
  sendOTPV2?: Maybe<OtpV2Status>;
  /** Sends a phone OTP to the given phone number. Exchange the OTP for a JWT auth token */
  sendPhoneOTP: Scalars['Boolean']['output'];
  /** Creates a new user with the `User` role */
  signup?: Maybe<LoginResponse>;
  /**
   * Creates a new user with the `User` role, with a status of 'pending'.
   * Users created with this method will not be able to login until they are approved by an admin.
   */
  signupWithoutNPI?: Maybe<LoginResponse>;
  /**
   * Stats a new SparkChat referring to a specific entity.
   * If the user has already started a chat with the specific entity, the existing chat will be returned.
   */
  startChat: SparkyChat;
  submitCollectonSurvey: Scalars['Boolean']['output'];
  /** Submits a verification request for the current user. The verification document must be uploaded to the URL returned by `generateVerificationRequest` first. */
  submitVerificationRequest: VerificationRequest;
  toggleIgnoreImportedVideos?: Maybe<Scalars['Boolean']['output']>;
  unLikeComment: Scalars['Boolean']['output'];
  unLikePost: Scalars['Boolean']['output'];
  /** Unblocks the specified user for the current user. */
  unblockUser: User;
  unfollowTopic: Scalars['Boolean']['output'];
  /** Unfollows a user */
  unfollowUser: Scalars['Boolean']['output'];
  /** Unmute the specified user for the current user. */
  unmuteUser: User;
  /** Unregisters a device token for push notifications for the current user */
  unregisterNotificationToken: Scalars['Boolean']['output'];
  updateAudience: Audience;
  updateBoardCertification: BoardCertification;
  updateCertificateSurveyQuestion: CertificateSurveyQuestion;
  updateCertificateSurveyQuestionChoice: CertificateSurveyQuestionChoice;
  updateCollection: Collection;
  updateCourse: Course;
  /** Updates a EducationHistory entry for the current user */
  updateEducationHistory: EducationHistory;
  updateEducationRequirement: EducationRequirement;
  updateFileUpload: Upload;
  /** Updates an existing financial disclosure statement for the current user. */
  updateFinancialDisclosureStatement: FinancialDisclosureStatement;
  updateLearningObjective: LearningObjective;
  /** Updates a LicenseHistory entry for the current user */
  updateLicenseHistory: LicenseHistory;
  updateOffice: Office;
  updatePositionsInCollection: Collection;
  /** Updates the post for the specified id. The post must belong to the current user */
  updatePost: Post;
  /** Updates the profile for the current user */
  updateProfile: User;
  updatePubmedTopicCluster?: Maybe<PubmedTopicCluster>;
  updateTopic: Topic;
  /** Update a user profile */
  updateUser: User;
  /** Updates a link for the current users bio */
  updateUserLink: UserLink;
  updateWaitListConfig?: Maybe<WaitListConfig>;
  updateWaitListEntry?: Maybe<WaitlistEntry>;
  /** Updates a WorkExperience entry for the current user */
  updateWorkExperience: WorkExperience;
  /** Verify's the phone number and OTP match */
  verifyPhoneOTP: PhoneVerificationResponse;
  vote: Poll;
};


export type MutationAddPostToCollectionArgs = {
  collectionId: Scalars['ID']['input'];
  postId: Scalars['ID']['input'];
};


export type MutationAdminAddTaxonomyToTopicArgs = {
  taxonomyId: Scalars['ID']['input'];
  topicId: Scalars['ID']['input'];
};


export type MutationAdminAnalyzeCommentArgs = {
  body: Scalars['String']['input'];
  postId: Scalars['ID']['input'];
  previousReflection?: InputMaybe<PreviousReflectionResultInput>;
};


export type MutationAdminAnalyzeTextArgs = {
  text: Scalars['String']['input'];
};


export type MutationAdminApproveEducationCreditArgs = {
  id: Scalars['ID']['input'];
  reason: Scalars['String']['input'];
};


export type MutationAdminApproveFinancialDisclosureArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminAssignUserCohortsArgs = {
  cohortIds: Array<Scalars['ID']['input']>;
  userIds: Array<Scalars['ID']['input']>;
};


export type MutationAdminBoostTrendingPostsArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type MutationAdminBoostTrendingTopicsArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type MutationAdminBoostTrendingUsersArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type MutationAdminCreateAnatomicalModelArgs = {
  input: CreateAnatomicalModelInput;
};


export type MutationAdminCreateCertifyingBoardArgs = {
  input: CreateCertifyingBoardInput;
};


export type MutationAdminCreateConversationArgs = {
  model: ConversationModel;
  userID: Scalars['ID']['input'];
};


export type MutationAdminCreateConversationFromConversationArgs = {
  configID?: InputMaybe<Scalars['ID']['input']>;
  conversationId: Scalars['ID']['input'];
};


export type MutationAdminCreateConversationFromPostArgs = {
  configID?: InputMaybe<Scalars['ID']['input']>;
  postId: Scalars['ID']['input'];
};


export type MutationAdminCreateFinancialDisclosureRoleArgs = {
  input: CreateFinancialDisclosureRoleInput;
};


export type MutationAdminCreateInstagramConnectionArgs = {
  userID?: InputMaybe<Scalars['Int']['input']>;
  username: Scalars['String']['input'];
};


export type MutationAdminCreatePostFromImportedVideoArgs = {
  userID?: InputMaybe<Scalars['Int']['input']>;
  videoID: Scalars['String']['input'];
};


export type MutationAdminCreatePostFromUploaderArgs = {
  storageKey: Scalars['String']['input'];
};


export type MutationAdminCreatePostFromVideoArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminCreateReflectionCriteriaArgs = {
  input: CreateReflectionCriteriaInput;
};


export type MutationAdminCreateReplyArgs = {
  configID?: InputMaybe<Scalars['ID']['input']>;
  content: Scalars['String']['input'];
  conversationId: Scalars['ID']['input'];
};


export type MutationAdminCreateReportReasonArgs = {
  input: CreateReportReasonInput;
};


export type MutationAdminCreateSparkyChatConfigArgs = {
  input: CreateSparkyChatConfigInput;
};


export type MutationAdminCreateTiktokConnectionArgs = {
  userID?: InputMaybe<Scalars['Int']['input']>;
  username: Scalars['String']['input'];
};


export type MutationAdminCreateVideoFromUploaderArgs = {
  storageKey: Scalars['String']['input'];
};


export type MutationAdminCreateYoutubeConnectionArgs = {
  userID?: InputMaybe<Scalars['Int']['input']>;
  username: Scalars['String']['input'];
};


export type MutationAdminDeleteAnatomicalModelArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminDeleteBookmarkArgs = {
  postId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type MutationAdminDeleteCertifyingBoardArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminDeleteCommentArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminDeleteFinancialDisclosureRoleArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminDeleteLikeArgs = {
  postId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type MutationAdminDeleteNotificationArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminDeleteReportReasonArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminDeleteUserArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminDeleteUserCohortArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminDenyEducationCreditArgs = {
  id: Scalars['ID']['input'];
  reason: Scalars['String']['input'];
};


export type MutationAdminDisableUserArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminDownloadFinancialDisclosureStatementArgs = {
  id: Scalars['ID']['input'];
  templateID: Scalars['ID']['input'];
};


export type MutationAdminEnableUserArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminIcebreakerSandboxArgs = {
  input: SparkyIcebreakerSandboxInput;
};


export type MutationAdminImportImageFromUrlArgs = {
  url: Scalars['String']['input'];
};


export type MutationAdminLoginArgs = {
  input: AdminLoginInput;
};


export type MutationAdminRefreshInsightsArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminRemoveReflectionCriteriaArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminRemoveSparkyChatConfigArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminRemoveTaxonomyFromTopicArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminRevokeFinancialDisclosureArgs = {
  id: Scalars['ID']['input'];
};


export type MutationAdminSparkySandboxArgs = {
  input: SparkySandboxInput;
};


export type MutationAdminTestSparkyRulesArgs = {
  rules: Array<SparkyRuleInput>;
  text: Scalars['String']['input'];
};


export type MutationAdminUnAssignUserCohortsArgs = {
  cohortIds: Array<Scalars['ID']['input']>;
  userIds: Array<Scalars['ID']['input']>;
};


export type MutationAdminUnfollowUserArgs = {
  ownerId: Scalars['ID']['input'];
  userId: Scalars['ID']['input'];
};


export type MutationAdminUpdateAnatomicalModelArgs = {
  id: Scalars['ID']['input'];
  input: UpdateAnatomicalModelInput;
};


export type MutationAdminUpdateCertifyingBoardArgs = {
  id: Scalars['ID']['input'];
  input: UpdateCertifyingBoardInput;
};


export type MutationAdminUpdateFinancialDisclosurePrintTemplateArgs = {
  input: UpdateFinancialDisclosurePrintTemplateInput;
};


export type MutationAdminUpdateFinancialDisclosureRoleArgs = {
  id: Scalars['ID']['input'];
  input: UpdateFinancialDisclosureRoleInput;
};


export type MutationAdminUpdateNotificationConfigArgs = {
  input: UpdateNotificationConfigInput;
};


export type MutationAdminUpdatePostReportArgs = {
  id: Scalars['ID']['input'];
  input: UpdatePostReportInput;
};


export type MutationAdminUpdateReflectionCriteriaArgs = {
  id: Scalars['ID']['input'];
  input: UpdateReflectionCriteriaInput;
};


export type MutationAdminUpdateReflectionCriteriaGroupArgs = {
  id: Scalars['ID']['input'];
  input: UpdateReflectionCriteriaGroupInput;
};


export type MutationAdminUpdateReportReasonArgs = {
  id: Scalars['ID']['input'];
  input: UpdateReportReasonInput;
};


export type MutationAdminUpdateSparkyChatConfigArgs = {
  id: Scalars['ID']['input'];
  input: UpdateSparkyChatConfigInput;
};


export type MutationAdminUpdateSparkyChatConfigRulesArgs = {
  id: Scalars['ID']['input'];
  rules: Array<SparkyRuleInput>;
};


export type MutationAdminUpdateUserReportArgs = {
  id: Scalars['ID']['input'];
  input: UpdateUserReportInput;
};


export type MutationAdminUpdateVerificationRequestArgs = {
  id: Scalars['ID']['input'];
  input: UpdateVerificationRequestInput;
};


export type MutationAdminUpsertUserCohortArgs = {
  name: Scalars['String']['input'];
};


export type MutationAskSparkyArgs = {
  question: Scalars['String']['input'];
};


export type MutationBlockUserArgs = {
  id: Scalars['ID']['input'];
};


export type MutationBookmarkPostArgs = {
  input: BookmarkPostInput;
};


export type MutationCreateAudienceArgs = {
  input: CreateAudienceInput;
};


export type MutationCreateBoardCertificationArgs = {
  input: CreateBoardCertificationInput;
};


export type MutationCreateCertificateArgs = {
  input: CreateCertificateInput;
};


export type MutationCreateCertificateForReflectionsArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type MutationCreateCertificateSurveyQuestionArgs = {
  input: CreateCertificateSurveyQuestionInput;
};


export type MutationCreateCertificateSurveyQuestionChoiceArgs = {
  input: CreateCertificateSurveyQuestionChoiceInput;
};


export type MutationCreateCollectionArgs = {
  input: CreateCollectionInput;
};


export type MutationCreateCommentArgs = {
  input: CreateCommentInput;
};


export type MutationCreateCommentV2Args = {
  input: CreateCommentInput;
};


export type MutationCreateConversationArgs = {
  initialMessage?: InputMaybe<Scalars['String']['input']>;
  model: ConversationModel;
};


export type MutationCreateConversationFromCommentArgs = {
  commentId: Scalars['ID']['input'];
};


export type MutationCreateConversationFromConversationArgs = {
  conversationId: Scalars['ID']['input'];
};


export type MutationCreateConversationFromPostArgs = {
  postId: Scalars['ID']['input'];
};


export type MutationCreateConversationFromVideoArgs = {
  videoId: Scalars['ID']['input'];
};


export type MutationCreateCourseArgs = {
  input: CreateCourseInput;
};


export type MutationCreateCreditFromCompletionArgs = {
  postID: Scalars['ID']['input'];
  surveyAnswers: Scalars['Map']['input'];
};


export type MutationCreateEducationHistoryArgs = {
  input: CreateEducationHistoryInput;
};


export type MutationCreateFinancialDisclosureStatementArgs = {
  input: CreateFinancialDisclosureStatementInput;
};


export type MutationCreateInstagramConnectionArgs = {
  username: Scalars['String']['input'];
};


export type MutationCreateLearningObjectiveArgs = {
  input: CreateLearningObjectiveInput;
};


export type MutationCreateLicenseHistoryArgs = {
  input: CreateLicenseHistoryInput;
};


export type MutationCreateMediaArgs = {
  input: CreateMediaItemInput;
};


export type MutationCreateOfficeArgs = {
  input: CreateOfficeInput;
};


export type MutationCreatePostArgs = {
  input: CreatePostInput;
};


export type MutationCreatePostFromImportedVideoArgs = {
  body?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  videoID: Scalars['String']['input'];
};


export type MutationCreatePostReactionArgs = {
  input: PostReactionInput;
};


export type MutationCreatePostsFromConnectionArgs = {
  id: Scalars['ID']['input'];
};


export type MutationCreatePostsFromImportedVideosArgs = {
  accountConnectionID: Scalars['Int']['input'];
  videoIDs: Array<Scalars['String']['input']>;
};


export type MutationCreatePubmedTopicClusterArgs = {
  input: CreatePubmedTopicClusterInput;
};


export type MutationCreateReplyArgs = {
  content: Scalars['String']['input'];
  conversationId: Scalars['ID']['input'];
};


export type MutationCreateSearchConversionArgs = {
  input: SearchConversionInput;
};


export type MutationCreateShortcodeArgs = {
  url: Scalars['String']['input'];
};


export type MutationCreateTiktokConnectionArgs = {
  username: Scalars['String']['input'];
};


export type MutationCreateTopicArgs = {
  input: CreateTopicInput;
};


export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


export type MutationCreateUserLinkArgs = {
  input: CreateUserLinkInput;
};


export type MutationCreateVideoCompletionArgs = {
  postID: Scalars['ID']['input'];
};


export type MutationCreateVideoEventArgs = {
  type: VideoEventType;
  videoId: Scalars['ID']['input'];
};


export type MutationCreateWorkExperienceArgs = {
  input: CreateWorkExperienceInput;
};


export type MutationCreateYoutubeConnectionArgs = {
  username: Scalars['String']['input'];
};


export type MutationDeleteBoardCertificationArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteCertificateSurveyQuestionChoiceArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteCollectionArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteCommentArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteCourseArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteEducationHistoryArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteFinancialDisclosureStatementArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteInstagramConnectionArgs = {
  id: Scalars['Int']['input'];
};


export type MutationDeleteLicenseHistoryArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeletePostArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeletePubmedTopicClusterArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteTiktokConnectionArgs = {
  id: Scalars['Int']['input'];
};


export type MutationDeleteTopicArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteUserLinkArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteWaitListEntryArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteWorkExperienceArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteYoutubeConnectionArgs = {
  id: Scalars['Int']['input'];
};


export type MutationFlagMessageHelpfulArgs = {
  messageId: Scalars['ID']['input'];
};


export type MutationFlagMessageNotHelpfulArgs = {
  messageId: Scalars['ID']['input'];
};


export type MutationFollowTopicArgs = {
  id: Scalars['ID']['input'];
};


export type MutationFollowTopicsArgs = {
  ids?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type MutationFollowUserArgs = {
  id: Scalars['ID']['input'];
};


export type MutationGenerateFileReplaceUrlArgs = {
  contentType: Scalars['String']['input'];
  id: Scalars['ID']['input'];
};


export type MutationGenerateFileUploadUrlArgs = {
  contentType: Scalars['String']['input'];
  fileName: Scalars['String']['input'];
};


export type MutationJoinWaitListArgs = {
  input: JoinWaitListInput;
};


export type MutationLikeCommentArgs = {
  input: LikeCommentInput;
};


export type MutationLikePostArgs = {
  input: LikePostInput;
};


export type MutationLoginArgs = {
  phoneVerificationToken: Scalars['String']['input'];
};


export type MutationLoginWithOtpArgs = {
  otp: Scalars['String']['input'];
  phone: Scalars['String']['input'];
};


export type MutationMarkNotificationsAsReadArgs = {
  input: MarkNotificationsAsRead;
};


export type MutationMuteUserArgs = {
  id: Scalars['ID']['input'];
};


export type MutationReflectOnConversationArgs = {
  conversationId: Scalars['ID']['input'];
};


export type MutationRefreshInstagramConnectionArgs = {
  id: Scalars['Int']['input'];
};


export type MutationRefreshTiktokConnectionArgs = {
  id: Scalars['Int']['input'];
};


export type MutationRefreshYoutubeConnectionArgs = {
  id: Scalars['Int']['input'];
};


export type MutationRegisterNotificationTokenArgs = {
  platform: Scalars['String']['input'];
  token: Scalars['String']['input'];
};


export type MutationRemoveAudienceArgs = {
  id: Scalars['ID']['input'];
};


export type MutationRemoveBookmarkArgs = {
  input: BookmarkPostInput;
};


export type MutationRemoveOfficeArgs = {
  id: Scalars['ID']['input'];
};


export type MutationRemovePostFromCollectionArgs = {
  collectionId: Scalars['ID']['input'];
  postId: Scalars['ID']['input'];
};


export type MutationReportPostArgs = {
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  reasonID: Scalars['ID']['input'];
};


export type MutationReportUserArgs = {
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  reasonID: Scalars['ID']['input'];
};


export type MutationSendChatMessageArgs = {
  chatID?: InputMaybe<Scalars['ID']['input']>;
  message: Scalars['String']['input'];
};


export type MutationSendOtpv2Args = {
  phone: Scalars['String']['input'];
};


export type MutationSendPhoneOtpArgs = {
  phone: Scalars['String']['input'];
};


export type MutationSignupArgs = {
  input: SignupInput;
};


export type MutationSignupWithoutNpiArgs = {
  input: SignupWithoutNpiInput;
};


export type MutationStartChatArgs = {
  chatType?: InputMaybe<ChatType>;
  entityID: Scalars['Int']['input'];
  entityType: Scalars['String']['input'];
  message: Scalars['String']['input'];
};


export type MutationSubmitCollectonSurveyArgs = {
  collectionId: Scalars['ID']['input'];
  data: Scalars['Any']['input'];
};


export type MutationSubmitVerificationRequestArgs = {
  id: Scalars['ID']['input'];
  input: SubmitVerificationRequestInput;
};


export type MutationToggleIgnoreImportedVideosArgs = {
  accountConnectionID: Scalars['Int']['input'];
  videoIDs: Array<Scalars['String']['input']>;
};


export type MutationUnLikeCommentArgs = {
  input: LikeCommentInput;
};


export type MutationUnLikePostArgs = {
  input: LikePostInput;
};


export type MutationUnblockUserArgs = {
  id: Scalars['ID']['input'];
};


export type MutationUnfollowTopicArgs = {
  id: Scalars['ID']['input'];
};


export type MutationUnfollowUserArgs = {
  id: Scalars['ID']['input'];
};


export type MutationUnmuteUserArgs = {
  id: Scalars['ID']['input'];
};


export type MutationUnregisterNotificationTokenArgs = {
  platform: Scalars['String']['input'];
  token: Scalars['String']['input'];
};


export type MutationUpdateAudienceArgs = {
  id: Scalars['ID']['input'];
  input: UpdateAudienceInput;
};


export type MutationUpdateBoardCertificationArgs = {
  id: Scalars['ID']['input'];
  input: UpdateBoardCertificationInput;
};


export type MutationUpdateCertificateSurveyQuestionArgs = {
  id: Scalars['ID']['input'];
  input: UpdateCertificateSurveyQuestionInput;
};


export type MutationUpdateCertificateSurveyQuestionChoiceArgs = {
  id: Scalars['ID']['input'];
  input: UpdateCertificateSurveyQuestionChoiceInput;
};


export type MutationUpdateCollectionArgs = {
  id: Scalars['ID']['input'];
  input: UpdateCollectionInput;
};


export type MutationUpdateCourseArgs = {
  id: Scalars['ID']['input'];
  input: UpdateCourseInput;
};


export type MutationUpdateEducationHistoryArgs = {
  id: Scalars['ID']['input'];
  input: UpdateEducationHistoryInput;
};


export type MutationUpdateEducationRequirementArgs = {
  id: Scalars['ID']['input'];
  input: UpdateEducationRequirementInput;
};


export type MutationUpdateFileUploadArgs = {
  id: Scalars['ID']['input'];
  input: UpdateUploadInput;
};


export type MutationUpdateFinancialDisclosureStatementArgs = {
  id: Scalars['ID']['input'];
  input: UpdateFinancialDisclosureStatementInput;
};


export type MutationUpdateLearningObjectiveArgs = {
  id: Scalars['ID']['input'];
  input: UpdateLearningObjectiveInput;
};


export type MutationUpdateLicenseHistoryArgs = {
  id: Scalars['ID']['input'];
  input: UpdateLicenseHistoryInput;
};


export type MutationUpdateOfficeArgs = {
  id: Scalars['ID']['input'];
  input: UpdateOfficeInput;
};


export type MutationUpdatePositionsInCollectionArgs = {
  collectionId: Scalars['ID']['input'];
  postIds?: InputMaybe<Array<Scalars['ID']['input']>>;
};


export type MutationUpdatePostArgs = {
  id: Scalars['ID']['input'];
  input: UpdatePostInput;
};


export type MutationUpdateProfileArgs = {
  input: UpdateUserInput;
};


export type MutationUpdatePubmedTopicClusterArgs = {
  id: Scalars['ID']['input'];
  input: UpdatePubmedTopicClusterInput;
};


export type MutationUpdateTopicArgs = {
  id: Scalars['ID']['input'];
  input: UpdateTopicInput;
};


export type MutationUpdateUserArgs = {
  id: Scalars['ID']['input'];
  input: UpdateUserInput;
};


export type MutationUpdateUserLinkArgs = {
  id: Scalars['ID']['input'];
  input: UpdateUserLinkInput;
};


export type MutationUpdateWaitListConfigArgs = {
  input: UpdateWaitListConfigInput;
};


export type MutationUpdateWaitListEntryArgs = {
  id: Scalars['ID']['input'];
  input: UpdateWaitlistEntryInput;
};


export type MutationUpdateWorkExperienceArgs = {
  id: Scalars['ID']['input'];
  input: UpdateWorkExperienceInput;
};


export type MutationVerifyPhoneOtpArgs = {
  otp: Scalars['String']['input'];
  phone: Scalars['String']['input'];
};


export type MutationVoteArgs = {
  pollID: Scalars['ID']['input'];
  pollQuestionID: Scalars['ID']['input'];
};

export type NamedEntity = {
  __typename?: 'NamedEntity';
  end: Scalars['Int']['output'];
  entityGroup: Scalars['String']['output'];
  score: Scalars['Float']['output'];
  start: Scalars['Int']['output'];
  word: Scalars['String']['output'];
};

export type NamedEntityStat = {
  __typename?: 'NamedEntityStat';
  count: Scalars['Int']['output'];
  entityGroup: Scalars['String']['output'];
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

export type Notification = Node & {
  __typename?: 'Notification';
  /**
   * The body of the notification. This is the fully rendered message minus the user's name
   * ie. liked your post "Test Post"
   * or  reflected on your post "Test Post"
   */
  body: Scalars['String']['output'];
  createdAt: Scalars['Time']['output'];
  /** The user that sent the notification. */
  from?: Maybe<User>;
  id: Scalars['ID']['output'];
  /** The image associated with the notification. */
  image?: Maybe<Image>;
  imageID?: Maybe<Scalars['ID']['output']>;
  /** (DEPRECATED - Use body instead) The message of the notification. */
  message: Scalars['String']['output'];
  /** The type of notification. */
  notificationType: NotificationNotificationType;
  pushSentAt?: Maybe<Scalars['Time']['output']>;
  /** The time that the notification was read. */
  readAt?: Maybe<Scalars['Time']['output']>;
  /** The ID of the resource that the notification is for. */
  resourceID: Scalars['String']['output'];
  /** The type of resource that the notification is for. */
  resourceType: Scalars['String']['output'];
  /** The user that the notification is for. */
  user?: Maybe<User>;
};

export type NotificationConfig = Node & {
  __typename?: 'NotificationConfig';
  createdAt: Scalars['Time']['output'];
  /** The message template for follow notifications. */
  followUserMessage: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** The message template for like notifications. */
  likedPostMessage: Scalars['String']['output'];
  /** The message template for comment notifications. */
  reflectedPostMessage: Scalars['String']['output'];
  /** The message template for reflection approved notifications. */
  reflectionApproved: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type NotificationConfigConnection = {
  __typename?: 'NotificationConfigConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NotificationConfigEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type NotificationConfigEdge = {
  __typename?: 'NotificationConfigEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<NotificationConfig>;
};

/** Ordering options for NotificationConfig connections */
export type NotificationConfigOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order NotificationConfigs. */
  field: NotificationConfigOrderField;
};

/** Properties by which NotificationConfig connections can be ordered. */
export enum NotificationConfigOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * NotificationConfigWhereInput is used for filtering NotificationConfig objects.
 * Input was generated by ent.
 */
export type NotificationConfigWhereInput = {
  and?: InputMaybe<Array<NotificationConfigWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** follow_user_message field predicates */
  followUserMessage?: InputMaybe<Scalars['String']['input']>;
  followUserMessageContains?: InputMaybe<Scalars['String']['input']>;
  followUserMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  followUserMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  followUserMessageGT?: InputMaybe<Scalars['String']['input']>;
  followUserMessageGTE?: InputMaybe<Scalars['String']['input']>;
  followUserMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  followUserMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  followUserMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  followUserMessageLT?: InputMaybe<Scalars['String']['input']>;
  followUserMessageLTE?: InputMaybe<Scalars['String']['input']>;
  followUserMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  followUserMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** liked_post_message field predicates */
  likedPostMessage?: InputMaybe<Scalars['String']['input']>;
  likedPostMessageContains?: InputMaybe<Scalars['String']['input']>;
  likedPostMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  likedPostMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  likedPostMessageGT?: InputMaybe<Scalars['String']['input']>;
  likedPostMessageGTE?: InputMaybe<Scalars['String']['input']>;
  likedPostMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  likedPostMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  likedPostMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  likedPostMessageLT?: InputMaybe<Scalars['String']['input']>;
  likedPostMessageLTE?: InputMaybe<Scalars['String']['input']>;
  likedPostMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  likedPostMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<NotificationConfigWhereInput>;
  or?: InputMaybe<Array<NotificationConfigWhereInput>>;
  /** reflected_post_message field predicates */
  reflectedPostMessage?: InputMaybe<Scalars['String']['input']>;
  reflectedPostMessageContains?: InputMaybe<Scalars['String']['input']>;
  reflectedPostMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  reflectedPostMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  reflectedPostMessageGT?: InputMaybe<Scalars['String']['input']>;
  reflectedPostMessageGTE?: InputMaybe<Scalars['String']['input']>;
  reflectedPostMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  reflectedPostMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  reflectedPostMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  reflectedPostMessageLT?: InputMaybe<Scalars['String']['input']>;
  reflectedPostMessageLTE?: InputMaybe<Scalars['String']['input']>;
  reflectedPostMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  reflectedPostMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** reflection_approved field predicates */
  reflectionApproved?: InputMaybe<Scalars['String']['input']>;
  reflectionApprovedContains?: InputMaybe<Scalars['String']['input']>;
  reflectionApprovedContainsFold?: InputMaybe<Scalars['String']['input']>;
  reflectionApprovedEqualFold?: InputMaybe<Scalars['String']['input']>;
  reflectionApprovedGT?: InputMaybe<Scalars['String']['input']>;
  reflectionApprovedGTE?: InputMaybe<Scalars['String']['input']>;
  reflectionApprovedHasPrefix?: InputMaybe<Scalars['String']['input']>;
  reflectionApprovedHasSuffix?: InputMaybe<Scalars['String']['input']>;
  reflectionApprovedIn?: InputMaybe<Array<Scalars['String']['input']>>;
  reflectionApprovedLT?: InputMaybe<Scalars['String']['input']>;
  reflectionApprovedLTE?: InputMaybe<Scalars['String']['input']>;
  reflectionApprovedNEQ?: InputMaybe<Scalars['String']['input']>;
  reflectionApprovedNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/** A connection to a list of items. */
export type NotificationConnection = {
  __typename?: 'NotificationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NotificationEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type NotificationEdge = {
  __typename?: 'NotificationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Notification>;
};

/** NotificationNotificationType is enum for the field notification_type */
export enum NotificationNotificationType {
  Comment = 'comment',
  Follow = 'follow',
  Like = 'like',
  Other = 'other',
  ReflectionApproved = 'reflection_approved'
}

/** Ordering options for Notification connections */
export type NotificationOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Notifications. */
  field: NotificationOrderField;
};

/** Properties by which Notification connections can be ordered. */
export enum NotificationOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * NotificationWhereInput is used for filtering Notification objects.
 * Input was generated by ent.
 */
export type NotificationWhereInput = {
  and?: InputMaybe<Array<NotificationWhereInput>>;
  /** body field predicates */
  body?: InputMaybe<Scalars['String']['input']>;
  bodyContains?: InputMaybe<Scalars['String']['input']>;
  bodyContainsFold?: InputMaybe<Scalars['String']['input']>;
  bodyEqualFold?: InputMaybe<Scalars['String']['input']>;
  bodyGT?: InputMaybe<Scalars['String']['input']>;
  bodyGTE?: InputMaybe<Scalars['String']['input']>;
  bodyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bodyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bodyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bodyLT?: InputMaybe<Scalars['String']['input']>;
  bodyLTE?: InputMaybe<Scalars['String']['input']>;
  bodyNEQ?: InputMaybe<Scalars['String']['input']>;
  bodyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** from edge predicates */
  hasFrom?: InputMaybe<Scalars['Boolean']['input']>;
  hasFromWith?: InputMaybe<Array<UserWhereInput>>;
  /** image edge predicates */
  hasImage?: InputMaybe<Scalars['Boolean']['input']>;
  hasImageWith?: InputMaybe<Array<ImageWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** image_id field predicates */
  imageID?: InputMaybe<Scalars['ID']['input']>;
  imageIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  imageIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  imageIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  imageIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  imageIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** message field predicates */
  message?: InputMaybe<Scalars['String']['input']>;
  messageContains?: InputMaybe<Scalars['String']['input']>;
  messageContainsFold?: InputMaybe<Scalars['String']['input']>;
  messageEqualFold?: InputMaybe<Scalars['String']['input']>;
  messageGT?: InputMaybe<Scalars['String']['input']>;
  messageGTE?: InputMaybe<Scalars['String']['input']>;
  messageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  messageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  messageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  messageLT?: InputMaybe<Scalars['String']['input']>;
  messageLTE?: InputMaybe<Scalars['String']['input']>;
  messageNEQ?: InputMaybe<Scalars['String']['input']>;
  messageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<NotificationWhereInput>;
  /** notification_type field predicates */
  notificationType?: InputMaybe<NotificationNotificationType>;
  notificationTypeIn?: InputMaybe<Array<NotificationNotificationType>>;
  notificationTypeNEQ?: InputMaybe<NotificationNotificationType>;
  notificationTypeNotIn?: InputMaybe<Array<NotificationNotificationType>>;
  or?: InputMaybe<Array<NotificationWhereInput>>;
  /** push_sent_at field predicates */
  pushSentAt?: InputMaybe<Scalars['Time']['input']>;
  pushSentAtGT?: InputMaybe<Scalars['Time']['input']>;
  pushSentAtGTE?: InputMaybe<Scalars['Time']['input']>;
  pushSentAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  pushSentAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  pushSentAtLT?: InputMaybe<Scalars['Time']['input']>;
  pushSentAtLTE?: InputMaybe<Scalars['Time']['input']>;
  pushSentAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  pushSentAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  pushSentAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** read_at field predicates */
  readAt?: InputMaybe<Scalars['Time']['input']>;
  readAtGT?: InputMaybe<Scalars['Time']['input']>;
  readAtGTE?: InputMaybe<Scalars['Time']['input']>;
  readAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  readAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  readAtLT?: InputMaybe<Scalars['Time']['input']>;
  readAtLTE?: InputMaybe<Scalars['Time']['input']>;
  readAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  readAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  readAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** resource_id field predicates */
  resourceID?: InputMaybe<Scalars['String']['input']>;
  resourceIDContains?: InputMaybe<Scalars['String']['input']>;
  resourceIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  resourceIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  resourceIDGT?: InputMaybe<Scalars['String']['input']>;
  resourceIDGTE?: InputMaybe<Scalars['String']['input']>;
  resourceIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  resourceIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  resourceIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  resourceIDLT?: InputMaybe<Scalars['String']['input']>;
  resourceIDLTE?: InputMaybe<Scalars['String']['input']>;
  resourceIDNEQ?: InputMaybe<Scalars['String']['input']>;
  resourceIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** resource_type field predicates */
  resourceType?: InputMaybe<Scalars['String']['input']>;
  resourceTypeContains?: InputMaybe<Scalars['String']['input']>;
  resourceTypeContainsFold?: InputMaybe<Scalars['String']['input']>;
  resourceTypeEqualFold?: InputMaybe<Scalars['String']['input']>;
  resourceTypeGT?: InputMaybe<Scalars['String']['input']>;
  resourceTypeGTE?: InputMaybe<Scalars['String']['input']>;
  resourceTypeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  resourceTypeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  resourceTypeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  resourceTypeLT?: InputMaybe<Scalars['String']['input']>;
  resourceTypeLTE?: InputMaybe<Scalars['String']['input']>;
  resourceTypeNEQ?: InputMaybe<Scalars['String']['input']>;
  resourceTypeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type NpiTaxonomy = Node & {
  __typename?: 'NpiTaxonomy';
  audiences?: Maybe<Array<Audience>>;
  classification: Scalars['String']['output'];
  code: Scalars['String']['output'];
  createdAt: Scalars['Time']['output'];
  displayName: Scalars['String']['output'];
  grouping: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  specialization?: Maybe<Scalars['String']['output']>;
  topicNpiTaxonomy?: Maybe<Array<TopicNpiTaxonomy>>;
  /** The topics that are tagged with the NPI taxonomy. */
  topics?: Maybe<Array<Topic>>;
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type NpiTaxonomyConnection = {
  __typename?: 'NpiTaxonomyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NpiTaxonomyEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type NpiTaxonomyEdge = {
  __typename?: 'NpiTaxonomyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<NpiTaxonomy>;
};

/** Ordering options for NpiTaxonomy connections */
export type NpiTaxonomyOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order NpiTaxonomies. */
  field: NpiTaxonomyOrderField;
};

/** Properties by which NpiTaxonomy connections can be ordered. */
export enum NpiTaxonomyOrderField {
  Classification = 'CLASSIFICATION',
  Code = 'CODE',
  DisplayName = 'DISPLAY_NAME',
  Specialization = 'SPECIALIZATION'
}

/**
 * NpiTaxonomyWhereInput is used for filtering NpiTaxonomy objects.
 * Input was generated by ent.
 */
export type NpiTaxonomyWhereInput = {
  and?: InputMaybe<Array<NpiTaxonomyWhereInput>>;
  /** classification field predicates */
  classification?: InputMaybe<Scalars['String']['input']>;
  classificationContains?: InputMaybe<Scalars['String']['input']>;
  classificationContainsFold?: InputMaybe<Scalars['String']['input']>;
  classificationEqualFold?: InputMaybe<Scalars['String']['input']>;
  classificationGT?: InputMaybe<Scalars['String']['input']>;
  classificationGTE?: InputMaybe<Scalars['String']['input']>;
  classificationHasPrefix?: InputMaybe<Scalars['String']['input']>;
  classificationHasSuffix?: InputMaybe<Scalars['String']['input']>;
  classificationIn?: InputMaybe<Array<Scalars['String']['input']>>;
  classificationLT?: InputMaybe<Scalars['String']['input']>;
  classificationLTE?: InputMaybe<Scalars['String']['input']>;
  classificationNEQ?: InputMaybe<Scalars['String']['input']>;
  classificationNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** code field predicates */
  code?: InputMaybe<Scalars['String']['input']>;
  codeContains?: InputMaybe<Scalars['String']['input']>;
  codeContainsFold?: InputMaybe<Scalars['String']['input']>;
  codeEqualFold?: InputMaybe<Scalars['String']['input']>;
  codeGT?: InputMaybe<Scalars['String']['input']>;
  codeGTE?: InputMaybe<Scalars['String']['input']>;
  codeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  codeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  codeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  codeLT?: InputMaybe<Scalars['String']['input']>;
  codeLTE?: InputMaybe<Scalars['String']['input']>;
  codeNEQ?: InputMaybe<Scalars['String']['input']>;
  codeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** display_name field predicates */
  displayName?: InputMaybe<Scalars['String']['input']>;
  displayNameContains?: InputMaybe<Scalars['String']['input']>;
  displayNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  displayNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  displayNameGT?: InputMaybe<Scalars['String']['input']>;
  displayNameGTE?: InputMaybe<Scalars['String']['input']>;
  displayNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  displayNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  displayNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  displayNameLT?: InputMaybe<Scalars['String']['input']>;
  displayNameLTE?: InputMaybe<Scalars['String']['input']>;
  displayNameNEQ?: InputMaybe<Scalars['String']['input']>;
  displayNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** grouping field predicates */
  grouping?: InputMaybe<Scalars['String']['input']>;
  groupingContains?: InputMaybe<Scalars['String']['input']>;
  groupingContainsFold?: InputMaybe<Scalars['String']['input']>;
  groupingEqualFold?: InputMaybe<Scalars['String']['input']>;
  groupingGT?: InputMaybe<Scalars['String']['input']>;
  groupingGTE?: InputMaybe<Scalars['String']['input']>;
  groupingHasPrefix?: InputMaybe<Scalars['String']['input']>;
  groupingHasSuffix?: InputMaybe<Scalars['String']['input']>;
  groupingIn?: InputMaybe<Array<Scalars['String']['input']>>;
  groupingLT?: InputMaybe<Scalars['String']['input']>;
  groupingLTE?: InputMaybe<Scalars['String']['input']>;
  groupingNEQ?: InputMaybe<Scalars['String']['input']>;
  groupingNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** audiences edge predicates */
  hasAudiences?: InputMaybe<Scalars['Boolean']['input']>;
  hasAudiencesWith?: InputMaybe<Array<AudienceWhereInput>>;
  /** topic_npi_taxonomy edge predicates */
  hasTopicNpiTaxonomy?: InputMaybe<Scalars['Boolean']['input']>;
  hasTopicNpiTaxonomyWith?: InputMaybe<Array<TopicNpiTaxonomyWhereInput>>;
  /** topics edge predicates */
  hasTopics?: InputMaybe<Scalars['Boolean']['input']>;
  hasTopicsWith?: InputMaybe<Array<TopicWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<NpiTaxonomyWhereInput>;
  or?: InputMaybe<Array<NpiTaxonomyWhereInput>>;
  /** specialization field predicates */
  specialization?: InputMaybe<Scalars['String']['input']>;
  specializationContains?: InputMaybe<Scalars['String']['input']>;
  specializationContainsFold?: InputMaybe<Scalars['String']['input']>;
  specializationEqualFold?: InputMaybe<Scalars['String']['input']>;
  specializationGT?: InputMaybe<Scalars['String']['input']>;
  specializationGTE?: InputMaybe<Scalars['String']['input']>;
  specializationHasPrefix?: InputMaybe<Scalars['String']['input']>;
  specializationHasSuffix?: InputMaybe<Scalars['String']['input']>;
  specializationIn?: InputMaybe<Array<Scalars['String']['input']>>;
  specializationIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  specializationLT?: InputMaybe<Scalars['String']['input']>;
  specializationLTE?: InputMaybe<Scalars['String']['input']>;
  specializationNEQ?: InputMaybe<Scalars['String']['input']>;
  specializationNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  specializationNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type Office = Node & {
  __typename?: 'Office';
  /** The first line of the address. Typically the street address or PO Box number. */
  address1: Scalars['String']['output'];
  /** The second line of the address. Typically the number of the apartment, suite, or unit. */
  address2?: Maybe<Scalars['String']['output']>;
  /** The city of the office */
  city: Scalars['String']['output'];
  /** The two-letter code for the country of the address. For example US for United States. */
  countryCode?: Maybe<Scalars['String']['output']>;
  /** The email address for the office */
  email?: Maybe<Scalars['String']['output']>;
  /** The fax number of the office. Formatted using E.164 standard. */
  fax?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The phone number of the office, Formatted using E.164 standard. */
  phone?: Maybe<Scalars['String']['output']>;
  /** Whether the office is the primary office location. */
  primary: Scalars['Boolean']['output'];
  /** The two-letter code for the region. For example CA for California. */
  stateCode: Scalars['String']['output'];
  user?: Maybe<User>;
  /** The zip or postal code of the address. */
  zip: Scalars['String']['output'];
};

/** A connection to a list of items. */
export type OfficeConnection = {
  __typename?: 'OfficeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OfficeEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type OfficeEdge = {
  __typename?: 'OfficeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Office>;
};

/**
 * OfficeWhereInput is used for filtering Office objects.
 * Input was generated by ent.
 */
export type OfficeWhereInput = {
  /** address1 field predicates */
  address1?: InputMaybe<Scalars['String']['input']>;
  address1Contains?: InputMaybe<Scalars['String']['input']>;
  address1ContainsFold?: InputMaybe<Scalars['String']['input']>;
  address1EqualFold?: InputMaybe<Scalars['String']['input']>;
  address1GT?: InputMaybe<Scalars['String']['input']>;
  address1GTE?: InputMaybe<Scalars['String']['input']>;
  address1HasPrefix?: InputMaybe<Scalars['String']['input']>;
  address1HasSuffix?: InputMaybe<Scalars['String']['input']>;
  address1In?: InputMaybe<Array<Scalars['String']['input']>>;
  address1LT?: InputMaybe<Scalars['String']['input']>;
  address1LTE?: InputMaybe<Scalars['String']['input']>;
  address1NEQ?: InputMaybe<Scalars['String']['input']>;
  address1NotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** address2 field predicates */
  address2?: InputMaybe<Scalars['String']['input']>;
  address2Contains?: InputMaybe<Scalars['String']['input']>;
  address2ContainsFold?: InputMaybe<Scalars['String']['input']>;
  address2EqualFold?: InputMaybe<Scalars['String']['input']>;
  address2GT?: InputMaybe<Scalars['String']['input']>;
  address2GTE?: InputMaybe<Scalars['String']['input']>;
  address2HasPrefix?: InputMaybe<Scalars['String']['input']>;
  address2HasSuffix?: InputMaybe<Scalars['String']['input']>;
  address2In?: InputMaybe<Array<Scalars['String']['input']>>;
  address2IsNil?: InputMaybe<Scalars['Boolean']['input']>;
  address2LT?: InputMaybe<Scalars['String']['input']>;
  address2LTE?: InputMaybe<Scalars['String']['input']>;
  address2NEQ?: InputMaybe<Scalars['String']['input']>;
  address2NotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  address2NotNil?: InputMaybe<Scalars['Boolean']['input']>;
  and?: InputMaybe<Array<OfficeWhereInput>>;
  /** city field predicates */
  city?: InputMaybe<Scalars['String']['input']>;
  cityContains?: InputMaybe<Scalars['String']['input']>;
  cityContainsFold?: InputMaybe<Scalars['String']['input']>;
  cityEqualFold?: InputMaybe<Scalars['String']['input']>;
  cityGT?: InputMaybe<Scalars['String']['input']>;
  cityGTE?: InputMaybe<Scalars['String']['input']>;
  cityHasPrefix?: InputMaybe<Scalars['String']['input']>;
  cityHasSuffix?: InputMaybe<Scalars['String']['input']>;
  cityIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cityLT?: InputMaybe<Scalars['String']['input']>;
  cityLTE?: InputMaybe<Scalars['String']['input']>;
  cityNEQ?: InputMaybe<Scalars['String']['input']>;
  cityNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** country_code field predicates */
  countryCode?: InputMaybe<Scalars['String']['input']>;
  countryCodeContains?: InputMaybe<Scalars['String']['input']>;
  countryCodeContainsFold?: InputMaybe<Scalars['String']['input']>;
  countryCodeEqualFold?: InputMaybe<Scalars['String']['input']>;
  countryCodeGT?: InputMaybe<Scalars['String']['input']>;
  countryCodeGTE?: InputMaybe<Scalars['String']['input']>;
  countryCodeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  countryCodeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  countryCodeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  countryCodeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  countryCodeLT?: InputMaybe<Scalars['String']['input']>;
  countryCodeLTE?: InputMaybe<Scalars['String']['input']>;
  countryCodeNEQ?: InputMaybe<Scalars['String']['input']>;
  countryCodeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  countryCodeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']['input']>;
  emailContains?: InputMaybe<Scalars['String']['input']>;
  emailContainsFold?: InputMaybe<Scalars['String']['input']>;
  emailEqualFold?: InputMaybe<Scalars['String']['input']>;
  emailGT?: InputMaybe<Scalars['String']['input']>;
  emailGTE?: InputMaybe<Scalars['String']['input']>;
  emailHasPrefix?: InputMaybe<Scalars['String']['input']>;
  emailHasSuffix?: InputMaybe<Scalars['String']['input']>;
  emailIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  emailLT?: InputMaybe<Scalars['String']['input']>;
  emailLTE?: InputMaybe<Scalars['String']['input']>;
  emailNEQ?: InputMaybe<Scalars['String']['input']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** fax field predicates */
  fax?: InputMaybe<Scalars['String']['input']>;
  faxContains?: InputMaybe<Scalars['String']['input']>;
  faxContainsFold?: InputMaybe<Scalars['String']['input']>;
  faxEqualFold?: InputMaybe<Scalars['String']['input']>;
  faxGT?: InputMaybe<Scalars['String']['input']>;
  faxGTE?: InputMaybe<Scalars['String']['input']>;
  faxHasPrefix?: InputMaybe<Scalars['String']['input']>;
  faxHasSuffix?: InputMaybe<Scalars['String']['input']>;
  faxIn?: InputMaybe<Array<Scalars['String']['input']>>;
  faxIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  faxLT?: InputMaybe<Scalars['String']['input']>;
  faxLTE?: InputMaybe<Scalars['String']['input']>;
  faxNEQ?: InputMaybe<Scalars['String']['input']>;
  faxNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  faxNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<OfficeWhereInput>;
  or?: InputMaybe<Array<OfficeWhereInput>>;
  /** phone field predicates */
  phone?: InputMaybe<Scalars['String']['input']>;
  phoneContains?: InputMaybe<Scalars['String']['input']>;
  phoneContainsFold?: InputMaybe<Scalars['String']['input']>;
  phoneEqualFold?: InputMaybe<Scalars['String']['input']>;
  phoneGT?: InputMaybe<Scalars['String']['input']>;
  phoneGTE?: InputMaybe<Scalars['String']['input']>;
  phoneHasPrefix?: InputMaybe<Scalars['String']['input']>;
  phoneHasSuffix?: InputMaybe<Scalars['String']['input']>;
  phoneIn?: InputMaybe<Array<Scalars['String']['input']>>;
  phoneIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  phoneLT?: InputMaybe<Scalars['String']['input']>;
  phoneLTE?: InputMaybe<Scalars['String']['input']>;
  phoneNEQ?: InputMaybe<Scalars['String']['input']>;
  phoneNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  phoneNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** primary field predicates */
  primary?: InputMaybe<Scalars['Boolean']['input']>;
  primaryNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** state_code field predicates */
  stateCode?: InputMaybe<Scalars['String']['input']>;
  stateCodeContains?: InputMaybe<Scalars['String']['input']>;
  stateCodeContainsFold?: InputMaybe<Scalars['String']['input']>;
  stateCodeEqualFold?: InputMaybe<Scalars['String']['input']>;
  stateCodeGT?: InputMaybe<Scalars['String']['input']>;
  stateCodeGTE?: InputMaybe<Scalars['String']['input']>;
  stateCodeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  stateCodeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  stateCodeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  stateCodeLT?: InputMaybe<Scalars['String']['input']>;
  stateCodeLTE?: InputMaybe<Scalars['String']['input']>;
  stateCodeNEQ?: InputMaybe<Scalars['String']['input']>;
  stateCodeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** zip field predicates */
  zip?: InputMaybe<Scalars['String']['input']>;
  zipContains?: InputMaybe<Scalars['String']['input']>;
  zipContainsFold?: InputMaybe<Scalars['String']['input']>;
  zipEqualFold?: InputMaybe<Scalars['String']['input']>;
  zipGT?: InputMaybe<Scalars['String']['input']>;
  zipGTE?: InputMaybe<Scalars['String']['input']>;
  zipHasPrefix?: InputMaybe<Scalars['String']['input']>;
  zipHasSuffix?: InputMaybe<Scalars['String']['input']>;
  zipIn?: InputMaybe<Array<Scalars['String']['input']>>;
  zipLT?: InputMaybe<Scalars['String']['input']>;
  zipLTE?: InputMaybe<Scalars['String']['input']>;
  zipNEQ?: InputMaybe<Scalars['String']['input']>;
  zipNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type OpenEvidenceReference = {
  __typename?: 'OpenEvidenceReference';
  citationKey: Scalars['Int']['output'];
  referenceDetail: OpenEvidenceReferenceDetail;
  referenceText: Scalars['String']['output'];
  sourceTexts: Array<Scalars['String']['output']>;
};

export type OpenEvidenceReferenceDetail = {
  __typename?: 'OpenEvidenceReferenceDetail';
  authorsString: Scalars['String']['output'];
  doi: Scalars['String']['output'];
  journalName: Scalars['String']['output'];
  journalShortName: Scalars['String']['output'];
  publicationDate: Scalars['String']['output'];
  publicationInfoString: Scalars['String']['output'];
  title: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

export type OpenGraphReference = {
  __typename?: 'OpenGraphReference';
  description: Scalars['String']['output'];
  image: Scalars['String']['output'];
  title: Scalars['String']['output'];
  url: Scalars['String']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

export type OtpV2Status = {
  __typename?: 'OtpV2Status';
  phoneStatus?: Maybe<PhoneStatus>;
};

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type PartOfSpeechTag = {
  __typename?: 'PartOfSpeechTag';
  dep?: Maybe<Scalars['String']['output']>;
  isAlpha?: Maybe<Scalars['Boolean']['output']>;
  isStop?: Maybe<Scalars['Boolean']['output']>;
  lemma?: Maybe<Scalars['String']['output']>;
  pos?: Maybe<Scalars['String']['output']>;
  shape?: Maybe<Scalars['String']['output']>;
  tag?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

export enum PhoneStatus {
  InUse = 'InUse',
  NotFound = 'NotFound',
  WaitListed = 'WaitListed'
}

export type PhoneVerificationResponse = {
  __typename?: 'PhoneVerificationResponse';
  token: Scalars['String']['output'];
};

export type PhoneVerificationToken = Node & {
  __typename?: 'PhoneVerificationToken';
  createdAt: Scalars['Time']['output'];
  expiresAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  message?: Maybe<Scalars['String']['output']>;
  phone: Scalars['String']['output'];
  token: Scalars['String']['output'];
  /** The user who consumed this token */
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type PhoneVerificationTokenConnection = {
  __typename?: 'PhoneVerificationTokenConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PhoneVerificationTokenEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PhoneVerificationTokenEdge = {
  __typename?: 'PhoneVerificationTokenEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PhoneVerificationToken>;
};

/** Ordering options for PhoneVerificationToken connections */
export type PhoneVerificationTokenOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order PhoneVerificationTokens. */
  field: PhoneVerificationTokenOrderField;
};

/** Properties by which PhoneVerificationToken connections can be ordered. */
export enum PhoneVerificationTokenOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * PhoneVerificationTokenWhereInput is used for filtering PhoneVerificationToken objects.
 * Input was generated by ent.
 */
export type PhoneVerificationTokenWhereInput = {
  and?: InputMaybe<Array<PhoneVerificationTokenWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** expires_at field predicates */
  expiresAt?: InputMaybe<Scalars['Time']['input']>;
  expiresAtGT?: InputMaybe<Scalars['Time']['input']>;
  expiresAtGTE?: InputMaybe<Scalars['Time']['input']>;
  expiresAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  expiresAtLT?: InputMaybe<Scalars['Time']['input']>;
  expiresAtLTE?: InputMaybe<Scalars['Time']['input']>;
  expiresAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  expiresAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** message field predicates */
  message?: InputMaybe<Scalars['String']['input']>;
  messageContains?: InputMaybe<Scalars['String']['input']>;
  messageContainsFold?: InputMaybe<Scalars['String']['input']>;
  messageEqualFold?: InputMaybe<Scalars['String']['input']>;
  messageGT?: InputMaybe<Scalars['String']['input']>;
  messageGTE?: InputMaybe<Scalars['String']['input']>;
  messageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  messageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  messageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  messageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  messageLT?: InputMaybe<Scalars['String']['input']>;
  messageLTE?: InputMaybe<Scalars['String']['input']>;
  messageNEQ?: InputMaybe<Scalars['String']['input']>;
  messageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  messageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<PhoneVerificationTokenWhereInput>;
  or?: InputMaybe<Array<PhoneVerificationTokenWhereInput>>;
  /** phone field predicates */
  phone?: InputMaybe<Scalars['String']['input']>;
  phoneContains?: InputMaybe<Scalars['String']['input']>;
  phoneContainsFold?: InputMaybe<Scalars['String']['input']>;
  phoneEqualFold?: InputMaybe<Scalars['String']['input']>;
  phoneGT?: InputMaybe<Scalars['String']['input']>;
  phoneGTE?: InputMaybe<Scalars['String']['input']>;
  phoneHasPrefix?: InputMaybe<Scalars['String']['input']>;
  phoneHasSuffix?: InputMaybe<Scalars['String']['input']>;
  phoneIn?: InputMaybe<Array<Scalars['String']['input']>>;
  phoneLT?: InputMaybe<Scalars['String']['input']>;
  phoneLTE?: InputMaybe<Scalars['String']['input']>;
  phoneNEQ?: InputMaybe<Scalars['String']['input']>;
  phoneNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** token field predicates */
  token?: InputMaybe<Scalars['String']['input']>;
  tokenContains?: InputMaybe<Scalars['String']['input']>;
  tokenContainsFold?: InputMaybe<Scalars['String']['input']>;
  tokenEqualFold?: InputMaybe<Scalars['String']['input']>;
  tokenGT?: InputMaybe<Scalars['String']['input']>;
  tokenGTE?: InputMaybe<Scalars['String']['input']>;
  tokenHasPrefix?: InputMaybe<Scalars['String']['input']>;
  tokenHasSuffix?: InputMaybe<Scalars['String']['input']>;
  tokenIn?: InputMaybe<Array<Scalars['String']['input']>>;
  tokenLT?: InputMaybe<Scalars['String']['input']>;
  tokenLTE?: InputMaybe<Scalars['String']['input']>;
  tokenNEQ?: InputMaybe<Scalars['String']['input']>;
  tokenNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type Poll = Node & {
  __typename?: 'Poll';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  post?: Maybe<Post>;
  questions?: Maybe<Array<PollQuestion>>;
  totalVotes: Scalars['Int']['output'];
};

export type PollAnswer = Node & {
  __typename?: 'PollAnswer';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  poll: Poll;
  pollID: Scalars['ID']['output'];
  question: PollQuestion;
  user: User;
  userID: Scalars['ID']['output'];
};

/**
 * PollAnswerWhereInput is used for filtering PollAnswer objects.
 * Input was generated by ent.
 */
export type PollAnswerWhereInput = {
  and?: InputMaybe<Array<PollAnswerWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** poll edge predicates */
  hasPoll?: InputMaybe<Scalars['Boolean']['input']>;
  hasPollWith?: InputMaybe<Array<PollWhereInput>>;
  /** question edge predicates */
  hasQuestion?: InputMaybe<Scalars['Boolean']['input']>;
  hasQuestionWith?: InputMaybe<Array<PollQuestionWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PollAnswerWhereInput>;
  or?: InputMaybe<Array<PollAnswerWhereInput>>;
  /** poll_id field predicates */
  pollID?: InputMaybe<Scalars['ID']['input']>;
  pollIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  pollIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  pollIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type PollQuestion = Node & {
  __typename?: 'PollQuestion';
  id: Scalars['ID']['output'];
  poll?: Maybe<Poll>;
  /** The question to ask the user. */
  question: Scalars['String']['output'];
  totalVotes: Scalars['Int']['output'];
};

/**
 * PollQuestionWhereInput is used for filtering PollQuestion objects.
 * Input was generated by ent.
 */
export type PollQuestionWhereInput = {
  and?: InputMaybe<Array<PollQuestionWhereInput>>;
  /** poll edge predicates */
  hasPoll?: InputMaybe<Scalars['Boolean']['input']>;
  hasPollWith?: InputMaybe<Array<PollWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PollQuestionWhereInput>;
  or?: InputMaybe<Array<PollQuestionWhereInput>>;
  /** question field predicates */
  question?: InputMaybe<Scalars['String']['input']>;
  questionContains?: InputMaybe<Scalars['String']['input']>;
  questionContainsFold?: InputMaybe<Scalars['String']['input']>;
  questionEqualFold?: InputMaybe<Scalars['String']['input']>;
  questionGT?: InputMaybe<Scalars['String']['input']>;
  questionGTE?: InputMaybe<Scalars['String']['input']>;
  questionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  questionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  questionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  questionLT?: InputMaybe<Scalars['String']['input']>;
  questionLTE?: InputMaybe<Scalars['String']['input']>;
  questionNEQ?: InputMaybe<Scalars['String']['input']>;
  questionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** total_votes field predicates */
  totalVotes?: InputMaybe<Scalars['Int']['input']>;
  totalVotesGT?: InputMaybe<Scalars['Int']['input']>;
  totalVotesGTE?: InputMaybe<Scalars['Int']['input']>;
  totalVotesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalVotesLT?: InputMaybe<Scalars['Int']['input']>;
  totalVotesLTE?: InputMaybe<Scalars['Int']['input']>;
  totalVotesNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalVotesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/**
 * PollWhereInput is used for filtering Poll objects.
 * Input was generated by ent.
 */
export type PollWhereInput = {
  and?: InputMaybe<Array<PollWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** questions edge predicates */
  hasQuestions?: InputMaybe<Scalars['Boolean']['input']>;
  hasQuestionsWith?: InputMaybe<Array<PollQuestionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PollWhereInput>;
  or?: InputMaybe<Array<PollWhereInput>>;
  /** total_votes field predicates */
  totalVotes?: InputMaybe<Scalars['Int']['input']>;
  totalVotesGT?: InputMaybe<Scalars['Int']['input']>;
  totalVotesGTE?: InputMaybe<Scalars['Int']['input']>;
  totalVotesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalVotesLT?: InputMaybe<Scalars['Int']['input']>;
  totalVotesLTE?: InputMaybe<Scalars['Int']['input']>;
  totalVotesNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalVotesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type Post = Node & {
  __typename?: 'Post';
  /** The accredited learning objective for this post */
  accreditedLearningObjective?: Maybe<LearningObjective>;
  /** The audiences for this post */
  audiences?: Maybe<Array<Audience>>;
  /** The author of this post */
  author?: Maybe<User>;
  /** Body of the post. Tags (starting with a #) and Mentions (starting with an @) are allowed */
  body: Scalars['String']['output'];
  bookmarkedAt?: Maybe<Scalars['Time']['output']>;
  /** The users who bookmarked this post */
  bookmarkedUsers?: Maybe<Array<User>>;
  bookmarks?: Maybe<Array<Bookmark>>;
  /** Whether this post is accredited for CE credits */
  ce: Scalars['Boolean']['output'];
  /** The disclosure statements for this post */
  ceDisclosureStatements?: Maybe<Scalars['String']['output']>;
  /** The citations this post is associated with */
  citations?: Maybe<Array<PostCitation>>;
  /** The comments on this post */
  comments?: Maybe<Array<Comment>>;
  /** Deprecated: Use commentsEnabled or reflectionsEnabled instead */
  commentsDisabled?: Maybe<Scalars['Boolean']['output']>;
  /** Whether comments are enabled for this post */
  commentsEnabled?: Maybe<Scalars['Boolean']['output']>;
  /** The cover image for this post. Images are hosted using Cloudflare images. Please see https://developers.cloudflare.com/images/cloudflare-images/serve-images/ for details on how to serve images. */
  coverImage?: Maybe<Image>;
  createdAt: Scalars['Time']['output'];
  /** The number of CE credits this post is accredited for */
  creditHours: Scalars['Float']['output'];
  /** The main discussion points for this post. If the post has an attached sourceArticle, the discussionPoints have been copied from there and are identical.  */
  discussionPoints?: Maybe<Array<Scalars['String']['output']>>;
  earnedAccreditedCeAt?: Maybe<Scalars['Time']['output']>;
  /** All credits earned from this post, across all the user. */
  educationCredits?: Maybe<Array<EducationCredit>>;
  embeddings?: Maybe<Array<PostEmbedding>>;
  /** Whether this post should be excluded from the feed */
  excludeFromFeed: Scalars['Boolean']['output'];
  /** The external URL for this post. This is used for articles and other external content */
  externalURL?: Maybe<Scalars['String']['output']>;
  /** Whether this post is featured */
  featured: Scalars['Boolean']['output'];
  feedHistories?: Maybe<Array<UserFeedHistory>>;
  id: Scalars['ID']['output'];
  /** The images for this post. */
  images?: Maybe<Array<Image>>;
  /** The time when the insights were last generated */
  insightsGeneratedAt?: Maybe<Scalars['Time']['output']>;
  /** The selected learning objectives for this post */
  learningObjectives?: Maybe<Array<LearningObjective>>;
  likedAt?: Maybe<Scalars['Time']['output']>;
  /** The users who liked this post */
  likedUsers?: Maybe<Array<User>>;
  likes?: Maybe<Array<Like>>;
  /** The media items in this post */
  mediaItems?: Maybe<Array<MediaItem>>;
  /** The users mentioned in this post */
  mentions?: Maybe<Array<User>>;
  poll?: Maybe<Poll>;
  /** The collections this post is associated with */
  postCollections?: Maybe<Array<PostCollection>>;
  /** The post reports this post has received */
  postReports?: Maybe<Array<PostReport>>;
  postlearningobectives?: Maybe<Array<PostLearningObjective>>;
  /** Whether reflections are enabled for this post */
  reflectionsEnabled?: Maybe<Scalars['Boolean']['output']>;
  reflectiveNudges?: Maybe<Array<Scalars['String']['output']>>;
  /** true if the current user has reported this post */
  reportedByCurrentUser?: Maybe<Scalars['Boolean']['output']>;
  /** The URL to use in the share sheet, social media or other sharing mechanisms */
  shareURL?: Maybe<Scalars['String']['output']>;
  sortKey?: Maybe<Scalars['Int']['output']>;
  sourceArticle?: Maybe<Article>;
  /** The current user's Sparky Chat for this post, if it exists */
  sparkyChat?: Maybe<SparkyChat>;
  /** The ID of this post in SpeakAI */
  speakMediaID?: Maybe<Scalars['String']['output']>;
  /**
   * The status of the post.
   * - draft: The post is in draft mode and is only visible to the post author.
   * - published: The post is published and visible in the feed and searchable.
   * - archived: The post is archived and not visible to anyone except an admin.
   * - deleted: The post is deleted and not visible to anyone except an admin.
   * - processing: The post is being processed and is only visible to the post author.
   */
  status: PostStatus;
  /** A suggested body based on the audio transcription */
  suggestedBody?: Maybe<Scalars['String']['output']>;
  /** A suggested title based on the audio transcription */
  suggestedTitle?: Maybe<Scalars['String']['output']>;
  syntheticSuggestedSearches?: Maybe<Array<Scalars['String']['output']>>;
  /** The tags on this post */
  tags?: Maybe<Array<Tag>>;
  /** The tenant that the topic belongs to. */
  tenant?: Maybe<Tenant>;
  termFrequencies?: Maybe<Scalars['Map']['output']>;
  terms?: Maybe<Array<Scalars['String']['output']>>;
  /** The number of terms per minute in the video */
  termsPerMinute: Scalars['Float']['output'];
  /** Title of the post */
  title: Scalars['String']['output'];
  /** The top learning objectives for this post */
  topLearningObjectives?: Maybe<Array<Scalars['String']['output']>>;
  topicClassifications?: Maybe<Array<TopicClassification>>;
  /** The topics this post is associated with */
  topics?: Maybe<Array<Topic>>;
  /** Total number of bookmarks */
  totalBookmarks: Scalars['Int']['output'];
  /** Total number of comments */
  totalComments: Scalars['Int']['output'];
  /** The total duration of all videos for this post, in seconds. */
  totalDuration: Scalars['Int']['output'];
  /** Total number of images on this post. */
  totalImages: Scalars['Int']['output'];
  /** Total number of likes */
  totalLikes: Scalars['Int']['output'];
  /** Total number of times the video on this post has been played. */
  totalPlays: Scalars['Int']['output'];
  /** Total number of reactions */
  totalReactions: Scalars['Int']['output'];
  /** Total number of videos on this post. */
  totalVideos: Scalars['Int']['output'];
  /** The transcription result from SpeakAI */
  transcription?: Maybe<SpeakInsightResult>;
  /** The time when the transcription completed */
  transcriptionCompletedAt?: Maybe<Scalars['Time']['output']>;
  /** The time when the transcription started */
  transcriptionStartedAt?: Maybe<Scalars['Time']['output']>;
  /** The trending boost of the post. */
  trendingBoost: Scalars['Float']['output'];
  /** The type of the post */
  type: PostType;
  updatedAt: Scalars['Time']['output'];
  /** The videos for this post. */
  videos?: Maybe<Array<Video>>;
  wordcloud?: Maybe<Scalars['String']['output']>;
};


export type PostTopicClassificationsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  suggested?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PostCitation = Node & {
  __typename?: 'PostCitation';
  id: Scalars['ID']['output'];
  /** The name of the citation. */
  name: Scalars['String']['output'];
  /** The post that the citation was created on. */
  post?: Maybe<Post>;
  /** The url of the citation. */
  url: Scalars['String']['output'];
};

/**
 * PostCitationWhereInput is used for filtering PostCitation objects.
 * Input was generated by ent.
 */
export type PostCitationWhereInput = {
  and?: InputMaybe<Array<PostCitationWhereInput>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<PostCitationWhereInput>;
  or?: InputMaybe<Array<PostCitationWhereInput>>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']['input']>;
  urlContains?: InputMaybe<Scalars['String']['input']>;
  urlContainsFold?: InputMaybe<Scalars['String']['input']>;
  urlEqualFold?: InputMaybe<Scalars['String']['input']>;
  urlGT?: InputMaybe<Scalars['String']['input']>;
  urlGTE?: InputMaybe<Scalars['String']['input']>;
  urlHasPrefix?: InputMaybe<Scalars['String']['input']>;
  urlHasSuffix?: InputMaybe<Scalars['String']['input']>;
  urlIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlLT?: InputMaybe<Scalars['String']['input']>;
  urlLTE?: InputMaybe<Scalars['String']['input']>;
  urlNEQ?: InputMaybe<Scalars['String']['input']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type PostCollection = Node & {
  __typename?: 'PostCollection';
  collection: Collection;
  collectionID: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  ordinal: Scalars['Int']['output'];
  post: Post;
  postID: Scalars['ID']['output'];
};

/**
 * PostCollectionWhereInput is used for filtering PostCollection objects.
 * Input was generated by ent.
 */
export type PostCollectionWhereInput = {
  and?: InputMaybe<Array<PostCollectionWhereInput>>;
  /** collection_id field predicates */
  collectionID?: InputMaybe<Scalars['ID']['input']>;
  collectionIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  collectionIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  collectionIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** collection edge predicates */
  hasCollection?: InputMaybe<Scalars['Boolean']['input']>;
  hasCollectionWith?: InputMaybe<Array<CollectionWhereInput>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PostCollectionWhereInput>;
  or?: InputMaybe<Array<PostCollectionWhereInput>>;
  /** ordinal field predicates */
  ordinal?: InputMaybe<Scalars['Int']['input']>;
  ordinalGT?: InputMaybe<Scalars['Int']['input']>;
  ordinalGTE?: InputMaybe<Scalars['Int']['input']>;
  ordinalIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  ordinalLT?: InputMaybe<Scalars['Int']['input']>;
  ordinalLTE?: InputMaybe<Scalars['Int']['input']>;
  ordinalNEQ?: InputMaybe<Scalars['Int']['input']>;
  ordinalNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** post_id field predicates */
  postID?: InputMaybe<Scalars['ID']['input']>;
  postIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  postIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  postIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** A connection to a list of items. */
export type PostConnection = {
  __typename?: 'PostConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PostEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PostEdge = {
  __typename?: 'PostEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Post>;
};

export type PostEmbedding = Node & {
  __typename?: 'PostEmbedding';
  content: Scalars['String']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  post: Post;
  postID: Scalars['ID']['output'];
  type: PostEmbeddingType;
};

/** PostEmbeddingType is enum for the field type */
export enum PostEmbeddingType {
  BodyAndTitle = 'body_and_title',
  Transcript = 'transcript'
}

/**
 * PostEmbeddingWhereInput is used for filtering PostEmbedding objects.
 * Input was generated by ent.
 */
export type PostEmbeddingWhereInput = {
  and?: InputMaybe<Array<PostEmbeddingWhereInput>>;
  /** content field predicates */
  content?: InputMaybe<Scalars['String']['input']>;
  contentContains?: InputMaybe<Scalars['String']['input']>;
  contentContainsFold?: InputMaybe<Scalars['String']['input']>;
  contentEqualFold?: InputMaybe<Scalars['String']['input']>;
  contentGT?: InputMaybe<Scalars['String']['input']>;
  contentGTE?: InputMaybe<Scalars['String']['input']>;
  contentHasPrefix?: InputMaybe<Scalars['String']['input']>;
  contentHasSuffix?: InputMaybe<Scalars['String']['input']>;
  contentIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contentLT?: InputMaybe<Scalars['String']['input']>;
  contentLTE?: InputMaybe<Scalars['String']['input']>;
  contentNEQ?: InputMaybe<Scalars['String']['input']>;
  contentNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PostEmbeddingWhereInput>;
  or?: InputMaybe<Array<PostEmbeddingWhereInput>>;
  /** post_id field predicates */
  postID?: InputMaybe<Scalars['ID']['input']>;
  postIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  postIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  postIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** type field predicates */
  type?: InputMaybe<PostEmbeddingType>;
  typeIn?: InputMaybe<Array<PostEmbeddingType>>;
  typeNEQ?: InputMaybe<PostEmbeddingType>;
  typeNotIn?: InputMaybe<Array<PostEmbeddingType>>;
};

export type PostLearningObjective = Node & {
  __typename?: 'PostLearningObjective';
  id: Scalars['ID']['output'];
  learningObjective: LearningObjective;
  learningObjectiveID: Scalars['ID']['output'];
  ordinal: Scalars['Int']['output'];
  post: Post;
  postID: Scalars['ID']['output'];
};

/**
 * PostLearningObjectiveWhereInput is used for filtering PostLearningObjective objects.
 * Input was generated by ent.
 */
export type PostLearningObjectiveWhereInput = {
  and?: InputMaybe<Array<PostLearningObjectiveWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PostLearningObjectiveWhereInput>;
  or?: InputMaybe<Array<PostLearningObjectiveWhereInput>>;
  /** ordinal field predicates */
  ordinal?: InputMaybe<Scalars['Int']['input']>;
  ordinalGT?: InputMaybe<Scalars['Int']['input']>;
  ordinalGTE?: InputMaybe<Scalars['Int']['input']>;
  ordinalIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  ordinalLT?: InputMaybe<Scalars['Int']['input']>;
  ordinalLTE?: InputMaybe<Scalars['Int']['input']>;
  ordinalNEQ?: InputMaybe<Scalars['Int']['input']>;
  ordinalNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Ordering options for Post connections */
export type PostOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Posts. */
  field: PostOrderField;
};

/** Properties by which Post connections can be ordered. */
export enum PostOrderField {
  CreatedAt = 'CREATED_AT',
  CreditHours = 'CREDIT_HOURS',
  TermsPerMinute = 'TERMS_PER_MINUTE',
  TotalBookmarks = 'TOTAL_BOOKMARKS',
  TotalComments = 'TOTAL_COMMENTS',
  TotalDuration = 'TOTAL_DURATION',
  TotalLikes = 'TOTAL_LIKES',
  TotalReactions = 'TOTAL_REACTIONS',
  TrendingBoost = 'TRENDING_BOOST'
}

export type PostReaction = Node & {
  __typename?: 'PostReaction';
  id: Scalars['ID']['output'];
  /** The post that the user reacted to. */
  post: Post;
  postID: Scalars['ID']['output'];
  /** The time that the user reacted to the post. */
  reactedAt: Scalars['Time']['output'];
  /** The user that created the reaction. */
  user: User;
  userID: Scalars['ID']['output'];
  /** The text value of the reaction. */
  value: Scalars['String']['output'];
};

export type PostReactionInput = {
  postId: Scalars['ID']['input'];
  reaction: Scalars['String']['input'];
};

/**
 * PostReactionWhereInput is used for filtering PostReaction objects.
 * Input was generated by ent.
 */
export type PostReactionWhereInput = {
  and?: InputMaybe<Array<PostReactionWhereInput>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PostReactionWhereInput>;
  or?: InputMaybe<Array<PostReactionWhereInput>>;
  /** post_id field predicates */
  postID?: InputMaybe<Scalars['ID']['input']>;
  postIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  postIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  postIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** reacted_at field predicates */
  reactedAt?: InputMaybe<Scalars['Time']['input']>;
  reactedAtGT?: InputMaybe<Scalars['Time']['input']>;
  reactedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  reactedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  reactedAtLT?: InputMaybe<Scalars['Time']['input']>;
  reactedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  reactedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  reactedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** value field predicates */
  value?: InputMaybe<Scalars['String']['input']>;
  valueContains?: InputMaybe<Scalars['String']['input']>;
  valueContainsFold?: InputMaybe<Scalars['String']['input']>;
  valueEqualFold?: InputMaybe<Scalars['String']['input']>;
  valueGT?: InputMaybe<Scalars['String']['input']>;
  valueGTE?: InputMaybe<Scalars['String']['input']>;
  valueHasPrefix?: InputMaybe<Scalars['String']['input']>;
  valueHasSuffix?: InputMaybe<Scalars['String']['input']>;
  valueIn?: InputMaybe<Array<Scalars['String']['input']>>;
  valueLT?: InputMaybe<Scalars['String']['input']>;
  valueLTE?: InputMaybe<Scalars['String']['input']>;
  valueNEQ?: InputMaybe<Scalars['String']['input']>;
  valueNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type PostReport = Node & {
  __typename?: 'PostReport';
  /** The author of the post report */
  author?: Maybe<User>;
  createdAt: Scalars['Time']['output'];
  /** The description of the user report */
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The reason for the user report */
  reportReason?: Maybe<ReportReason>;
  /** The post that was reported */
  reportedPost?: Maybe<Post>;
  /** The time the report was reviewed */
  reviewedAt?: Maybe<Scalars['Time']['output']>;
  /** The admin user that reviewed the report */
  reviewedBy?: Maybe<User>;
};

/** A connection to a list of items. */
export type PostReportConnection = {
  __typename?: 'PostReportConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PostReportEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PostReportEdge = {
  __typename?: 'PostReportEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PostReport>;
};

/** Ordering options for PostReport connections */
export type PostReportOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order PostReports. */
  field: PostReportOrderField;
};

/** Properties by which PostReport connections can be ordered. */
export enum PostReportOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * PostReportWhereInput is used for filtering PostReport objects.
 * Input was generated by ent.
 */
export type PostReportWhereInput = {
  and?: InputMaybe<Array<PostReportWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** author edge predicates */
  hasAuthor?: InputMaybe<Scalars['Boolean']['input']>;
  hasAuthorWith?: InputMaybe<Array<UserWhereInput>>;
  /** report_reason edge predicates */
  hasReportReason?: InputMaybe<Scalars['Boolean']['input']>;
  hasReportReasonWith?: InputMaybe<Array<ReportReasonWhereInput>>;
  /** reported_post edge predicates */
  hasReportedPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasReportedPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** reviewed_by edge predicates */
  hasReviewedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasReviewedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PostReportWhereInput>;
  or?: InputMaybe<Array<PostReportWhereInput>>;
  /** reviewed_at field predicates */
  reviewedAt?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtGT?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  reviewedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  reviewedAtLT?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  reviewedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PostSearchConnection = {
  __typename?: 'PostSearchConnection';
  edges?: Maybe<Array<Maybe<PostEdge>>>;
  pageInfo: PageInfo;
  /** The topics that are present in the search results. */
  topics?: Maybe<Array<Maybe<Topic>>>;
  totalCount: Scalars['Int']['output'];
};

export type PostSearchResult = {
  __typename?: 'PostSearchResult';
  coverImage?: Maybe<SearchResultImage>;
  id: Scalars['ID']['output'];
  tags: Array<Scalars['String']['output']>;
  title: Scalars['String']['output'];
  topics: Array<TopicSearchResult>;
  user?: Maybe<UserSearchResult>;
  video?: Maybe<SearchResultVideo>;
};

/** PostStatus is enum for the field status */
export enum PostStatus {
  Archived = 'archived',
  Deleted = 'deleted',
  Draft = 'draft',
  Processing = 'processing',
  Published = 'published'
}

/** PostType is enum for the field type */
export enum PostType {
  Article = 'article',
  Image = 'image',
  Poll = 'poll',
  Text = 'text',
  Video = 'video'
}

/**
 * PostWhereInput is used for filtering Post objects.
 * Input was generated by ent.
 */
export type PostWhereInput = {
  and?: InputMaybe<Array<PostWhereInput>>;
  /** body field predicates */
  body?: InputMaybe<Scalars['String']['input']>;
  bodyContains?: InputMaybe<Scalars['String']['input']>;
  bodyContainsFold?: InputMaybe<Scalars['String']['input']>;
  bodyEqualFold?: InputMaybe<Scalars['String']['input']>;
  bodyGT?: InputMaybe<Scalars['String']['input']>;
  bodyGTE?: InputMaybe<Scalars['String']['input']>;
  bodyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bodyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bodyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bodyLT?: InputMaybe<Scalars['String']['input']>;
  bodyLTE?: InputMaybe<Scalars['String']['input']>;
  bodyNEQ?: InputMaybe<Scalars['String']['input']>;
  bodyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** ce field predicates */
  ce?: InputMaybe<Scalars['Boolean']['input']>;
  /** ce_disclosure_statements field predicates */
  ceDisclosureStatements?: InputMaybe<Scalars['String']['input']>;
  ceDisclosureStatementsContains?: InputMaybe<Scalars['String']['input']>;
  ceDisclosureStatementsContainsFold?: InputMaybe<Scalars['String']['input']>;
  ceDisclosureStatementsEqualFold?: InputMaybe<Scalars['String']['input']>;
  ceDisclosureStatementsGT?: InputMaybe<Scalars['String']['input']>;
  ceDisclosureStatementsGTE?: InputMaybe<Scalars['String']['input']>;
  ceDisclosureStatementsHasPrefix?: InputMaybe<Scalars['String']['input']>;
  ceDisclosureStatementsHasSuffix?: InputMaybe<Scalars['String']['input']>;
  ceDisclosureStatementsIn?: InputMaybe<Array<Scalars['String']['input']>>;
  ceDisclosureStatementsIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  ceDisclosureStatementsLT?: InputMaybe<Scalars['String']['input']>;
  ceDisclosureStatementsLTE?: InputMaybe<Scalars['String']['input']>;
  ceDisclosureStatementsNEQ?: InputMaybe<Scalars['String']['input']>;
  ceDisclosureStatementsNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  ceDisclosureStatementsNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  ceNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** credit_hours field predicates */
  creditHours?: InputMaybe<Scalars['Float']['input']>;
  creditHoursGT?: InputMaybe<Scalars['Float']['input']>;
  creditHoursGTE?: InputMaybe<Scalars['Float']['input']>;
  creditHoursIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  creditHoursLT?: InputMaybe<Scalars['Float']['input']>;
  creditHoursLTE?: InputMaybe<Scalars['Float']['input']>;
  creditHoursNEQ?: InputMaybe<Scalars['Float']['input']>;
  creditHoursNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** exclude_from_feed field predicates */
  excludeFromFeed?: InputMaybe<Scalars['Boolean']['input']>;
  excludeFromFeedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** external_url field predicates */
  externalURL?: InputMaybe<Scalars['String']['input']>;
  externalURLContains?: InputMaybe<Scalars['String']['input']>;
  externalURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  externalURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  externalURLGT?: InputMaybe<Scalars['String']['input']>;
  externalURLGTE?: InputMaybe<Scalars['String']['input']>;
  externalURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  externalURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  externalURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  externalURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  externalURLLT?: InputMaybe<Scalars['String']['input']>;
  externalURLLTE?: InputMaybe<Scalars['String']['input']>;
  externalURLNEQ?: InputMaybe<Scalars['String']['input']>;
  externalURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  externalURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** featured field predicates */
  featured?: InputMaybe<Scalars['Boolean']['input']>;
  featuredNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** accredited_learning_objective edge predicates */
  hasAccreditedLearningObjective?: InputMaybe<Scalars['Boolean']['input']>;
  hasAccreditedLearningObjectiveWith?: InputMaybe<Array<LearningObjectiveWhereInput>>;
  /** audiences edge predicates */
  hasAudiences?: InputMaybe<Scalars['Boolean']['input']>;
  hasAudiencesWith?: InputMaybe<Array<AudienceWhereInput>>;
  /** author edge predicates */
  hasAuthor?: InputMaybe<Scalars['Boolean']['input']>;
  hasAuthorWith?: InputMaybe<Array<UserWhereInput>>;
  /** bookmarked_users edge predicates */
  hasBookmarkedUsers?: InputMaybe<Scalars['Boolean']['input']>;
  hasBookmarkedUsersWith?: InputMaybe<Array<UserWhereInput>>;
  /** bookmarks edge predicates */
  hasBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  hasBookmarksWith?: InputMaybe<Array<BookmarkWhereInput>>;
  /** citations edge predicates */
  hasCitations?: InputMaybe<Scalars['Boolean']['input']>;
  hasCitationsWith?: InputMaybe<Array<PostCitationWhereInput>>;
  /** comments edge predicates */
  hasComments?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommentsWith?: InputMaybe<Array<CommentWhereInput>>;
  /** cover_image edge predicates */
  hasCoverImage?: InputMaybe<Scalars['Boolean']['input']>;
  hasCoverImageWith?: InputMaybe<Array<ImageWhereInput>>;
  /** education_credits edge predicates */
  hasEducationCredits?: InputMaybe<Scalars['Boolean']['input']>;
  hasEducationCreditsWith?: InputMaybe<Array<EducationCreditWhereInput>>;
  /** embeddings edge predicates */
  hasEmbeddings?: InputMaybe<Scalars['Boolean']['input']>;
  hasEmbeddingsWith?: InputMaybe<Array<PostEmbeddingWhereInput>>;
  /** feed_histories edge predicates */
  hasFeedHistories?: InputMaybe<Scalars['Boolean']['input']>;
  hasFeedHistoriesWith?: InputMaybe<Array<UserFeedHistoryWhereInput>>;
  /** images edge predicates */
  hasImages?: InputMaybe<Scalars['Boolean']['input']>;
  hasImagesWith?: InputMaybe<Array<ImageWhereInput>>;
  /** learning_objectives edge predicates */
  hasLearningObjectives?: InputMaybe<Scalars['Boolean']['input']>;
  hasLearningObjectivesWith?: InputMaybe<Array<LearningObjectiveWhereInput>>;
  /** liked_users edge predicates */
  hasLikedUsers?: InputMaybe<Scalars['Boolean']['input']>;
  hasLikedUsersWith?: InputMaybe<Array<UserWhereInput>>;
  /** likes edge predicates */
  hasLikes?: InputMaybe<Scalars['Boolean']['input']>;
  hasLikesWith?: InputMaybe<Array<LikeWhereInput>>;
  /** media_items edge predicates */
  hasMediaItems?: InputMaybe<Scalars['Boolean']['input']>;
  hasMediaItemsWith?: InputMaybe<Array<MediaItemWhereInput>>;
  /** mentions edge predicates */
  hasMentions?: InputMaybe<Scalars['Boolean']['input']>;
  hasMentionsWith?: InputMaybe<Array<UserWhereInput>>;
  /** poll edge predicates */
  hasPoll?: InputMaybe<Scalars['Boolean']['input']>;
  hasPollWith?: InputMaybe<Array<PollWhereInput>>;
  /** post_collections edge predicates */
  hasPostCollections?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostCollectionsWith?: InputMaybe<Array<PostCollectionWhereInput>>;
  /** post_reports edge predicates */
  hasPostReports?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostReportsWith?: InputMaybe<Array<PostReportWhereInput>>;
  /** post_tags edge predicates */
  hasPostTags?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostTagsWith?: InputMaybe<Array<TagWhereInput>>;
  /** postlearningobectives edge predicates */
  hasPostlearningobectives?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostlearningobectivesWith?: InputMaybe<Array<PostLearningObjectiveWhereInput>>;
  /** source_article edge predicates */
  hasSourceArticle?: InputMaybe<Scalars['Boolean']['input']>;
  hasSourceArticleWith?: InputMaybe<Array<ArticleWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']['input']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** topics edge predicates */
  hasTopics?: InputMaybe<Scalars['Boolean']['input']>;
  hasTopicsWith?: InputMaybe<Array<TopicWhereInput>>;
  /** videos edge predicates */
  hasVideos?: InputMaybe<Scalars['Boolean']['input']>;
  hasVideosWith?: InputMaybe<Array<VideoWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** insights_generated_at field predicates */
  insightsGeneratedAt?: InputMaybe<Scalars['Time']['input']>;
  insightsGeneratedAtGT?: InputMaybe<Scalars['Time']['input']>;
  insightsGeneratedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  insightsGeneratedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  insightsGeneratedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  insightsGeneratedAtLT?: InputMaybe<Scalars['Time']['input']>;
  insightsGeneratedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  insightsGeneratedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  insightsGeneratedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  insightsGeneratedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<PostWhereInput>;
  or?: InputMaybe<Array<PostWhereInput>>;
  /** share_url field predicates */
  shareURL?: InputMaybe<Scalars['String']['input']>;
  shareURLContains?: InputMaybe<Scalars['String']['input']>;
  shareURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  shareURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  shareURLGT?: InputMaybe<Scalars['String']['input']>;
  shareURLGTE?: InputMaybe<Scalars['String']['input']>;
  shareURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  shareURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  shareURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  shareURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  shareURLLT?: InputMaybe<Scalars['String']['input']>;
  shareURLLTE?: InputMaybe<Scalars['String']['input']>;
  shareURLNEQ?: InputMaybe<Scalars['String']['input']>;
  shareURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  shareURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** sort_key field predicates */
  sortKey?: InputMaybe<Scalars['Int']['input']>;
  sortKeyGT?: InputMaybe<Scalars['Int']['input']>;
  sortKeyGTE?: InputMaybe<Scalars['Int']['input']>;
  sortKeyIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  sortKeyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  sortKeyLT?: InputMaybe<Scalars['Int']['input']>;
  sortKeyLTE?: InputMaybe<Scalars['Int']['input']>;
  sortKeyNEQ?: InputMaybe<Scalars['Int']['input']>;
  sortKeyNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  sortKeyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** speak_media_id field predicates */
  speakMediaID?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDContains?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDGT?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDGTE?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  speakMediaIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  speakMediaIDLT?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDLTE?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDNEQ?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  speakMediaIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** status field predicates */
  status?: InputMaybe<PostStatus>;
  statusIn?: InputMaybe<Array<PostStatus>>;
  statusNEQ?: InputMaybe<PostStatus>;
  statusNotIn?: InputMaybe<Array<PostStatus>>;
  /** suggested_body field predicates */
  suggestedBody?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyContains?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyContainsFold?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyEqualFold?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyGT?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyGTE?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  suggestedBodyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  suggestedBodyLT?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyLTE?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyNEQ?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  suggestedBodyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** suggested_title field predicates */
  suggestedTitle?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleContains?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleContainsFold?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleEqualFold?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleGT?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleGTE?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  suggestedTitleIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  suggestedTitleLT?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleLTE?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleNEQ?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  suggestedTitleNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** terms_per_minute field predicates */
  termsPerMinute?: InputMaybe<Scalars['Float']['input']>;
  termsPerMinuteGT?: InputMaybe<Scalars['Float']['input']>;
  termsPerMinuteGTE?: InputMaybe<Scalars['Float']['input']>;
  termsPerMinuteIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  termsPerMinuteLT?: InputMaybe<Scalars['Float']['input']>;
  termsPerMinuteLTE?: InputMaybe<Scalars['Float']['input']>;
  termsPerMinuteNEQ?: InputMaybe<Scalars['Float']['input']>;
  termsPerMinuteNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** total_bookmarks field predicates */
  totalBookmarks?: InputMaybe<Scalars['Int']['input']>;
  totalBookmarksGT?: InputMaybe<Scalars['Int']['input']>;
  totalBookmarksGTE?: InputMaybe<Scalars['Int']['input']>;
  totalBookmarksIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalBookmarksLT?: InputMaybe<Scalars['Int']['input']>;
  totalBookmarksLTE?: InputMaybe<Scalars['Int']['input']>;
  totalBookmarksNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalBookmarksNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** total_comments field predicates */
  totalComments?: InputMaybe<Scalars['Int']['input']>;
  totalCommentsGT?: InputMaybe<Scalars['Int']['input']>;
  totalCommentsGTE?: InputMaybe<Scalars['Int']['input']>;
  totalCommentsIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalCommentsLT?: InputMaybe<Scalars['Int']['input']>;
  totalCommentsLTE?: InputMaybe<Scalars['Int']['input']>;
  totalCommentsNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalCommentsNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** total_duration field predicates */
  totalDuration?: InputMaybe<Scalars['Int']['input']>;
  totalDurationGT?: InputMaybe<Scalars['Int']['input']>;
  totalDurationGTE?: InputMaybe<Scalars['Int']['input']>;
  totalDurationIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalDurationLT?: InputMaybe<Scalars['Int']['input']>;
  totalDurationLTE?: InputMaybe<Scalars['Int']['input']>;
  totalDurationNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalDurationNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** total_images field predicates */
  totalImages?: InputMaybe<Scalars['Int']['input']>;
  totalImagesGT?: InputMaybe<Scalars['Int']['input']>;
  totalImagesGTE?: InputMaybe<Scalars['Int']['input']>;
  totalImagesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalImagesLT?: InputMaybe<Scalars['Int']['input']>;
  totalImagesLTE?: InputMaybe<Scalars['Int']['input']>;
  totalImagesNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalImagesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** total_likes field predicates */
  totalLikes?: InputMaybe<Scalars['Int']['input']>;
  totalLikesGT?: InputMaybe<Scalars['Int']['input']>;
  totalLikesGTE?: InputMaybe<Scalars['Int']['input']>;
  totalLikesIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalLikesLT?: InputMaybe<Scalars['Int']['input']>;
  totalLikesLTE?: InputMaybe<Scalars['Int']['input']>;
  totalLikesNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalLikesNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** total_plays field predicates */
  totalPlays?: InputMaybe<Scalars['Int']['input']>;
  totalPlaysGT?: InputMaybe<Scalars['Int']['input']>;
  totalPlaysGTE?: InputMaybe<Scalars['Int']['input']>;
  totalPlaysIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalPlaysLT?: InputMaybe<Scalars['Int']['input']>;
  totalPlaysLTE?: InputMaybe<Scalars['Int']['input']>;
  totalPlaysNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalPlaysNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** total_reactions field predicates */
  totalReactions?: InputMaybe<Scalars['Int']['input']>;
  totalReactionsGT?: InputMaybe<Scalars['Int']['input']>;
  totalReactionsGTE?: InputMaybe<Scalars['Int']['input']>;
  totalReactionsIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalReactionsLT?: InputMaybe<Scalars['Int']['input']>;
  totalReactionsLTE?: InputMaybe<Scalars['Int']['input']>;
  totalReactionsNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalReactionsNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** total_videos field predicates */
  totalVideos?: InputMaybe<Scalars['Int']['input']>;
  totalVideosGT?: InputMaybe<Scalars['Int']['input']>;
  totalVideosGTE?: InputMaybe<Scalars['Int']['input']>;
  totalVideosIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalVideosLT?: InputMaybe<Scalars['Int']['input']>;
  totalVideosLTE?: InputMaybe<Scalars['Int']['input']>;
  totalVideosNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalVideosNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** transcription_completed_at field predicates */
  transcriptionCompletedAt?: InputMaybe<Scalars['Time']['input']>;
  transcriptionCompletedAtGT?: InputMaybe<Scalars['Time']['input']>;
  transcriptionCompletedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  transcriptionCompletedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  transcriptionCompletedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  transcriptionCompletedAtLT?: InputMaybe<Scalars['Time']['input']>;
  transcriptionCompletedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  transcriptionCompletedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  transcriptionCompletedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  transcriptionCompletedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** transcription_started_at field predicates */
  transcriptionStartedAt?: InputMaybe<Scalars['Time']['input']>;
  transcriptionStartedAtGT?: InputMaybe<Scalars['Time']['input']>;
  transcriptionStartedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  transcriptionStartedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  transcriptionStartedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  transcriptionStartedAtLT?: InputMaybe<Scalars['Time']['input']>;
  transcriptionStartedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  transcriptionStartedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  transcriptionStartedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  transcriptionStartedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** trending_boost field predicates */
  trendingBoost?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostGT?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostGTE?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  trendingBoostLT?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostLTE?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostNEQ?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** type field predicates */
  type?: InputMaybe<PostType>;
  typeIn?: InputMaybe<Array<PostType>>;
  typeNEQ?: InputMaybe<PostType>;
  typeNotIn?: InputMaybe<Array<PostType>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** wordcloud field predicates */
  wordcloud?: InputMaybe<Scalars['String']['input']>;
  wordcloudContains?: InputMaybe<Scalars['String']['input']>;
  wordcloudContainsFold?: InputMaybe<Scalars['String']['input']>;
  wordcloudEqualFold?: InputMaybe<Scalars['String']['input']>;
  wordcloudGT?: InputMaybe<Scalars['String']['input']>;
  wordcloudGTE?: InputMaybe<Scalars['String']['input']>;
  wordcloudHasPrefix?: InputMaybe<Scalars['String']['input']>;
  wordcloudHasSuffix?: InputMaybe<Scalars['String']['input']>;
  wordcloudIn?: InputMaybe<Array<Scalars['String']['input']>>;
  wordcloudIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  wordcloudLT?: InputMaybe<Scalars['String']['input']>;
  wordcloudLTE?: InputMaybe<Scalars['String']['input']>;
  wordcloudNEQ?: InputMaybe<Scalars['String']['input']>;
  wordcloudNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  wordcloudNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PreviousReflectionResultInput = {
  followUpPrompt?: InputMaybe<Scalars['String']['input']>;
  isInquisitive?: InputMaybe<Scalars['Boolean']['input']>;
  isLinguisticallyAcceptable?: InputMaybe<Scalars['Boolean']['input']>;
  isReflective?: InputMaybe<Scalars['Boolean']['input']>;
  isToxic?: InputMaybe<Scalars['Boolean']['input']>;
  medicalTermCount?: InputMaybe<Scalars['Int']['input']>;
  personalProperNounCount?: InputMaybe<Scalars['Int']['input']>;
  qaPrediction?: InputMaybe<Scalars['String']['input']>;
  shouldEarnCredits?: InputMaybe<Scalars['Boolean']['input']>;
  totalWords?: InputMaybe<Scalars['Int']['input']>;
};

export type Provider = Node & {
  __typename?: 'Provider';
  businessCity: Scalars['String']['output'];
  businessCountryCode: Scalars['String']['output'];
  businessMailAddress: Scalars['String']['output'];
  businessMailAddress2: Scalars['String']['output'];
  businessPostalCode: Scalars['String']['output'];
  businessState: Scalars['String']['output'];
  businessTelephoneNumber: Scalars['String']['output'];
  credential: Scalars['String']['output'];
  firstName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  licenseNumber: Scalars['String']['output'];
  licenseStateCode: Scalars['String']['output'];
  middleName: Scalars['String']['output'];
  npi: Scalars['String']['output'];
  practiceLocationAddress: Scalars['String']['output'];
  practiceLocationAddress2: Scalars['String']['output'];
  practiceLocationCity: Scalars['String']['output'];
  practiceLocationCountryCode: Scalars['String']['output'];
  practiceLocationPostalCode: Scalars['String']['output'];
  practiceLocationState: Scalars['String']['output'];
  practiceLocationTelephoneNumber: Scalars['String']['output'];
  prefix: Scalars['String']['output'];
  suffix: Scalars['String']['output'];
  taxonomyCode: Scalars['String']['output'];
};

/**
 * ProviderWhereInput is used for filtering Provider objects.
 * Input was generated by ent.
 */
export type ProviderWhereInput = {
  and?: InputMaybe<Array<ProviderWhereInput>>;
  /** business_city field predicates */
  businessCity?: InputMaybe<Scalars['String']['input']>;
  businessCityContains?: InputMaybe<Scalars['String']['input']>;
  businessCityContainsFold?: InputMaybe<Scalars['String']['input']>;
  businessCityEqualFold?: InputMaybe<Scalars['String']['input']>;
  businessCityGT?: InputMaybe<Scalars['String']['input']>;
  businessCityGTE?: InputMaybe<Scalars['String']['input']>;
  businessCityHasPrefix?: InputMaybe<Scalars['String']['input']>;
  businessCityHasSuffix?: InputMaybe<Scalars['String']['input']>;
  businessCityIn?: InputMaybe<Array<Scalars['String']['input']>>;
  businessCityLT?: InputMaybe<Scalars['String']['input']>;
  businessCityLTE?: InputMaybe<Scalars['String']['input']>;
  businessCityNEQ?: InputMaybe<Scalars['String']['input']>;
  businessCityNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** business_country_code field predicates */
  businessCountryCode?: InputMaybe<Scalars['String']['input']>;
  businessCountryCodeContains?: InputMaybe<Scalars['String']['input']>;
  businessCountryCodeContainsFold?: InputMaybe<Scalars['String']['input']>;
  businessCountryCodeEqualFold?: InputMaybe<Scalars['String']['input']>;
  businessCountryCodeGT?: InputMaybe<Scalars['String']['input']>;
  businessCountryCodeGTE?: InputMaybe<Scalars['String']['input']>;
  businessCountryCodeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  businessCountryCodeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  businessCountryCodeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  businessCountryCodeLT?: InputMaybe<Scalars['String']['input']>;
  businessCountryCodeLTE?: InputMaybe<Scalars['String']['input']>;
  businessCountryCodeNEQ?: InputMaybe<Scalars['String']['input']>;
  businessCountryCodeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** business_mail_address field predicates */
  businessMailAddress?: InputMaybe<Scalars['String']['input']>;
  /** business_mail_address_2 field predicates */
  businessMailAddress2?: InputMaybe<Scalars['String']['input']>;
  businessMailAddress2Contains?: InputMaybe<Scalars['String']['input']>;
  businessMailAddress2ContainsFold?: InputMaybe<Scalars['String']['input']>;
  businessMailAddress2EqualFold?: InputMaybe<Scalars['String']['input']>;
  businessMailAddress2GT?: InputMaybe<Scalars['String']['input']>;
  businessMailAddress2GTE?: InputMaybe<Scalars['String']['input']>;
  businessMailAddress2HasPrefix?: InputMaybe<Scalars['String']['input']>;
  businessMailAddress2HasSuffix?: InputMaybe<Scalars['String']['input']>;
  businessMailAddress2In?: InputMaybe<Array<Scalars['String']['input']>>;
  businessMailAddress2LT?: InputMaybe<Scalars['String']['input']>;
  businessMailAddress2LTE?: InputMaybe<Scalars['String']['input']>;
  businessMailAddress2NEQ?: InputMaybe<Scalars['String']['input']>;
  businessMailAddress2NotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  businessMailAddressContains?: InputMaybe<Scalars['String']['input']>;
  businessMailAddressContainsFold?: InputMaybe<Scalars['String']['input']>;
  businessMailAddressEqualFold?: InputMaybe<Scalars['String']['input']>;
  businessMailAddressGT?: InputMaybe<Scalars['String']['input']>;
  businessMailAddressGTE?: InputMaybe<Scalars['String']['input']>;
  businessMailAddressHasPrefix?: InputMaybe<Scalars['String']['input']>;
  businessMailAddressHasSuffix?: InputMaybe<Scalars['String']['input']>;
  businessMailAddressIn?: InputMaybe<Array<Scalars['String']['input']>>;
  businessMailAddressLT?: InputMaybe<Scalars['String']['input']>;
  businessMailAddressLTE?: InputMaybe<Scalars['String']['input']>;
  businessMailAddressNEQ?: InputMaybe<Scalars['String']['input']>;
  businessMailAddressNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** business_postal_code field predicates */
  businessPostalCode?: InputMaybe<Scalars['String']['input']>;
  businessPostalCodeContains?: InputMaybe<Scalars['String']['input']>;
  businessPostalCodeContainsFold?: InputMaybe<Scalars['String']['input']>;
  businessPostalCodeEqualFold?: InputMaybe<Scalars['String']['input']>;
  businessPostalCodeGT?: InputMaybe<Scalars['String']['input']>;
  businessPostalCodeGTE?: InputMaybe<Scalars['String']['input']>;
  businessPostalCodeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  businessPostalCodeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  businessPostalCodeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  businessPostalCodeLT?: InputMaybe<Scalars['String']['input']>;
  businessPostalCodeLTE?: InputMaybe<Scalars['String']['input']>;
  businessPostalCodeNEQ?: InputMaybe<Scalars['String']['input']>;
  businessPostalCodeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** business_state field predicates */
  businessState?: InputMaybe<Scalars['String']['input']>;
  businessStateContains?: InputMaybe<Scalars['String']['input']>;
  businessStateContainsFold?: InputMaybe<Scalars['String']['input']>;
  businessStateEqualFold?: InputMaybe<Scalars['String']['input']>;
  businessStateGT?: InputMaybe<Scalars['String']['input']>;
  businessStateGTE?: InputMaybe<Scalars['String']['input']>;
  businessStateHasPrefix?: InputMaybe<Scalars['String']['input']>;
  businessStateHasSuffix?: InputMaybe<Scalars['String']['input']>;
  businessStateIn?: InputMaybe<Array<Scalars['String']['input']>>;
  businessStateLT?: InputMaybe<Scalars['String']['input']>;
  businessStateLTE?: InputMaybe<Scalars['String']['input']>;
  businessStateNEQ?: InputMaybe<Scalars['String']['input']>;
  businessStateNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** business_telephone_number field predicates */
  businessTelephoneNumber?: InputMaybe<Scalars['String']['input']>;
  businessTelephoneNumberContains?: InputMaybe<Scalars['String']['input']>;
  businessTelephoneNumberContainsFold?: InputMaybe<Scalars['String']['input']>;
  businessTelephoneNumberEqualFold?: InputMaybe<Scalars['String']['input']>;
  businessTelephoneNumberGT?: InputMaybe<Scalars['String']['input']>;
  businessTelephoneNumberGTE?: InputMaybe<Scalars['String']['input']>;
  businessTelephoneNumberHasPrefix?: InputMaybe<Scalars['String']['input']>;
  businessTelephoneNumberHasSuffix?: InputMaybe<Scalars['String']['input']>;
  businessTelephoneNumberIn?: InputMaybe<Array<Scalars['String']['input']>>;
  businessTelephoneNumberLT?: InputMaybe<Scalars['String']['input']>;
  businessTelephoneNumberLTE?: InputMaybe<Scalars['String']['input']>;
  businessTelephoneNumberNEQ?: InputMaybe<Scalars['String']['input']>;
  businessTelephoneNumberNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** credential field predicates */
  credential?: InputMaybe<Scalars['String']['input']>;
  credentialContains?: InputMaybe<Scalars['String']['input']>;
  credentialContainsFold?: InputMaybe<Scalars['String']['input']>;
  credentialEqualFold?: InputMaybe<Scalars['String']['input']>;
  credentialGT?: InputMaybe<Scalars['String']['input']>;
  credentialGTE?: InputMaybe<Scalars['String']['input']>;
  credentialHasPrefix?: InputMaybe<Scalars['String']['input']>;
  credentialHasSuffix?: InputMaybe<Scalars['String']['input']>;
  credentialIn?: InputMaybe<Array<Scalars['String']['input']>>;
  credentialLT?: InputMaybe<Scalars['String']['input']>;
  credentialLTE?: InputMaybe<Scalars['String']['input']>;
  credentialNEQ?: InputMaybe<Scalars['String']['input']>;
  credentialNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** first_name field predicates */
  firstName?: InputMaybe<Scalars['String']['input']>;
  firstNameContains?: InputMaybe<Scalars['String']['input']>;
  firstNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  firstNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  firstNameGT?: InputMaybe<Scalars['String']['input']>;
  firstNameGTE?: InputMaybe<Scalars['String']['input']>;
  firstNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  firstNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  firstNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  firstNameLT?: InputMaybe<Scalars['String']['input']>;
  firstNameLTE?: InputMaybe<Scalars['String']['input']>;
  firstNameNEQ?: InputMaybe<Scalars['String']['input']>;
  firstNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_name field predicates */
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastNameContains?: InputMaybe<Scalars['String']['input']>;
  lastNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  lastNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  lastNameGT?: InputMaybe<Scalars['String']['input']>;
  lastNameGTE?: InputMaybe<Scalars['String']['input']>;
  lastNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  lastNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  lastNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  lastNameLT?: InputMaybe<Scalars['String']['input']>;
  lastNameLTE?: InputMaybe<Scalars['String']['input']>;
  lastNameNEQ?: InputMaybe<Scalars['String']['input']>;
  lastNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** license_number field predicates */
  licenseNumber?: InputMaybe<Scalars['String']['input']>;
  licenseNumberContains?: InputMaybe<Scalars['String']['input']>;
  licenseNumberContainsFold?: InputMaybe<Scalars['String']['input']>;
  licenseNumberEqualFold?: InputMaybe<Scalars['String']['input']>;
  licenseNumberGT?: InputMaybe<Scalars['String']['input']>;
  licenseNumberGTE?: InputMaybe<Scalars['String']['input']>;
  licenseNumberHasPrefix?: InputMaybe<Scalars['String']['input']>;
  licenseNumberHasSuffix?: InputMaybe<Scalars['String']['input']>;
  licenseNumberIn?: InputMaybe<Array<Scalars['String']['input']>>;
  licenseNumberLT?: InputMaybe<Scalars['String']['input']>;
  licenseNumberLTE?: InputMaybe<Scalars['String']['input']>;
  licenseNumberNEQ?: InputMaybe<Scalars['String']['input']>;
  licenseNumberNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** license_state_code field predicates */
  licenseStateCode?: InputMaybe<Scalars['String']['input']>;
  licenseStateCodeContains?: InputMaybe<Scalars['String']['input']>;
  licenseStateCodeContainsFold?: InputMaybe<Scalars['String']['input']>;
  licenseStateCodeEqualFold?: InputMaybe<Scalars['String']['input']>;
  licenseStateCodeGT?: InputMaybe<Scalars['String']['input']>;
  licenseStateCodeGTE?: InputMaybe<Scalars['String']['input']>;
  licenseStateCodeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  licenseStateCodeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  licenseStateCodeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  licenseStateCodeLT?: InputMaybe<Scalars['String']['input']>;
  licenseStateCodeLTE?: InputMaybe<Scalars['String']['input']>;
  licenseStateCodeNEQ?: InputMaybe<Scalars['String']['input']>;
  licenseStateCodeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** middle_name field predicates */
  middleName?: InputMaybe<Scalars['String']['input']>;
  middleNameContains?: InputMaybe<Scalars['String']['input']>;
  middleNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  middleNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  middleNameGT?: InputMaybe<Scalars['String']['input']>;
  middleNameGTE?: InputMaybe<Scalars['String']['input']>;
  middleNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  middleNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  middleNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  middleNameLT?: InputMaybe<Scalars['String']['input']>;
  middleNameLTE?: InputMaybe<Scalars['String']['input']>;
  middleNameNEQ?: InputMaybe<Scalars['String']['input']>;
  middleNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ProviderWhereInput>;
  /** npi field predicates */
  npi?: InputMaybe<Scalars['String']['input']>;
  npiContains?: InputMaybe<Scalars['String']['input']>;
  npiContainsFold?: InputMaybe<Scalars['String']['input']>;
  npiEqualFold?: InputMaybe<Scalars['String']['input']>;
  npiGT?: InputMaybe<Scalars['String']['input']>;
  npiGTE?: InputMaybe<Scalars['String']['input']>;
  npiHasPrefix?: InputMaybe<Scalars['String']['input']>;
  npiHasSuffix?: InputMaybe<Scalars['String']['input']>;
  npiIn?: InputMaybe<Array<Scalars['String']['input']>>;
  npiLT?: InputMaybe<Scalars['String']['input']>;
  npiLTE?: InputMaybe<Scalars['String']['input']>;
  npiNEQ?: InputMaybe<Scalars['String']['input']>;
  npiNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  or?: InputMaybe<Array<ProviderWhereInput>>;
  /** practice_location_address field predicates */
  practiceLocationAddress?: InputMaybe<Scalars['String']['input']>;
  /** practice_location_address_2 field predicates */
  practiceLocationAddress2?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddress2Contains?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddress2ContainsFold?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddress2EqualFold?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddress2GT?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddress2GTE?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddress2HasPrefix?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddress2HasSuffix?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddress2In?: InputMaybe<Array<Scalars['String']['input']>>;
  practiceLocationAddress2LT?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddress2LTE?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddress2NEQ?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddress2NotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  practiceLocationAddressContains?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddressContainsFold?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddressEqualFold?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddressGT?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddressGTE?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddressHasPrefix?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddressHasSuffix?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddressIn?: InputMaybe<Array<Scalars['String']['input']>>;
  practiceLocationAddressLT?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddressLTE?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddressNEQ?: InputMaybe<Scalars['String']['input']>;
  practiceLocationAddressNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** practice_location_city field predicates */
  practiceLocationCity?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCityContains?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCityContainsFold?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCityEqualFold?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCityGT?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCityGTE?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCityHasPrefix?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCityHasSuffix?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCityIn?: InputMaybe<Array<Scalars['String']['input']>>;
  practiceLocationCityLT?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCityLTE?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCityNEQ?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCityNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** practice_location_country_code field predicates */
  practiceLocationCountryCode?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCountryCodeContains?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCountryCodeContainsFold?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCountryCodeEqualFold?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCountryCodeGT?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCountryCodeGTE?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCountryCodeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCountryCodeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCountryCodeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  practiceLocationCountryCodeLT?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCountryCodeLTE?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCountryCodeNEQ?: InputMaybe<Scalars['String']['input']>;
  practiceLocationCountryCodeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** practice_location_postal_code field predicates */
  practiceLocationPostalCode?: InputMaybe<Scalars['String']['input']>;
  practiceLocationPostalCodeContains?: InputMaybe<Scalars['String']['input']>;
  practiceLocationPostalCodeContainsFold?: InputMaybe<Scalars['String']['input']>;
  practiceLocationPostalCodeEqualFold?: InputMaybe<Scalars['String']['input']>;
  practiceLocationPostalCodeGT?: InputMaybe<Scalars['String']['input']>;
  practiceLocationPostalCodeGTE?: InputMaybe<Scalars['String']['input']>;
  practiceLocationPostalCodeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  practiceLocationPostalCodeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  practiceLocationPostalCodeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  practiceLocationPostalCodeLT?: InputMaybe<Scalars['String']['input']>;
  practiceLocationPostalCodeLTE?: InputMaybe<Scalars['String']['input']>;
  practiceLocationPostalCodeNEQ?: InputMaybe<Scalars['String']['input']>;
  practiceLocationPostalCodeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** practice_location_state field predicates */
  practiceLocationState?: InputMaybe<Scalars['String']['input']>;
  practiceLocationStateContains?: InputMaybe<Scalars['String']['input']>;
  practiceLocationStateContainsFold?: InputMaybe<Scalars['String']['input']>;
  practiceLocationStateEqualFold?: InputMaybe<Scalars['String']['input']>;
  practiceLocationStateGT?: InputMaybe<Scalars['String']['input']>;
  practiceLocationStateGTE?: InputMaybe<Scalars['String']['input']>;
  practiceLocationStateHasPrefix?: InputMaybe<Scalars['String']['input']>;
  practiceLocationStateHasSuffix?: InputMaybe<Scalars['String']['input']>;
  practiceLocationStateIn?: InputMaybe<Array<Scalars['String']['input']>>;
  practiceLocationStateLT?: InputMaybe<Scalars['String']['input']>;
  practiceLocationStateLTE?: InputMaybe<Scalars['String']['input']>;
  practiceLocationStateNEQ?: InputMaybe<Scalars['String']['input']>;
  practiceLocationStateNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** practice_location_telephone_number field predicates */
  practiceLocationTelephoneNumber?: InputMaybe<Scalars['String']['input']>;
  practiceLocationTelephoneNumberContains?: InputMaybe<Scalars['String']['input']>;
  practiceLocationTelephoneNumberContainsFold?: InputMaybe<Scalars['String']['input']>;
  practiceLocationTelephoneNumberEqualFold?: InputMaybe<Scalars['String']['input']>;
  practiceLocationTelephoneNumberGT?: InputMaybe<Scalars['String']['input']>;
  practiceLocationTelephoneNumberGTE?: InputMaybe<Scalars['String']['input']>;
  practiceLocationTelephoneNumberHasPrefix?: InputMaybe<Scalars['String']['input']>;
  practiceLocationTelephoneNumberHasSuffix?: InputMaybe<Scalars['String']['input']>;
  practiceLocationTelephoneNumberIn?: InputMaybe<Array<Scalars['String']['input']>>;
  practiceLocationTelephoneNumberLT?: InputMaybe<Scalars['String']['input']>;
  practiceLocationTelephoneNumberLTE?: InputMaybe<Scalars['String']['input']>;
  practiceLocationTelephoneNumberNEQ?: InputMaybe<Scalars['String']['input']>;
  practiceLocationTelephoneNumberNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** prefix field predicates */
  prefix?: InputMaybe<Scalars['String']['input']>;
  prefixContains?: InputMaybe<Scalars['String']['input']>;
  prefixContainsFold?: InputMaybe<Scalars['String']['input']>;
  prefixEqualFold?: InputMaybe<Scalars['String']['input']>;
  prefixGT?: InputMaybe<Scalars['String']['input']>;
  prefixGTE?: InputMaybe<Scalars['String']['input']>;
  prefixHasPrefix?: InputMaybe<Scalars['String']['input']>;
  prefixHasSuffix?: InputMaybe<Scalars['String']['input']>;
  prefixIn?: InputMaybe<Array<Scalars['String']['input']>>;
  prefixLT?: InputMaybe<Scalars['String']['input']>;
  prefixLTE?: InputMaybe<Scalars['String']['input']>;
  prefixNEQ?: InputMaybe<Scalars['String']['input']>;
  prefixNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** suffix field predicates */
  suffix?: InputMaybe<Scalars['String']['input']>;
  suffixContains?: InputMaybe<Scalars['String']['input']>;
  suffixContainsFold?: InputMaybe<Scalars['String']['input']>;
  suffixEqualFold?: InputMaybe<Scalars['String']['input']>;
  suffixGT?: InputMaybe<Scalars['String']['input']>;
  suffixGTE?: InputMaybe<Scalars['String']['input']>;
  suffixHasPrefix?: InputMaybe<Scalars['String']['input']>;
  suffixHasSuffix?: InputMaybe<Scalars['String']['input']>;
  suffixIn?: InputMaybe<Array<Scalars['String']['input']>>;
  suffixLT?: InputMaybe<Scalars['String']['input']>;
  suffixLTE?: InputMaybe<Scalars['String']['input']>;
  suffixNEQ?: InputMaybe<Scalars['String']['input']>;
  suffixNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** taxonomy_code field predicates */
  taxonomyCode?: InputMaybe<Scalars['String']['input']>;
  taxonomyCodeContains?: InputMaybe<Scalars['String']['input']>;
  taxonomyCodeContainsFold?: InputMaybe<Scalars['String']['input']>;
  taxonomyCodeEqualFold?: InputMaybe<Scalars['String']['input']>;
  taxonomyCodeGT?: InputMaybe<Scalars['String']['input']>;
  taxonomyCodeGTE?: InputMaybe<Scalars['String']['input']>;
  taxonomyCodeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  taxonomyCodeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  taxonomyCodeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  taxonomyCodeLT?: InputMaybe<Scalars['String']['input']>;
  taxonomyCodeLTE?: InputMaybe<Scalars['String']['input']>;
  taxonomyCodeNEQ?: InputMaybe<Scalars['String']['input']>;
  taxonomyCodeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type PubmedAbstractEmbedding = Node & {
  __typename?: 'PubmedAbstractEmbedding';
  abstract: PubmedArticleAbstract;
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  pubmedAbstractID: Scalars['ID']['output'];
  pubmedArticle: PubmedArticle;
  pubmedArticleID: Scalars['ID']['output'];
};

/**
 * PubmedAbstractEmbeddingWhereInput is used for filtering PubmedAbstractEmbedding objects.
 * Input was generated by ent.
 */
export type PubmedAbstractEmbeddingWhereInput = {
  and?: InputMaybe<Array<PubmedAbstractEmbeddingWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** abstract edge predicates */
  hasAbstract?: InputMaybe<Scalars['Boolean']['input']>;
  hasAbstractWith?: InputMaybe<Array<PubmedArticleAbstractWhereInput>>;
  /** pubmed_article edge predicates */
  hasPubmedArticle?: InputMaybe<Scalars['Boolean']['input']>;
  hasPubmedArticleWith?: InputMaybe<Array<PubmedArticleWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PubmedAbstractEmbeddingWhereInput>;
  or?: InputMaybe<Array<PubmedAbstractEmbeddingWhereInput>>;
  /** pubmed_abstract_id field predicates */
  pubmedAbstractID?: InputMaybe<Scalars['ID']['input']>;
  pubmedAbstractIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  pubmedAbstractIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  pubmedAbstractIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** pubmed_article_id field predicates */
  pubmedArticleID?: InputMaybe<Scalars['ID']['input']>;
  pubmedArticleIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  pubmedArticleIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  pubmedArticleIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type PubmedArticle = Node & {
  __typename?: 'PubmedArticle';
  abstract?: Maybe<Scalars['String']['output']>;
  abstractCopyright?: Maybe<Scalars['String']['output']>;
  abstractStructured?: Maybe<Array<Abstract>>;
  abstracts?: Maybe<Array<PubmedArticleAbstract>>;
  articleIDList?: Maybe<Array<ArticleId>>;
  authorList?: Maybe<Array<Author>>;
  /** When the article was created in out database */
  createdAt: Scalars['Time']['output'];
  /** The date the article was created in pubmed */
  dateCompleted?: Maybe<Scalars['Time']['output']>;
  /** The date the article was revised in pubmed */
  dateRevised?: Maybe<Scalars['Time']['output']>;
  embeddings?: Maybe<Array<PubmedAbstractEmbedding>>;
  /** When the embeddings were generated for the article */
  embeddingsGeneratedAt?: Maybe<Scalars['Time']['output']>;
  grantList?: Maybe<Array<Grant>>;
  id: Scalars['ID']['output'];
  /** The file the article was imported from */
  importFile?: Maybe<Scalars['String']['output']>;
  /** When the article was indexed */
  indexedAt?: Maybe<Scalars['Time']['output']>;
  journal?: Maybe<Journal>;
  keywordList?: Maybe<Array<Scalars['String']['output']>>;
  /** Is the article in medline */
  medline: Scalars['Boolean']['output'];
  meshHeadingList?: Maybe<Array<MeshHeading>>;
  /** Is the article in PMC and open access */
  openAccess: Scalars['Boolean']['output'];
  /** Is the article in PMC */
  pmc: Scalars['Boolean']['output'];
  /** When the article was downloaded from PMC */
  pmcDownloadedAt?: Maybe<Scalars['Time']['output']>;
  /** The unique identifier for the article */
  pmid: Scalars['Int']['output'];
  referenceList?: Maybe<Array<Reference>>;
  /** The sparky queries that reference this article */
  sparkyQueries?: Maybe<Array<SparkyQuery>>;
  summary?: Maybe<Scalars['String']['output']>;
  /** When the summary was generated for the article */
  summaryGeneratedAt?: Maybe<Scalars['Time']['output']>;
  termFrequencies?: Maybe<Scalars['Map']['output']>;
  terms?: Maybe<Array<Scalars['String']['output']>>;
  title: Scalars['String']['output'];
  /** The number of tokens in the title and abstract */
  tokens?: Maybe<Scalars['Int']['output']>;
  topicClassifications?: Maybe<Array<TopicClassification>>;
  /** When the article was last updated in our database */
  updatedAt: Scalars['Time']['output'];
  /** When the article was vectorized */
  vectorizedAt?: Maybe<Scalars['Time']['output']>;
};

export type PubmedArticleAbstract = Node & {
  __typename?: 'PubmedArticleAbstract';
  content: Scalars['String']['output'];
  embedding?: Maybe<PubmedAbstractEmbedding>;
  id: Scalars['ID']['output'];
  label?: Maybe<Scalars['String']['output']>;
  nlmCategory?: Maybe<Scalars['String']['output']>;
  pmid?: Maybe<Scalars['Int']['output']>;
  pubmedArticle: PubmedArticle;
  pubmedArticleAbstracts: Scalars['ID']['output'];
};

/** A connection to a list of items. */
export type PubmedArticleAbstractConnection = {
  __typename?: 'PubmedArticleAbstractConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PubmedArticleAbstractEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PubmedArticleAbstractEdge = {
  __typename?: 'PubmedArticleAbstractEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PubmedArticleAbstract>;
};

/**
 * PubmedArticleAbstractWhereInput is used for filtering PubmedArticleAbstract objects.
 * Input was generated by ent.
 */
export type PubmedArticleAbstractWhereInput = {
  and?: InputMaybe<Array<PubmedArticleAbstractWhereInput>>;
  /** content field predicates */
  content?: InputMaybe<Scalars['String']['input']>;
  contentContains?: InputMaybe<Scalars['String']['input']>;
  contentContainsFold?: InputMaybe<Scalars['String']['input']>;
  contentEqualFold?: InputMaybe<Scalars['String']['input']>;
  contentGT?: InputMaybe<Scalars['String']['input']>;
  contentGTE?: InputMaybe<Scalars['String']['input']>;
  contentHasPrefix?: InputMaybe<Scalars['String']['input']>;
  contentHasSuffix?: InputMaybe<Scalars['String']['input']>;
  contentIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contentLT?: InputMaybe<Scalars['String']['input']>;
  contentLTE?: InputMaybe<Scalars['String']['input']>;
  contentNEQ?: InputMaybe<Scalars['String']['input']>;
  contentNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** embedding edge predicates */
  hasEmbedding?: InputMaybe<Scalars['Boolean']['input']>;
  hasEmbeddingWith?: InputMaybe<Array<PubmedAbstractEmbeddingWhereInput>>;
  /** pubmed_article edge predicates */
  hasPubmedArticle?: InputMaybe<Scalars['Boolean']['input']>;
  hasPubmedArticleWith?: InputMaybe<Array<PubmedArticleWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']['input']>;
  labelContains?: InputMaybe<Scalars['String']['input']>;
  labelContainsFold?: InputMaybe<Scalars['String']['input']>;
  labelEqualFold?: InputMaybe<Scalars['String']['input']>;
  labelGT?: InputMaybe<Scalars['String']['input']>;
  labelGTE?: InputMaybe<Scalars['String']['input']>;
  labelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  labelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  labelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  labelIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  labelLT?: InputMaybe<Scalars['String']['input']>;
  labelLTE?: InputMaybe<Scalars['String']['input']>;
  labelNEQ?: InputMaybe<Scalars['String']['input']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  labelNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** nlm_category field predicates */
  nlmCategory?: InputMaybe<Scalars['String']['input']>;
  nlmCategoryContains?: InputMaybe<Scalars['String']['input']>;
  nlmCategoryContainsFold?: InputMaybe<Scalars['String']['input']>;
  nlmCategoryEqualFold?: InputMaybe<Scalars['String']['input']>;
  nlmCategoryGT?: InputMaybe<Scalars['String']['input']>;
  nlmCategoryGTE?: InputMaybe<Scalars['String']['input']>;
  nlmCategoryHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nlmCategoryHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nlmCategoryIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nlmCategoryIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nlmCategoryLT?: InputMaybe<Scalars['String']['input']>;
  nlmCategoryLTE?: InputMaybe<Scalars['String']['input']>;
  nlmCategoryNEQ?: InputMaybe<Scalars['String']['input']>;
  nlmCategoryNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nlmCategoryNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<PubmedArticleAbstractWhereInput>;
  or?: InputMaybe<Array<PubmedArticleAbstractWhereInput>>;
  /** pmid field predicates */
  pmid?: InputMaybe<Scalars['Int']['input']>;
  pmidGT?: InputMaybe<Scalars['Int']['input']>;
  pmidGTE?: InputMaybe<Scalars['Int']['input']>;
  pmidIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  pmidIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  pmidLT?: InputMaybe<Scalars['Int']['input']>;
  pmidLTE?: InputMaybe<Scalars['Int']['input']>;
  pmidNEQ?: InputMaybe<Scalars['Int']['input']>;
  pmidNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  pmidNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** pubmed_article_abstracts field predicates */
  pubmedArticleAbstracts?: InputMaybe<Scalars['ID']['input']>;
  pubmedArticleAbstractsIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  pubmedArticleAbstractsNEQ?: InputMaybe<Scalars['ID']['input']>;
  pubmedArticleAbstractsNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** A connection to a list of items. */
export type PubmedArticleConnection = {
  __typename?: 'PubmedArticleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PubmedArticleEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

export type PubmedArticleCountDate = {
  __typename?: 'PubmedArticleCountDate';
  count?: Maybe<Scalars['Int']['output']>;
  date?: Maybe<Scalars['Time']['output']>;
};

/** An edge in a connection. */
export type PubmedArticleEdge = {
  __typename?: 'PubmedArticleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PubmedArticle>;
};

export type PubmedArticleEmbedding = Node & {
  __typename?: 'PubmedArticleEmbedding';
  content: Scalars['String']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  pubmedArticle?: Maybe<PubmedArticle>;
};

/**
 * PubmedArticleEmbeddingWhereInput is used for filtering PubmedArticleEmbedding objects.
 * Input was generated by ent.
 */
export type PubmedArticleEmbeddingWhereInput = {
  and?: InputMaybe<Array<PubmedArticleEmbeddingWhereInput>>;
  /** content field predicates */
  content?: InputMaybe<Scalars['String']['input']>;
  contentContains?: InputMaybe<Scalars['String']['input']>;
  contentContainsFold?: InputMaybe<Scalars['String']['input']>;
  contentEqualFold?: InputMaybe<Scalars['String']['input']>;
  contentGT?: InputMaybe<Scalars['String']['input']>;
  contentGTE?: InputMaybe<Scalars['String']['input']>;
  contentHasPrefix?: InputMaybe<Scalars['String']['input']>;
  contentHasSuffix?: InputMaybe<Scalars['String']['input']>;
  contentIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contentLT?: InputMaybe<Scalars['String']['input']>;
  contentLTE?: InputMaybe<Scalars['String']['input']>;
  contentNEQ?: InputMaybe<Scalars['String']['input']>;
  contentNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** pubmed_article edge predicates */
  hasPubmedArticle?: InputMaybe<Scalars['Boolean']['input']>;
  hasPubmedArticleWith?: InputMaybe<Array<PubmedArticleWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PubmedArticleEmbeddingWhereInput>;
  or?: InputMaybe<Array<PubmedArticleEmbeddingWhereInput>>;
};

/** Ordering options for PubmedArticle connections */
export type PubmedArticleOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order PubmedArticles. */
  field: PubmedArticleOrderField;
};

/** Properties by which PubmedArticle connections can be ordered. */
export enum PubmedArticleOrderField {
  DateCompleted = 'date_completed',
  DateRevised = 'date_revised'
}

/**
 * PubmedArticleWhereInput is used for filtering PubmedArticle objects.
 * Input was generated by ent.
 */
export type PubmedArticleWhereInput = {
  /** abstract field predicates */
  abstract?: InputMaybe<Scalars['String']['input']>;
  abstractContains?: InputMaybe<Scalars['String']['input']>;
  abstractContainsFold?: InputMaybe<Scalars['String']['input']>;
  /** abstract_copyright field predicates */
  abstractCopyright?: InputMaybe<Scalars['String']['input']>;
  abstractCopyrightContains?: InputMaybe<Scalars['String']['input']>;
  abstractCopyrightContainsFold?: InputMaybe<Scalars['String']['input']>;
  abstractCopyrightEqualFold?: InputMaybe<Scalars['String']['input']>;
  abstractCopyrightGT?: InputMaybe<Scalars['String']['input']>;
  abstractCopyrightGTE?: InputMaybe<Scalars['String']['input']>;
  abstractCopyrightHasPrefix?: InputMaybe<Scalars['String']['input']>;
  abstractCopyrightHasSuffix?: InputMaybe<Scalars['String']['input']>;
  abstractCopyrightIn?: InputMaybe<Array<Scalars['String']['input']>>;
  abstractCopyrightIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  abstractCopyrightLT?: InputMaybe<Scalars['String']['input']>;
  abstractCopyrightLTE?: InputMaybe<Scalars['String']['input']>;
  abstractCopyrightNEQ?: InputMaybe<Scalars['String']['input']>;
  abstractCopyrightNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  abstractCopyrightNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  abstractEqualFold?: InputMaybe<Scalars['String']['input']>;
  abstractGT?: InputMaybe<Scalars['String']['input']>;
  abstractGTE?: InputMaybe<Scalars['String']['input']>;
  abstractHasPrefix?: InputMaybe<Scalars['String']['input']>;
  abstractHasSuffix?: InputMaybe<Scalars['String']['input']>;
  abstractIn?: InputMaybe<Array<Scalars['String']['input']>>;
  abstractIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  abstractLT?: InputMaybe<Scalars['String']['input']>;
  abstractLTE?: InputMaybe<Scalars['String']['input']>;
  abstractNEQ?: InputMaybe<Scalars['String']['input']>;
  abstractNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  abstractNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  and?: InputMaybe<Array<PubmedArticleWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** date_completed field predicates */
  dateCompleted?: InputMaybe<Scalars['Time']['input']>;
  dateCompletedGT?: InputMaybe<Scalars['Time']['input']>;
  dateCompletedGTE?: InputMaybe<Scalars['Time']['input']>;
  dateCompletedIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dateCompletedIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  dateCompletedLT?: InputMaybe<Scalars['Time']['input']>;
  dateCompletedLTE?: InputMaybe<Scalars['Time']['input']>;
  dateCompletedNEQ?: InputMaybe<Scalars['Time']['input']>;
  dateCompletedNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dateCompletedNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** date_revised field predicates */
  dateRevised?: InputMaybe<Scalars['Time']['input']>;
  dateRevisedGT?: InputMaybe<Scalars['Time']['input']>;
  dateRevisedGTE?: InputMaybe<Scalars['Time']['input']>;
  dateRevisedIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dateRevisedIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  dateRevisedLT?: InputMaybe<Scalars['Time']['input']>;
  dateRevisedLTE?: InputMaybe<Scalars['Time']['input']>;
  dateRevisedNEQ?: InputMaybe<Scalars['Time']['input']>;
  dateRevisedNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dateRevisedNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** embeddings_generated_at field predicates */
  embeddingsGeneratedAt?: InputMaybe<Scalars['Time']['input']>;
  embeddingsGeneratedAtGT?: InputMaybe<Scalars['Time']['input']>;
  embeddingsGeneratedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  embeddingsGeneratedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  embeddingsGeneratedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  embeddingsGeneratedAtLT?: InputMaybe<Scalars['Time']['input']>;
  embeddingsGeneratedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  embeddingsGeneratedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  embeddingsGeneratedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  embeddingsGeneratedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** abstracts edge predicates */
  hasAbstracts?: InputMaybe<Scalars['Boolean']['input']>;
  hasAbstractsWith?: InputMaybe<Array<PubmedArticleAbstractWhereInput>>;
  /** embeddings edge predicates */
  hasEmbeddings?: InputMaybe<Scalars['Boolean']['input']>;
  hasEmbeddingsWith?: InputMaybe<Array<PubmedAbstractEmbeddingWhereInput>>;
  /** sparky_queries edge predicates */
  hasSparkyQueries?: InputMaybe<Scalars['Boolean']['input']>;
  hasSparkyQueriesWith?: InputMaybe<Array<SparkyQueryWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** import_file field predicates */
  importFile?: InputMaybe<Scalars['String']['input']>;
  importFileContains?: InputMaybe<Scalars['String']['input']>;
  importFileContainsFold?: InputMaybe<Scalars['String']['input']>;
  importFileEqualFold?: InputMaybe<Scalars['String']['input']>;
  importFileGT?: InputMaybe<Scalars['String']['input']>;
  importFileGTE?: InputMaybe<Scalars['String']['input']>;
  importFileHasPrefix?: InputMaybe<Scalars['String']['input']>;
  importFileHasSuffix?: InputMaybe<Scalars['String']['input']>;
  importFileIn?: InputMaybe<Array<Scalars['String']['input']>>;
  importFileIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  importFileLT?: InputMaybe<Scalars['String']['input']>;
  importFileLTE?: InputMaybe<Scalars['String']['input']>;
  importFileNEQ?: InputMaybe<Scalars['String']['input']>;
  importFileNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  importFileNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** indexed_at field predicates */
  indexedAt?: InputMaybe<Scalars['Time']['input']>;
  indexedAtGT?: InputMaybe<Scalars['Time']['input']>;
  indexedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  indexedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  indexedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  indexedAtLT?: InputMaybe<Scalars['Time']['input']>;
  indexedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  indexedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  indexedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  indexedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** medline field predicates */
  medline?: InputMaybe<Scalars['Boolean']['input']>;
  medlineNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<PubmedArticleWhereInput>;
  /** open_access field predicates */
  openAccess?: InputMaybe<Scalars['Boolean']['input']>;
  openAccessNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  or?: InputMaybe<Array<PubmedArticleWhereInput>>;
  /** pmc field predicates */
  pmc?: InputMaybe<Scalars['Boolean']['input']>;
  /** pmc_downloaded_at field predicates */
  pmcDownloadedAt?: InputMaybe<Scalars['Time']['input']>;
  pmcDownloadedAtGT?: InputMaybe<Scalars['Time']['input']>;
  pmcDownloadedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  pmcDownloadedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  pmcDownloadedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  pmcDownloadedAtLT?: InputMaybe<Scalars['Time']['input']>;
  pmcDownloadedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  pmcDownloadedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  pmcDownloadedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  pmcDownloadedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  pmcNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** pmid field predicates */
  pmid?: InputMaybe<Scalars['Int']['input']>;
  pmidGT?: InputMaybe<Scalars['Int']['input']>;
  pmidGTE?: InputMaybe<Scalars['Int']['input']>;
  pmidIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  pmidLT?: InputMaybe<Scalars['Int']['input']>;
  pmidLTE?: InputMaybe<Scalars['Int']['input']>;
  pmidNEQ?: InputMaybe<Scalars['Int']['input']>;
  pmidNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** summary field predicates */
  summary?: InputMaybe<Scalars['String']['input']>;
  summaryContains?: InputMaybe<Scalars['String']['input']>;
  summaryContainsFold?: InputMaybe<Scalars['String']['input']>;
  summaryEqualFold?: InputMaybe<Scalars['String']['input']>;
  summaryGT?: InputMaybe<Scalars['String']['input']>;
  summaryGTE?: InputMaybe<Scalars['String']['input']>;
  /** summary_generated_at field predicates */
  summaryGeneratedAt?: InputMaybe<Scalars['Time']['input']>;
  summaryGeneratedAtGT?: InputMaybe<Scalars['Time']['input']>;
  summaryGeneratedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  summaryGeneratedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  summaryGeneratedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  summaryGeneratedAtLT?: InputMaybe<Scalars['Time']['input']>;
  summaryGeneratedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  summaryGeneratedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  summaryGeneratedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  summaryGeneratedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  summaryHasPrefix?: InputMaybe<Scalars['String']['input']>;
  summaryHasSuffix?: InputMaybe<Scalars['String']['input']>;
  summaryIn?: InputMaybe<Array<Scalars['String']['input']>>;
  summaryIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  summaryLT?: InputMaybe<Scalars['String']['input']>;
  summaryLTE?: InputMaybe<Scalars['String']['input']>;
  summaryNEQ?: InputMaybe<Scalars['String']['input']>;
  summaryNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  summaryNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** tokens field predicates */
  tokens?: InputMaybe<Scalars['Int']['input']>;
  tokensGT?: InputMaybe<Scalars['Int']['input']>;
  tokensGTE?: InputMaybe<Scalars['Int']['input']>;
  tokensIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  tokensIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  tokensLT?: InputMaybe<Scalars['Int']['input']>;
  tokensLTE?: InputMaybe<Scalars['Int']['input']>;
  tokensNEQ?: InputMaybe<Scalars['Int']['input']>;
  tokensNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  tokensNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** vectorized_at field predicates */
  vectorizedAt?: InputMaybe<Scalars['Time']['input']>;
  vectorizedAtGT?: InputMaybe<Scalars['Time']['input']>;
  vectorizedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  vectorizedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  vectorizedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  vectorizedAtLT?: InputMaybe<Scalars['Time']['input']>;
  vectorizedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  vectorizedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  vectorizedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  vectorizedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type PubmedCentralArticle = Node & {
  __typename?: 'PubmedCentralArticle';
  bioc?: Maybe<BioCDocument>;
  date?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  /** The unique identifier for the article */
  pmcid: Scalars['String']['output'];
};

/**
 * PubmedCentralArticleWhereInput is used for filtering PubmedCentralArticle objects.
 * Input was generated by ent.
 */
export type PubmedCentralArticleWhereInput = {
  and?: InputMaybe<Array<PubmedCentralArticleWhereInput>>;
  /** date field predicates */
  date?: InputMaybe<Scalars['Time']['input']>;
  dateGT?: InputMaybe<Scalars['Time']['input']>;
  dateGTE?: InputMaybe<Scalars['Time']['input']>;
  dateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  dateLT?: InputMaybe<Scalars['Time']['input']>;
  dateLTE?: InputMaybe<Scalars['Time']['input']>;
  dateNEQ?: InputMaybe<Scalars['Time']['input']>;
  dateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PubmedCentralArticleWhereInput>;
  or?: InputMaybe<Array<PubmedCentralArticleWhereInput>>;
  /** pmcid field predicates */
  pmcid?: InputMaybe<Scalars['String']['input']>;
  pmcidContains?: InputMaybe<Scalars['String']['input']>;
  pmcidContainsFold?: InputMaybe<Scalars['String']['input']>;
  pmcidEqualFold?: InputMaybe<Scalars['String']['input']>;
  pmcidGT?: InputMaybe<Scalars['String']['input']>;
  pmcidGTE?: InputMaybe<Scalars['String']['input']>;
  pmcidHasPrefix?: InputMaybe<Scalars['String']['input']>;
  pmcidHasSuffix?: InputMaybe<Scalars['String']['input']>;
  pmcidIn?: InputMaybe<Array<Scalars['String']['input']>>;
  pmcidLT?: InputMaybe<Scalars['String']['input']>;
  pmcidLTE?: InputMaybe<Scalars['String']['input']>;
  pmcidNEQ?: InputMaybe<Scalars['String']['input']>;
  pmcidNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type PubmedClusterCount = {
  __typename?: 'PubmedClusterCount';
  clusterLabel?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
};

export type PubmedClusterCountDate = {
  __typename?: 'PubmedClusterCountDate';
  clusterLabel?: Maybe<Scalars['String']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  date?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
};

export type PubmedDownloadLog = Node & {
  __typename?: 'PubmedDownloadLog';
  completedAt: Scalars['Time']['output'];
  createdAt: Scalars['Time']['output'];
  ftpDate: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  status?: Maybe<PubmedDownloadLogStatus>;
  url: Scalars['String']['output'];
};

/** PubmedDownloadLogStatus is enum for the field status */
export enum PubmedDownloadLogStatus {
  Failure = 'failure',
  Success = 'success'
}

/**
 * PubmedDownloadLogWhereInput is used for filtering PubmedDownloadLog objects.
 * Input was generated by ent.
 */
export type PubmedDownloadLogWhereInput = {
  and?: InputMaybe<Array<PubmedDownloadLogWhereInput>>;
  /** completed_at field predicates */
  completedAt?: InputMaybe<Scalars['Time']['input']>;
  completedAtGT?: InputMaybe<Scalars['Time']['input']>;
  completedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtLT?: InputMaybe<Scalars['Time']['input']>;
  completedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  completedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** ftp_date field predicates */
  ftpDate?: InputMaybe<Scalars['Time']['input']>;
  ftpDateGT?: InputMaybe<Scalars['Time']['input']>;
  ftpDateGTE?: InputMaybe<Scalars['Time']['input']>;
  ftpDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  ftpDateLT?: InputMaybe<Scalars['Time']['input']>;
  ftpDateLTE?: InputMaybe<Scalars['Time']['input']>;
  ftpDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  ftpDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<PubmedDownloadLogWhereInput>;
  or?: InputMaybe<Array<PubmedDownloadLogWhereInput>>;
  /** status field predicates */
  status?: InputMaybe<PubmedDownloadLogStatus>;
  statusIn?: InputMaybe<Array<PubmedDownloadLogStatus>>;
  statusIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  statusNEQ?: InputMaybe<PubmedDownloadLogStatus>;
  statusNotIn?: InputMaybe<Array<PubmedDownloadLogStatus>>;
  statusNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']['input']>;
  urlContains?: InputMaybe<Scalars['String']['input']>;
  urlContainsFold?: InputMaybe<Scalars['String']['input']>;
  urlEqualFold?: InputMaybe<Scalars['String']['input']>;
  urlGT?: InputMaybe<Scalars['String']['input']>;
  urlGTE?: InputMaybe<Scalars['String']['input']>;
  urlHasPrefix?: InputMaybe<Scalars['String']['input']>;
  urlHasSuffix?: InputMaybe<Scalars['String']['input']>;
  urlIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlLT?: InputMaybe<Scalars['String']['input']>;
  urlLTE?: InputMaybe<Scalars['String']['input']>;
  urlNEQ?: InputMaybe<Scalars['String']['input']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type PubmedEdge = {
  __typename?: 'PubmedEdge';
  cursor: Scalars['Cursor']['output'];
  node: PubmedArticle;
};

export type PubmedSearchConnection = {
  __typename?: 'PubmedSearchConnection';
  edges?: Maybe<Array<Maybe<PubmedEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type PubmedTopicCluster = Node & {
  __typename?: 'PubmedTopicCluster';
  clusterID: Scalars['Int']['output'];
  clusterLabel: Scalars['String']['output'];
  clusterWords: Array<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  label?: Maybe<Scalars['String']['output']>;
  pubmedArticles?: Maybe<Array<PubmedArticle>>;
  topicPubmedTopicCluster?: Maybe<Array<TopicPubmedTopicCluster>>;
  topics?: Maybe<Array<Topic>>;
};

/** A connection to a list of items. */
export type PubmedTopicClusterConnection = {
  __typename?: 'PubmedTopicClusterConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PubmedTopicClusterEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type PubmedTopicClusterEdge = {
  __typename?: 'PubmedTopicClusterEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<PubmedTopicCluster>;
};

/**
 * PubmedTopicClusterWhereInput is used for filtering PubmedTopicCluster objects.
 * Input was generated by ent.
 */
export type PubmedTopicClusterWhereInput = {
  and?: InputMaybe<Array<PubmedTopicClusterWhereInput>>;
  /** cluster_id field predicates */
  clusterID?: InputMaybe<Scalars['Int']['input']>;
  clusterIDGT?: InputMaybe<Scalars['Int']['input']>;
  clusterIDGTE?: InputMaybe<Scalars['Int']['input']>;
  clusterIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  clusterIDLT?: InputMaybe<Scalars['Int']['input']>;
  clusterIDLTE?: InputMaybe<Scalars['Int']['input']>;
  clusterIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  clusterIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** cluster_label field predicates */
  clusterLabel?: InputMaybe<Scalars['String']['input']>;
  clusterLabelContains?: InputMaybe<Scalars['String']['input']>;
  clusterLabelContainsFold?: InputMaybe<Scalars['String']['input']>;
  clusterLabelEqualFold?: InputMaybe<Scalars['String']['input']>;
  clusterLabelGT?: InputMaybe<Scalars['String']['input']>;
  clusterLabelGTE?: InputMaybe<Scalars['String']['input']>;
  clusterLabelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  clusterLabelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  clusterLabelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  clusterLabelLT?: InputMaybe<Scalars['String']['input']>;
  clusterLabelLTE?: InputMaybe<Scalars['String']['input']>;
  clusterLabelNEQ?: InputMaybe<Scalars['String']['input']>;
  clusterLabelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** pubmed_articles edge predicates */
  hasPubmedArticles?: InputMaybe<Scalars['Boolean']['input']>;
  hasPubmedArticlesWith?: InputMaybe<Array<PubmedArticleWhereInput>>;
  /** topic_pubmed_topic_cluster edge predicates */
  hasTopicPubmedTopicCluster?: InputMaybe<Scalars['Boolean']['input']>;
  hasTopicPubmedTopicClusterWith?: InputMaybe<Array<TopicPubmedTopicClusterWhereInput>>;
  /** topics edge predicates */
  hasTopics?: InputMaybe<Scalars['Boolean']['input']>;
  hasTopicsWith?: InputMaybe<Array<TopicWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']['input']>;
  labelContains?: InputMaybe<Scalars['String']['input']>;
  labelContainsFold?: InputMaybe<Scalars['String']['input']>;
  labelEqualFold?: InputMaybe<Scalars['String']['input']>;
  labelGT?: InputMaybe<Scalars['String']['input']>;
  labelGTE?: InputMaybe<Scalars['String']['input']>;
  labelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  labelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  labelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  labelIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  labelLT?: InputMaybe<Scalars['String']['input']>;
  labelLTE?: InputMaybe<Scalars['String']['input']>;
  labelNEQ?: InputMaybe<Scalars['String']['input']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  labelNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<PubmedTopicClusterWhereInput>;
  or?: InputMaybe<Array<PubmedTopicClusterWhereInput>>;
};

export type Query = {
  __typename?: 'Query';
  accountConnections: AccountConnectionConnection;
  adminActiveUsers: TableData;
  adminActivityLogSummary: TableData;
  adminFinancialDisclosurePrintTemplate: FinancialDisclosurePrintTemplate;
  adminGetNotificationConfig: NotificationConfig;
  adminKeyIndicators: Array<KeyIndicator>;
  adminMostViewedPosts: TableData;
  adminMostViewedUsers: TableData;
  adminReflectionsByUser: TableData;
  adminReflectionsOverTime: TableSeries;
  adminShowDeletedFinancialDisclosures?: Maybe<Array<FinancialDisclosure>>;
  adminTopUsersByTotalPosts: TableData;
  adminTotalSearchesOverTime: TableData;
  adminTrendingTopics: TableData;
  adminUserActivitySummary: UserActivitySummary;
  adminVideoCompletions: Array<AdminVideoCompletion>;
  anatomicalModels: AnatomicalModelConnection;
  apiQueryLogs: ApiQueryLogConnection;
  articles: ArticleConnection;
  audiences: AudienceConnection;
  auditLogs: AuditLogConnection;
  blockedUsers: UserConnection;
  boardCertifications: BoardCertificationConnection;
  bookmarks: BookmarkConnection;
  certificateSurveyAnswers: CertificateSurveyAnswerConnection;
  certificateSurveyQuestionChoices: CertificateSurveyQuestionChoiceConnection;
  certificateSurveyQuestions: CertificateSurveyQuestionConnection;
  certificates: CertificateConnection;
  certifyingBoards: CertifyingBoardConnection;
  checkWaitListStatus?: Maybe<WaitlistEntry>;
  clinicalTrialConditionCounts?: Maybe<Array<ClinicalTrialConditionCount>>;
  clinicalTrialMapPoints?: Maybe<Array<ClinicalTrialMapPoint>>;
  clinicalTrialStatusCounts?: Maybe<Array<ClinicalTrialStatusCount>>;
  clinicalTrials: ClinicalTrialConnection;
  collections: CollectionConnection;
  commentLikes: CommentLikeConnection;
  /** ** Admin Only ** Returns Yes/No totals for each model prediction */
  commentNamedEntityStats?: Maybe<AdminReflectionStats>;
  comments: CommentConnection;
  courses: CourseConnection;
  /** The one hundred most common NPI credentials */
  credentials: Array<Scalars['String']['output']>;
  /** The currently authenticated user */
  currentUser: User;
  dashboards: DashboardConnection;
  educationCredits: EducationCreditConnection;
  educationHistories: EducationHistoryConnection;
  educationRequirements: EducationRequirementConnection;
  feed: PostConnection;
  feedV2: FeedConnection;
  financialDisclosurePrintTemplates: FinancialDisclosurePrintTemplateConnection;
  financialDisclosureRoles: FinancialDisclosureRoleConnection;
  financialDisclosureStatements: FinancialDisclosureStatementConnection;
  financialDisclosures: FinancialDisclosureConnection;
  friends: Array<User>;
  /** Generates a reflective prompt for a specified post */
  generateReflectionPrompts: Array<ReflectionPrompt>;
  generateReflectionPromptsFromText: Array<ReflectionPrompt>;
  getChatMessages: Array<Maybe<SparkyChatMessage>>;
  giblibVideos: GiblibVideoConnection;
  googleDriveFiles: GoogleDriveFileConnection;
  importedVideos: ImportedVideoConnection;
  jobHistories: JobHistoryConnection;
  learningObjectives: LearningObjectiveConnection;
  licenseHistories: LicenseHistoryConnection;
  likes: LikeConnection;
  mediaItems: MediaItemConnection;
  medicalDictionaryDefinition: MedicalDictionaryDefinition;
  medicalDictionarySearch: Array<MedicalDictionarySearchResult>;
  mutedUsers: UserConnection;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  notificationConfigs: NotificationConfigConnection;
  notifications: NotificationConnection;
  npiTaxonomies: NpiTaxonomyConnection;
  offices: OfficeConnection;
  phoneVerificationTokens: PhoneVerificationTokenConnection;
  ping: Scalars['String']['output'];
  pollForSparkyResponse: SparkyQuery;
  /** List of popular videos */
  popularVideos?: Maybe<PostConnection>;
  post?: Maybe<Post>;
  postReports: PostReportConnection;
  posts: PostConnection;
  pubmedArticles: PubmedArticleConnection;
  pubmedTopicClusters: PubmedTopicClusterConnection;
  reflectionAnalyses: ReflectionAnalysisConnection;
  reflectionAnalysisResults: ReflectionAnalysisResultConnection;
  reflectionAnalysisScores: ReflectionAnalysisScoreConnection;
  reflectionCriteriaGroups: ReflectionCriteriaGroupConnection;
  reflectionCriteriaSlice: ReflectionCriteriaConnection;
  relationship: UserRelationship;
  reportReasons: ReportReasonConnection;
  search: Array<SearchResult>;
  searchPosts: PostSearchConnection;
  searchPubmed: PubmedSearchConnection;
  /** Search the NPI registry for a provider by name or number */
  searchRegistry?: Maybe<Array<RegistryResult>>;
  searchSuggestions: SearchSuggestionResult;
  /** Returns a list of posts, users, and topics that match the query. */
  searchSuggestionsV2: SearchSuggestionResultV2;
  searchTopics: TopicSearchConnection;
  searchUsers: UserSearchConnection;
  /** Returns a list of posts or users that match the query. Each SearchResult also includes an ID you can use to create a SearchConversion. */
  searchV2: SearchResults;
  searches: SearchConnection;
  shortcode: Article;
  sparkyAnswers: SparkyQueryConnection;
  sparkyChatConfigs: SparkyChatConfigConnection;
  sparkyChatMessages: SparkyChatMessageConnection;
  sparkyChats: SparkyChatConnection;
  sparkyConversations: SparkyConversationConnection;
  sparkyMessages: SparkyMessageConnection;
  sparkyPrompts: SparkyPromptConnection;
  /** Suggest a unique handle for a user based on their name and credential */
  suggestHandle: Scalars['String']['output'];
  /** Returns a list of licenses and possible board certifications for the current user, or the given NPI number if present */
  suggestLicenses?: Maybe<LicenseSuggestionRoot>;
  /** List of recommended users */
  suggestedUsers: UserConnection;
  tags: TagConnection;
  topicClassifications: TopicClassificationConnection;
  topicClusters: TopicClusterConnection;
  topics: TopicConnection;
  /** List of trending topics */
  trendingTopics?: Maybe<TopicConnection>;
  uploads: UploadConnection;
  /** Returns a user by ID */
  user: User;
  /** The current users activity summary */
  userActivitySummary: UserActivitySummary;
  userAuditHistory?: Maybe<Array<UserAuditHistoryItem>>;
  userBlocks: UserBlockConnection;
  userCohorts: UserCohortConnection;
  userCollectionCompletions: UserCollectionCompletionConnection;
  userLinks: UserLinkConnection;
  userMutes: UserMuteConnection;
  userNotificationTokens: UserNotificationTokenConnection;
  userReports: UserReportConnection;
  users: UserConnection;
  /** Validate an email for uniqueness */
  validateEmail: Scalars['Boolean']['output'];
  /** Validate a handle for uniqueness */
  validateHandle: Scalars['Boolean']['output'];
  /** Validate a phone number for uniqueness */
  validatePhone: Scalars['Boolean']['output'];
  /** Validate an NPI number for uniqueness */
  validateProviderNumber: Scalars['Boolean']['output'];
  verificationRequests: VerificationRequestConnection;
  video: Video;
  videoPipelines: VideoPipelineConnection;
  videos: VideoConnection;
  waitListConfig?: Maybe<WaitListConfig>;
  waitListConfigs: WaitListConfigConnection;
  waitlistEntries: WaitlistEntryConnection;
  watchHistoryByLearningObjective: Array<WatchHistoryForLearningObjective>;
  workExperiences: WorkExperienceConnection;
};


export type QueryAccountConnectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<AccountConnectionOrder>;
  where?: InputMaybe<AccountConnectionWhereInput>;
};


export type QueryAdminActiveUsersArgs = {
  endDate?: InputMaybe<Scalars['Time']['input']>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
};


export type QueryAdminActivityLogSummaryArgs = {
  where?: InputMaybe<ApiQueryLogWhereInput>;
};


export type QueryAdminMostViewedPostsArgs = {
  endDate?: InputMaybe<Scalars['Time']['input']>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
};


export type QueryAdminMostViewedUsersArgs = {
  endDate?: InputMaybe<Scalars['Time']['input']>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
};


export type QueryAdminReflectionsByUserArgs = {
  endDate?: InputMaybe<Scalars['Time']['input']>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
};


export type QueryAdminReflectionsOverTimeArgs = {
  endDate?: InputMaybe<Scalars['Time']['input']>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
};


export type QueryAdminShowDeletedFinancialDisclosuresArgs = {
  id: Scalars['ID']['input'];
};


export type QueryAdminTopUsersByTotalPostsArgs = {
  endDate?: InputMaybe<Scalars['Time']['input']>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
};


export type QueryAdminTotalSearchesOverTimeArgs = {
  endDate?: InputMaybe<Scalars['Time']['input']>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
};


export type QueryAdminTrendingTopicsArgs = {
  endDate?: InputMaybe<Scalars['Time']['input']>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
};


export type QueryAdminUserActivitySummaryArgs = {
  id: Scalars['ID']['input'];
};


export type QueryAdminVideoCompletionsArgs = {
  userId: Scalars['ID']['input'];
  videoIds: Array<Scalars['ID']['input']>;
};


export type QueryAnatomicalModelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<AnatomicalModelWhereInput>;
};


export type QueryApiQueryLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ApiQueryLogOrder>;
  where?: InputMaybe<ApiQueryLogWhereInput>;
};


export type QueryArticlesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ArticleOrder>;
  where?: InputMaybe<ArticleWhereInput>;
};


export type QueryAudiencesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<AudienceOrder>;
  where?: InputMaybe<AudienceWhereInput>;
};


export type QueryAuditLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<AuditLogOrder>;
  where?: InputMaybe<AuditLogWhereInput>;
};


export type QueryBlockedUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryBoardCertificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BoardCertificationWhereInput>;
};


export type QueryBookmarksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<BookmarkOrder>;
  where?: InputMaybe<BookmarkWhereInput>;
};


export type QueryCertificateSurveyAnswersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CertificateSurveyAnswerWhereInput>;
};


export type QueryCertificateSurveyQuestionChoicesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CertificateSurveyQuestionChoiceWhereInput>;
};


export type QueryCertificateSurveyQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CertificateSurveyQuestionWhereInput>;
};


export type QueryCertificatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CertificateWhereInput>;
};


export type QueryCertifyingBoardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CertifyingBoardWhereInput>;
};


export type QueryCheckWaitListStatusArgs = {
  phone: Scalars['String']['input'];
};


export type QueryClinicalTrialConditionCountsArgs = {
  conditionIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  hasSearch?: InputMaybe<Scalars['String']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  statusIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type QueryClinicalTrialMapPointsArgs = {
  conditionIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  search?: InputMaybe<Scalars['String']['input']>;
  statusIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type QueryClinicalTrialStatusCountsArgs = {
  conditionIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  statusIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};


export type QueryClinicalTrialsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  conditionIn?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ClinicalTrialOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  where?: InputMaybe<ClinicalTrialWhereInput>;
};


export type QueryCollectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CollectionWhereInput>;
};


export type QueryCommentLikesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<CommentLikeOrder>;
  where?: InputMaybe<CommentLikeWhereInput>;
};


export type QueryCommentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<CommentOrder>;
  where?: InputMaybe<CommentWhereInput>;
};


export type QueryCoursesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<CourseWhereInput>;
};


export type QueryDashboardsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<DashboardWhereInput>;
};


export type QueryEducationCreditsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<EducationCreditOrder>;
  where?: InputMaybe<EducationCreditWhereInput>;
};


export type QueryEducationHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EducationHistoryWhereInput>;
};


export type QueryEducationRequirementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<EducationRequirementWhereInput>;
};


export type QueryFeedArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PostOrder>;
  where?: InputMaybe<PostWhereInput>;
};


export type QueryFeedV2Args = {
  after?: InputMaybe<Scalars['String']['input']>;
  feedType?: InputMaybe<FeedType>;
  includePostTypes?: InputMaybe<Array<PostType>>;
  taxonomyCode?: InputMaybe<Scalars['String']['input']>;
};


export type QueryFinancialDisclosurePrintTemplatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<FinancialDisclosurePrintTemplateOrder>;
  where?: InputMaybe<FinancialDisclosurePrintTemplateWhereInput>;
};


export type QueryFinancialDisclosureRolesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<FinancialDisclosureRoleOrder>;
  where?: InputMaybe<FinancialDisclosureRoleWhereInput>;
};


export type QueryFinancialDisclosureStatementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<FinancialDisclosureStatementOrder>;
  where?: InputMaybe<FinancialDisclosureStatementWhereInput>;
};


export type QueryFinancialDisclosuresArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<FinancialDisclosureOrder>;
  where?: InputMaybe<FinancialDisclosureWhereInput>;
};


export type QueryGenerateReflectionPromptsArgs = {
  id: Scalars['ID']['input'];
  learningObjective?: InputMaybe<Scalars['String']['input']>;
};


export type QueryGenerateReflectionPromptsFromTextArgs = {
  discussionPoints?: InputMaybe<Scalars['String']['input']>;
  learningObjective?: InputMaybe<Scalars['String']['input']>;
};


export type QueryGetChatMessagesArgs = {
  chatID?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryGiblibVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<GiblibVideoOrder>;
  where?: InputMaybe<GiblibVideoWhereInput>;
};


export type QueryGoogleDriveFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<GoogleDriveFileOrder>;
  where?: InputMaybe<GoogleDriveFileWhereInput>;
};


export type QueryImportedVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ImportedVideoOrder>;
  where?: InputMaybe<ImportedVideoWhereInput>;
};


export type QueryJobHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<JobHistoryWhereInput>;
};


export type QueryLearningObjectivesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<LearningObjectiveWhereInput>;
};


export type QueryLicenseHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<LicenseHistoryWhereInput>;
};


export type QueryLikesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<LikeOrder>;
  where?: InputMaybe<LikeWhereInput>;
};


export type QueryMediaItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<MediaItemWhereInput>;
};


export type QueryMedicalDictionaryDefinitionArgs = {
  word: Scalars['String']['input'];
};


export type QueryMedicalDictionarySearchArgs = {
  word: Scalars['String']['input'];
};


export type QueryMutedUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QueryNotificationConfigsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<NotificationConfigOrder>;
  where?: InputMaybe<NotificationConfigWhereInput>;
};


export type QueryNotificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<NotificationOrder>;
  where?: InputMaybe<NotificationWhereInput>;
};


export type QueryNpiTaxonomiesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<NpiTaxonomyOrder>;
  where?: InputMaybe<NpiTaxonomyWhereInput>;
};


export type QueryOfficesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<OfficeWhereInput>;
};


export type QueryPhoneVerificationTokensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PhoneVerificationTokenOrder>;
  where?: InputMaybe<PhoneVerificationTokenWhereInput>;
};


export type QueryPollForSparkyResponseArgs = {
  queryId: Scalars['ID']['input'];
};


export type QueryPopularVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryPostArgs = {
  id: Scalars['ID']['input'];
};


export type QueryPostReportsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PostReportOrder>;
  where?: InputMaybe<PostReportWhereInput>;
};


export type QueryPostsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PostOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  where?: InputMaybe<PostWhereInput>;
};


export type QueryPubmedArticlesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<PubmedArticleOrder>;
  where?: InputMaybe<PubmedArticleWhereInput>;
};


export type QueryPubmedTopicClustersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<PubmedTopicClusterWhereInput>;
};


export type QueryReflectionAnalysesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ReflectionAnalysisWhereInput>;
};


export type QueryReflectionAnalysisResultsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ReflectionAnalysisResultWhereInput>;
};


export type QueryReflectionAnalysisScoresArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ReflectionAnalysisScoreWhereInput>;
};


export type QueryReflectionCriteriaGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ReflectionCriteriaGroupWhereInput>;
};


export type QueryReflectionCriteriaSliceArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ReflectionCriteriaWhereInput>;
};


export type QueryRelationshipArgs = {
  id: Scalars['ID']['input'];
};


export type QueryReportReasonsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<ReportReasonWhereInput>;
};


export type QuerySearchArgs = {
  query: Scalars['String']['input'];
};


export type QuerySearchPostsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<SearchPostFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SearchPostOrderBy>;
  query: Scalars['String']['input'];
  semantic?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QuerySearchPubmedArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  query: Scalars['String']['input'];
  semantic?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QuerySearchRegistryArgs = {
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['String']['input']>;
  state?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySearchSuggestionsArgs = {
  query: Scalars['String']['input'];
};


export type QuerySearchSuggestionsV2Args = {
  query: Scalars['String']['input'];
  semantic?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QuerySearchTopicsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TopicOrderBy>;
  query: Scalars['String']['input'];
};


export type QuerySearchUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<SearchUserFilterInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SearchUserOrderBy>;
  query: Scalars['String']['input'];
  semantic?: InputMaybe<Scalars['Boolean']['input']>;
};


export type QuerySearchV2Args = {
  query: Scalars['String']['input'];
};


export type QuerySearchesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SearchOrder>;
  where?: InputMaybe<SearchWhereInput>;
};


export type QueryShortcodeArgs = {
  code: Scalars['String']['input'];
};


export type QuerySparkyAnswersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QuerySparkyChatConfigsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SparkyChatConfigOrder>;
  where?: InputMaybe<SparkyChatConfigWhereInput>;
};


export type QuerySparkyChatMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SparkyChatMessageOrder>;
  where?: InputMaybe<SparkyChatMessageWhereInput>;
};


export type QuerySparkyChatsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SparkyChatOrder>;
  where?: InputMaybe<SparkyChatWhereInput>;
};


export type QuerySparkyConversationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SparkyConversationOrder>;
  where?: InputMaybe<SparkyConversationWhereInput>;
};


export type QuerySparkyMessagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SparkyMessageOrder>;
  where?: InputMaybe<SparkyMessageWhereInput>;
};


export type QuerySparkyPromptsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SparkyPromptOrder>;
  where?: InputMaybe<SparkyPromptWhereInput>;
};


export type QuerySuggestHandleArgs = {
  credential: Scalars['String']['input'];
  firstName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
};


export type QuerySuggestLicensesArgs = {
  npiNumber?: InputMaybe<Scalars['String']['input']>;
};


export type QuerySuggestedUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<TagWhereInput>;
};


export type QueryTopicClassificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<TopicClassificationWhereInput>;
};


export type QueryTopicClustersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<TopicClusterWhereInput>;
};


export type QueryTopicsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<TopicOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  where?: InputMaybe<TopicWhereInput>;
};


export type QueryTrendingTopicsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


export type QueryUploadsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UploadOrder>;
  where?: InputMaybe<UploadWhereInput>;
};


export type QueryUserArgs = {
  id: Scalars['ID']['input'];
};


export type QueryUserAuditHistoryArgs = {
  action?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  id: Scalars['ID']['input'];
  startDate?: InputMaybe<Scalars['Time']['input']>;
};


export type QueryUserBlocksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserBlockOrder>;
  where?: InputMaybe<UserBlockWhereInput>;
};


export type QueryUserCohortsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserCohortWhereInput>;
};


export type QueryUserCollectionCompletionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserCollectionCompletionWhereInput>;
};


export type QueryUserLinksArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserLinkWhereInput>;
};


export type QueryUserMutesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserMuteOrder>;
  where?: InputMaybe<UserMuteWhereInput>;
};


export type QueryUserNotificationTokensArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<UserNotificationTokenWhereInput>;
};


export type QueryUserReportsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserReportOrder>;
  where?: InputMaybe<UserReportWhereInput>;
};


export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<UserOrder>;
  search?: InputMaybe<Scalars['String']['input']>;
  where?: InputMaybe<UserWhereInput>;
};


export type QueryValidateEmailArgs = {
  email: Scalars['String']['input'];
};


export type QueryValidateHandleArgs = {
  handle: Scalars['String']['input'];
};


export type QueryValidatePhoneArgs = {
  phone: Scalars['String']['input'];
};


export type QueryValidateProviderNumberArgs = {
  npi: Scalars['String']['input'];
};


export type QueryVerificationRequestsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<VerificationRequestOrder>;
  where?: InputMaybe<VerificationRequestWhereInput>;
};


export type QueryVideoArgs = {
  id: Scalars['ID']['input'];
};


export type QueryVideoPipelinesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<VideoPipelineOrder>;
  where?: InputMaybe<VideoPipelineWhereInput>;
};


export type QueryVideosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<VideoOrder>;
  where?: InputMaybe<VideoWhereInput>;
};


export type QueryWaitListConfigsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<WaitListConfigWhereInput>;
};


export type QueryWaitlistEntriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<WaitlistEntryOrder>;
  where?: InputMaybe<WaitlistEntryWhereInput>;
};


export type QueryWorkExperiencesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<WorkExperienceWhereInput>;
};

export type Reference = {
  __typename?: 'Reference';
  articleId?: Maybe<ArticleId>;
  citation?: Maybe<Scalars['String']['output']>;
};

export type ReflectionAnalysis = Node & {
  __typename?: 'ReflectionAnalysis';
  chat?: Maybe<SparkyChat>;
  comment?: Maybe<Comment>;
  completedAt?: Maybe<Scalars['Time']['output']>;
  consensus?: Maybe<ReflectionAnalysisResult>;
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  reflections?: Maybe<Array<Scalars['String']['output']>>;
  results?: Maybe<Array<ReflectionAnalysisResult>>;
  startedAt?: Maybe<Scalars['Time']['output']>;
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type ReflectionAnalysisConnection = {
  __typename?: 'ReflectionAnalysisConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReflectionAnalysisEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ReflectionAnalysisEdge = {
  __typename?: 'ReflectionAnalysisEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ReflectionAnalysis>;
};

export type ReflectionAnalysisResult = Node & {
  __typename?: 'ReflectionAnalysisResult';
  analysis?: Maybe<ReflectionAnalysis>;
  completedAt?: Maybe<Scalars['Time']['output']>;
  consensus: Scalars['Boolean']['output'];
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  model: Scalars['String']['output'];
  prompt: Scalars['String']['output'];
  response?: Maybe<Scalars['String']['output']>;
  score?: Maybe<Scalars['Int']['output']>;
  scores?: Maybe<Array<ReflectionAnalysisScore>>;
  startedAt?: Maybe<Scalars['Time']['output']>;
  summary?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type ReflectionAnalysisResultConnection = {
  __typename?: 'ReflectionAnalysisResultConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReflectionAnalysisResultEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ReflectionAnalysisResultEdge = {
  __typename?: 'ReflectionAnalysisResultEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ReflectionAnalysisResult>;
};

/**
 * ReflectionAnalysisResultWhereInput is used for filtering ReflectionAnalysisResult objects.
 * Input was generated by ent.
 */
export type ReflectionAnalysisResultWhereInput = {
  and?: InputMaybe<Array<ReflectionAnalysisResultWhereInput>>;
  /** completed_at field predicates */
  completedAt?: InputMaybe<Scalars['Time']['input']>;
  completedAtGT?: InputMaybe<Scalars['Time']['input']>;
  completedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  completedAtLT?: InputMaybe<Scalars['Time']['input']>;
  completedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  completedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** consensus field predicates */
  consensus?: InputMaybe<Scalars['Boolean']['input']>;
  consensusNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** analysis edge predicates */
  hasAnalysis?: InputMaybe<Scalars['Boolean']['input']>;
  hasAnalysisWith?: InputMaybe<Array<ReflectionAnalysisWhereInput>>;
  /** scores edge predicates */
  hasScores?: InputMaybe<Scalars['Boolean']['input']>;
  hasScoresWith?: InputMaybe<Array<ReflectionAnalysisScoreWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** model field predicates */
  model?: InputMaybe<Scalars['String']['input']>;
  modelContains?: InputMaybe<Scalars['String']['input']>;
  modelContainsFold?: InputMaybe<Scalars['String']['input']>;
  modelEqualFold?: InputMaybe<Scalars['String']['input']>;
  modelGT?: InputMaybe<Scalars['String']['input']>;
  modelGTE?: InputMaybe<Scalars['String']['input']>;
  modelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  modelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  modelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelLT?: InputMaybe<Scalars['String']['input']>;
  modelLTE?: InputMaybe<Scalars['String']['input']>;
  modelNEQ?: InputMaybe<Scalars['String']['input']>;
  modelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ReflectionAnalysisResultWhereInput>;
  or?: InputMaybe<Array<ReflectionAnalysisResultWhereInput>>;
  /** prompt field predicates */
  prompt?: InputMaybe<Scalars['String']['input']>;
  promptContains?: InputMaybe<Scalars['String']['input']>;
  promptContainsFold?: InputMaybe<Scalars['String']['input']>;
  promptEqualFold?: InputMaybe<Scalars['String']['input']>;
  promptGT?: InputMaybe<Scalars['String']['input']>;
  promptGTE?: InputMaybe<Scalars['String']['input']>;
  promptHasPrefix?: InputMaybe<Scalars['String']['input']>;
  promptHasSuffix?: InputMaybe<Scalars['String']['input']>;
  promptIn?: InputMaybe<Array<Scalars['String']['input']>>;
  promptLT?: InputMaybe<Scalars['String']['input']>;
  promptLTE?: InputMaybe<Scalars['String']['input']>;
  promptNEQ?: InputMaybe<Scalars['String']['input']>;
  promptNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** response field predicates */
  response?: InputMaybe<Scalars['String']['input']>;
  responseContains?: InputMaybe<Scalars['String']['input']>;
  responseContainsFold?: InputMaybe<Scalars['String']['input']>;
  responseEqualFold?: InputMaybe<Scalars['String']['input']>;
  responseGT?: InputMaybe<Scalars['String']['input']>;
  responseGTE?: InputMaybe<Scalars['String']['input']>;
  responseHasPrefix?: InputMaybe<Scalars['String']['input']>;
  responseHasSuffix?: InputMaybe<Scalars['String']['input']>;
  responseIn?: InputMaybe<Array<Scalars['String']['input']>>;
  responseIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  responseLT?: InputMaybe<Scalars['String']['input']>;
  responseLTE?: InputMaybe<Scalars['String']['input']>;
  responseNEQ?: InputMaybe<Scalars['String']['input']>;
  responseNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  responseNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** score field predicates */
  score?: InputMaybe<Scalars['Int']['input']>;
  scoreGT?: InputMaybe<Scalars['Int']['input']>;
  scoreGTE?: InputMaybe<Scalars['Int']['input']>;
  scoreIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  scoreIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  scoreLT?: InputMaybe<Scalars['Int']['input']>;
  scoreLTE?: InputMaybe<Scalars['Int']['input']>;
  scoreNEQ?: InputMaybe<Scalars['Int']['input']>;
  scoreNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  scoreNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** started_at field predicates */
  startedAt?: InputMaybe<Scalars['Time']['input']>;
  startedAtGT?: InputMaybe<Scalars['Time']['input']>;
  startedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  startedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  startedAtLT?: InputMaybe<Scalars['Time']['input']>;
  startedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  startedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  startedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** summary field predicates */
  summary?: InputMaybe<Scalars['String']['input']>;
  summaryContains?: InputMaybe<Scalars['String']['input']>;
  summaryContainsFold?: InputMaybe<Scalars['String']['input']>;
  summaryEqualFold?: InputMaybe<Scalars['String']['input']>;
  summaryGT?: InputMaybe<Scalars['String']['input']>;
  summaryGTE?: InputMaybe<Scalars['String']['input']>;
  summaryHasPrefix?: InputMaybe<Scalars['String']['input']>;
  summaryHasSuffix?: InputMaybe<Scalars['String']['input']>;
  summaryIn?: InputMaybe<Array<Scalars['String']['input']>>;
  summaryIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  summaryLT?: InputMaybe<Scalars['String']['input']>;
  summaryLTE?: InputMaybe<Scalars['String']['input']>;
  summaryNEQ?: InputMaybe<Scalars['String']['input']>;
  summaryNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  summaryNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type ReflectionAnalysisScore = Node & {
  __typename?: 'ReflectionAnalysisScore';
  criteria: Scalars['String']['output'];
  criteriaKey?: Maybe<Scalars['String']['output']>;
  facet?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  justification: Scalars['String']['output'];
  message?: Maybe<SparkyMessage>;
  /** The model used to generate the score */
  model?: Maybe<Scalars['String']['output']>;
  nudge: Scalars['String']['output'];
  reflectionCriteria?: Maybe<ReflectionCriteria>;
  reflectionCriteriaID?: Maybe<Scalars['ID']['output']>;
  score: Scalars['Int']['output'];
  sparkyConversation?: Maybe<SparkyConversation>;
  sparkyConversationID?: Maybe<Scalars['ID']['output']>;
  type?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of items. */
export type ReflectionAnalysisScoreConnection = {
  __typename?: 'ReflectionAnalysisScoreConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReflectionAnalysisScoreEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ReflectionAnalysisScoreEdge = {
  __typename?: 'ReflectionAnalysisScoreEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ReflectionAnalysisScore>;
};

/**
 * ReflectionAnalysisScoreWhereInput is used for filtering ReflectionAnalysisScore objects.
 * Input was generated by ent.
 */
export type ReflectionAnalysisScoreWhereInput = {
  and?: InputMaybe<Array<ReflectionAnalysisScoreWhereInput>>;
  /** criteria field predicates */
  criteria?: InputMaybe<Scalars['String']['input']>;
  criteriaContains?: InputMaybe<Scalars['String']['input']>;
  criteriaContainsFold?: InputMaybe<Scalars['String']['input']>;
  criteriaEqualFold?: InputMaybe<Scalars['String']['input']>;
  criteriaGT?: InputMaybe<Scalars['String']['input']>;
  criteriaGTE?: InputMaybe<Scalars['String']['input']>;
  criteriaHasPrefix?: InputMaybe<Scalars['String']['input']>;
  criteriaHasSuffix?: InputMaybe<Scalars['String']['input']>;
  criteriaIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** criteria_key field predicates */
  criteriaKey?: InputMaybe<Scalars['String']['input']>;
  criteriaKeyContains?: InputMaybe<Scalars['String']['input']>;
  criteriaKeyContainsFold?: InputMaybe<Scalars['String']['input']>;
  criteriaKeyEqualFold?: InputMaybe<Scalars['String']['input']>;
  criteriaKeyGT?: InputMaybe<Scalars['String']['input']>;
  criteriaKeyGTE?: InputMaybe<Scalars['String']['input']>;
  criteriaKeyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  criteriaKeyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  criteriaKeyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  criteriaKeyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  criteriaKeyLT?: InputMaybe<Scalars['String']['input']>;
  criteriaKeyLTE?: InputMaybe<Scalars['String']['input']>;
  criteriaKeyNEQ?: InputMaybe<Scalars['String']['input']>;
  criteriaKeyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  criteriaKeyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  criteriaLT?: InputMaybe<Scalars['String']['input']>;
  criteriaLTE?: InputMaybe<Scalars['String']['input']>;
  criteriaNEQ?: InputMaybe<Scalars['String']['input']>;
  criteriaNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** facet field predicates */
  facet?: InputMaybe<Scalars['String']['input']>;
  facetContains?: InputMaybe<Scalars['String']['input']>;
  facetContainsFold?: InputMaybe<Scalars['String']['input']>;
  facetEqualFold?: InputMaybe<Scalars['String']['input']>;
  facetGT?: InputMaybe<Scalars['String']['input']>;
  facetGTE?: InputMaybe<Scalars['String']['input']>;
  facetHasPrefix?: InputMaybe<Scalars['String']['input']>;
  facetHasSuffix?: InputMaybe<Scalars['String']['input']>;
  facetIn?: InputMaybe<Array<Scalars['String']['input']>>;
  facetIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  facetLT?: InputMaybe<Scalars['String']['input']>;
  facetLTE?: InputMaybe<Scalars['String']['input']>;
  facetNEQ?: InputMaybe<Scalars['String']['input']>;
  facetNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  facetNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** message edge predicates */
  hasMessage?: InputMaybe<Scalars['Boolean']['input']>;
  hasMessageWith?: InputMaybe<Array<SparkyMessageWhereInput>>;
  /** reflection_criteria edge predicates */
  hasReflectionCriteria?: InputMaybe<Scalars['Boolean']['input']>;
  hasReflectionCriteriaWith?: InputMaybe<Array<ReflectionCriteriaWhereInput>>;
  /** sparky_conversation edge predicates */
  hasSparkyConversation?: InputMaybe<Scalars['Boolean']['input']>;
  hasSparkyConversationWith?: InputMaybe<Array<SparkyConversationWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** justification field predicates */
  justification?: InputMaybe<Scalars['String']['input']>;
  justificationContains?: InputMaybe<Scalars['String']['input']>;
  justificationContainsFold?: InputMaybe<Scalars['String']['input']>;
  justificationEqualFold?: InputMaybe<Scalars['String']['input']>;
  justificationGT?: InputMaybe<Scalars['String']['input']>;
  justificationGTE?: InputMaybe<Scalars['String']['input']>;
  justificationHasPrefix?: InputMaybe<Scalars['String']['input']>;
  justificationHasSuffix?: InputMaybe<Scalars['String']['input']>;
  justificationIn?: InputMaybe<Array<Scalars['String']['input']>>;
  justificationLT?: InputMaybe<Scalars['String']['input']>;
  justificationLTE?: InputMaybe<Scalars['String']['input']>;
  justificationNEQ?: InputMaybe<Scalars['String']['input']>;
  justificationNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** model field predicates */
  model?: InputMaybe<Scalars['String']['input']>;
  modelContains?: InputMaybe<Scalars['String']['input']>;
  modelContainsFold?: InputMaybe<Scalars['String']['input']>;
  modelEqualFold?: InputMaybe<Scalars['String']['input']>;
  modelGT?: InputMaybe<Scalars['String']['input']>;
  modelGTE?: InputMaybe<Scalars['String']['input']>;
  modelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  modelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  modelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  modelLT?: InputMaybe<Scalars['String']['input']>;
  modelLTE?: InputMaybe<Scalars['String']['input']>;
  modelNEQ?: InputMaybe<Scalars['String']['input']>;
  modelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<ReflectionAnalysisScoreWhereInput>;
  /** nudge field predicates */
  nudge?: InputMaybe<Scalars['String']['input']>;
  nudgeContains?: InputMaybe<Scalars['String']['input']>;
  nudgeContainsFold?: InputMaybe<Scalars['String']['input']>;
  nudgeEqualFold?: InputMaybe<Scalars['String']['input']>;
  nudgeGT?: InputMaybe<Scalars['String']['input']>;
  nudgeGTE?: InputMaybe<Scalars['String']['input']>;
  nudgeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nudgeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nudgeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nudgeLT?: InputMaybe<Scalars['String']['input']>;
  nudgeLTE?: InputMaybe<Scalars['String']['input']>;
  nudgeNEQ?: InputMaybe<Scalars['String']['input']>;
  nudgeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  or?: InputMaybe<Array<ReflectionAnalysisScoreWhereInput>>;
  /** reflection_criteria_id field predicates */
  reflectionCriteriaID?: InputMaybe<Scalars['ID']['input']>;
  reflectionCriteriaIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  reflectionCriteriaIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  reflectionCriteriaIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  reflectionCriteriaIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  reflectionCriteriaIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** score field predicates */
  score?: InputMaybe<Scalars['Int']['input']>;
  scoreGT?: InputMaybe<Scalars['Int']['input']>;
  scoreGTE?: InputMaybe<Scalars['Int']['input']>;
  scoreIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  scoreLT?: InputMaybe<Scalars['Int']['input']>;
  scoreLTE?: InputMaybe<Scalars['Int']['input']>;
  scoreNEQ?: InputMaybe<Scalars['Int']['input']>;
  scoreNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** sparky_conversation_id field predicates */
  sparkyConversationID?: InputMaybe<Scalars['ID']['input']>;
  sparkyConversationIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  sparkyConversationIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  sparkyConversationIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  sparkyConversationIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  sparkyConversationIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** type field predicates */
  type?: InputMaybe<Scalars['String']['input']>;
  typeContains?: InputMaybe<Scalars['String']['input']>;
  typeContainsFold?: InputMaybe<Scalars['String']['input']>;
  typeEqualFold?: InputMaybe<Scalars['String']['input']>;
  typeGT?: InputMaybe<Scalars['String']['input']>;
  typeGTE?: InputMaybe<Scalars['String']['input']>;
  typeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  typeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  typeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  typeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  typeLT?: InputMaybe<Scalars['String']['input']>;
  typeLTE?: InputMaybe<Scalars['String']['input']>;
  typeNEQ?: InputMaybe<Scalars['String']['input']>;
  typeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  typeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * ReflectionAnalysisWhereInput is used for filtering ReflectionAnalysis objects.
 * Input was generated by ent.
 */
export type ReflectionAnalysisWhereInput = {
  and?: InputMaybe<Array<ReflectionAnalysisWhereInput>>;
  /** completed_at field predicates */
  completedAt?: InputMaybe<Scalars['Time']['input']>;
  completedAtGT?: InputMaybe<Scalars['Time']['input']>;
  completedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  completedAtLT?: InputMaybe<Scalars['Time']['input']>;
  completedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  completedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** chat edge predicates */
  hasChat?: InputMaybe<Scalars['Boolean']['input']>;
  hasChatWith?: InputMaybe<Array<SparkyChatWhereInput>>;
  /** comment edge predicates */
  hasComment?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommentWith?: InputMaybe<Array<CommentWhereInput>>;
  /** consensus edge predicates */
  hasConsensus?: InputMaybe<Scalars['Boolean']['input']>;
  hasConsensusWith?: InputMaybe<Array<ReflectionAnalysisResultWhereInput>>;
  /** results edge predicates */
  hasResults?: InputMaybe<Scalars['Boolean']['input']>;
  hasResultsWith?: InputMaybe<Array<ReflectionAnalysisResultWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<ReflectionAnalysisWhereInput>;
  or?: InputMaybe<Array<ReflectionAnalysisWhereInput>>;
  /** started_at field predicates */
  startedAt?: InputMaybe<Scalars['Time']['input']>;
  startedAtGT?: InputMaybe<Scalars['Time']['input']>;
  startedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  startedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  startedAtLT?: InputMaybe<Scalars['Time']['input']>;
  startedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  startedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  startedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type ReflectionCriteria = Node & {
  __typename?: 'ReflectionCriteria';
  /** The footer from the group edge, if it exists */
  cachedFooter?: Maybe<Scalars['String']['output']>;
  /** The header from the group edge, if it exists */
  cachedHeader?: Maybe<Scalars['String']['output']>;
  children?: Maybe<Array<ReflectionCriteria>>;
  criteria: Scalars['String']['output'];
  criteriaAbbreviation?: Maybe<Scalars['String']['output']>;
  experiment?: Maybe<ReflectionExperiment>;
  /** The facet of the criteria. Ie AACME, Oog, Developing Reflective Practice */
  facet?: Maybe<Scalars['String']['output']>;
  group?: Maybe<ReflectionCriteriaGroup>;
  id: Scalars['ID']['output'];
  /** The models for the criteria should run on. Leave empty to run on all models. */
  models?: Maybe<Array<Scalars['String']['output']>>;
  /** The children topics of the topic. */
  parent?: Maybe<ReflectionCriteria>;
  prompt?: Maybe<Scalars['String']['output']>;
  /** The rubric for the criteria */
  rubric: Array<Scalars['String']['output']>;
  scores?: Maybe<Array<ReflectionAnalysisScore>>;
};

/** A connection to a list of items. */
export type ReflectionCriteriaConnection = {
  __typename?: 'ReflectionCriteriaConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReflectionCriteriaEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ReflectionCriteriaEdge = {
  __typename?: 'ReflectionCriteriaEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ReflectionCriteria>;
};

export type ReflectionCriteriaGroup = Node & {
  __typename?: 'ReflectionCriteriaGroup';
  criterias?: Maybe<Array<ReflectionCriteria>>;
  expression?: Maybe<Scalars['String']['output']>;
  facetKey?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  promptFooter?: Maybe<Scalars['String']['output']>;
  promptHeader?: Maybe<Scalars['String']['output']>;
  responseFormat?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of items. */
export type ReflectionCriteriaGroupConnection = {
  __typename?: 'ReflectionCriteriaGroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReflectionCriteriaGroupEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ReflectionCriteriaGroupEdge = {
  __typename?: 'ReflectionCriteriaGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ReflectionCriteriaGroup>;
};

/**
 * ReflectionCriteriaGroupWhereInput is used for filtering ReflectionCriteriaGroup objects.
 * Input was generated by ent.
 */
export type ReflectionCriteriaGroupWhereInput = {
  and?: InputMaybe<Array<ReflectionCriteriaGroupWhereInput>>;
  /** expression field predicates */
  expression?: InputMaybe<Scalars['String']['input']>;
  expressionContains?: InputMaybe<Scalars['String']['input']>;
  expressionContainsFold?: InputMaybe<Scalars['String']['input']>;
  expressionEqualFold?: InputMaybe<Scalars['String']['input']>;
  expressionGT?: InputMaybe<Scalars['String']['input']>;
  expressionGTE?: InputMaybe<Scalars['String']['input']>;
  expressionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  expressionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  expressionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  expressionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  expressionLT?: InputMaybe<Scalars['String']['input']>;
  expressionLTE?: InputMaybe<Scalars['String']['input']>;
  expressionNEQ?: InputMaybe<Scalars['String']['input']>;
  expressionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  expressionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** facet_key field predicates */
  facetKey?: InputMaybe<Scalars['String']['input']>;
  facetKeyContains?: InputMaybe<Scalars['String']['input']>;
  facetKeyContainsFold?: InputMaybe<Scalars['String']['input']>;
  facetKeyEqualFold?: InputMaybe<Scalars['String']['input']>;
  facetKeyGT?: InputMaybe<Scalars['String']['input']>;
  facetKeyGTE?: InputMaybe<Scalars['String']['input']>;
  facetKeyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  facetKeyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  facetKeyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  facetKeyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  facetKeyLT?: InputMaybe<Scalars['String']['input']>;
  facetKeyLTE?: InputMaybe<Scalars['String']['input']>;
  facetKeyNEQ?: InputMaybe<Scalars['String']['input']>;
  facetKeyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  facetKeyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** criterias edge predicates */
  hasCriterias?: InputMaybe<Scalars['Boolean']['input']>;
  hasCriteriasWith?: InputMaybe<Array<ReflectionCriteriaWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ReflectionCriteriaGroupWhereInput>;
  or?: InputMaybe<Array<ReflectionCriteriaGroupWhereInput>>;
  /** prompt_footer field predicates */
  promptFooter?: InputMaybe<Scalars['String']['input']>;
  promptFooterContains?: InputMaybe<Scalars['String']['input']>;
  promptFooterContainsFold?: InputMaybe<Scalars['String']['input']>;
  promptFooterEqualFold?: InputMaybe<Scalars['String']['input']>;
  promptFooterGT?: InputMaybe<Scalars['String']['input']>;
  promptFooterGTE?: InputMaybe<Scalars['String']['input']>;
  promptFooterHasPrefix?: InputMaybe<Scalars['String']['input']>;
  promptFooterHasSuffix?: InputMaybe<Scalars['String']['input']>;
  promptFooterIn?: InputMaybe<Array<Scalars['String']['input']>>;
  promptFooterIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  promptFooterLT?: InputMaybe<Scalars['String']['input']>;
  promptFooterLTE?: InputMaybe<Scalars['String']['input']>;
  promptFooterNEQ?: InputMaybe<Scalars['String']['input']>;
  promptFooterNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  promptFooterNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** prompt_header field predicates */
  promptHeader?: InputMaybe<Scalars['String']['input']>;
  promptHeaderContains?: InputMaybe<Scalars['String']['input']>;
  promptHeaderContainsFold?: InputMaybe<Scalars['String']['input']>;
  promptHeaderEqualFold?: InputMaybe<Scalars['String']['input']>;
  promptHeaderGT?: InputMaybe<Scalars['String']['input']>;
  promptHeaderGTE?: InputMaybe<Scalars['String']['input']>;
  promptHeaderHasPrefix?: InputMaybe<Scalars['String']['input']>;
  promptHeaderHasSuffix?: InputMaybe<Scalars['String']['input']>;
  promptHeaderIn?: InputMaybe<Array<Scalars['String']['input']>>;
  promptHeaderIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  promptHeaderLT?: InputMaybe<Scalars['String']['input']>;
  promptHeaderLTE?: InputMaybe<Scalars['String']['input']>;
  promptHeaderNEQ?: InputMaybe<Scalars['String']['input']>;
  promptHeaderNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  promptHeaderNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** response_format field predicates */
  responseFormat?: InputMaybe<Scalars['String']['input']>;
  responseFormatContains?: InputMaybe<Scalars['String']['input']>;
  responseFormatContainsFold?: InputMaybe<Scalars['String']['input']>;
  responseFormatEqualFold?: InputMaybe<Scalars['String']['input']>;
  responseFormatGT?: InputMaybe<Scalars['String']['input']>;
  responseFormatGTE?: InputMaybe<Scalars['String']['input']>;
  responseFormatHasPrefix?: InputMaybe<Scalars['String']['input']>;
  responseFormatHasSuffix?: InputMaybe<Scalars['String']['input']>;
  responseFormatIn?: InputMaybe<Array<Scalars['String']['input']>>;
  responseFormatIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  responseFormatLT?: InputMaybe<Scalars['String']['input']>;
  responseFormatLTE?: InputMaybe<Scalars['String']['input']>;
  responseFormatNEQ?: InputMaybe<Scalars['String']['input']>;
  responseFormatNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  responseFormatNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * ReflectionCriteriaWhereInput is used for filtering ReflectionCriteria objects.
 * Input was generated by ent.
 */
export type ReflectionCriteriaWhereInput = {
  and?: InputMaybe<Array<ReflectionCriteriaWhereInput>>;
  /** cached_footer field predicates */
  cachedFooter?: InputMaybe<Scalars['String']['input']>;
  cachedFooterContains?: InputMaybe<Scalars['String']['input']>;
  cachedFooterContainsFold?: InputMaybe<Scalars['String']['input']>;
  cachedFooterEqualFold?: InputMaybe<Scalars['String']['input']>;
  cachedFooterGT?: InputMaybe<Scalars['String']['input']>;
  cachedFooterGTE?: InputMaybe<Scalars['String']['input']>;
  cachedFooterHasPrefix?: InputMaybe<Scalars['String']['input']>;
  cachedFooterHasSuffix?: InputMaybe<Scalars['String']['input']>;
  cachedFooterIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cachedFooterIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  cachedFooterLT?: InputMaybe<Scalars['String']['input']>;
  cachedFooterLTE?: InputMaybe<Scalars['String']['input']>;
  cachedFooterNEQ?: InputMaybe<Scalars['String']['input']>;
  cachedFooterNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cachedFooterNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** cached_header field predicates */
  cachedHeader?: InputMaybe<Scalars['String']['input']>;
  cachedHeaderContains?: InputMaybe<Scalars['String']['input']>;
  cachedHeaderContainsFold?: InputMaybe<Scalars['String']['input']>;
  cachedHeaderEqualFold?: InputMaybe<Scalars['String']['input']>;
  cachedHeaderGT?: InputMaybe<Scalars['String']['input']>;
  cachedHeaderGTE?: InputMaybe<Scalars['String']['input']>;
  cachedHeaderHasPrefix?: InputMaybe<Scalars['String']['input']>;
  cachedHeaderHasSuffix?: InputMaybe<Scalars['String']['input']>;
  cachedHeaderIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cachedHeaderIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  cachedHeaderLT?: InputMaybe<Scalars['String']['input']>;
  cachedHeaderLTE?: InputMaybe<Scalars['String']['input']>;
  cachedHeaderNEQ?: InputMaybe<Scalars['String']['input']>;
  cachedHeaderNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cachedHeaderNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** criteria field predicates */
  criteria?: InputMaybe<Scalars['String']['input']>;
  /** criteria_abbreviation field predicates */
  criteriaAbbreviation?: InputMaybe<Scalars['String']['input']>;
  criteriaAbbreviationContains?: InputMaybe<Scalars['String']['input']>;
  criteriaAbbreviationContainsFold?: InputMaybe<Scalars['String']['input']>;
  criteriaAbbreviationEqualFold?: InputMaybe<Scalars['String']['input']>;
  criteriaAbbreviationGT?: InputMaybe<Scalars['String']['input']>;
  criteriaAbbreviationGTE?: InputMaybe<Scalars['String']['input']>;
  criteriaAbbreviationHasPrefix?: InputMaybe<Scalars['String']['input']>;
  criteriaAbbreviationHasSuffix?: InputMaybe<Scalars['String']['input']>;
  criteriaAbbreviationIn?: InputMaybe<Array<Scalars['String']['input']>>;
  criteriaAbbreviationIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  criteriaAbbreviationLT?: InputMaybe<Scalars['String']['input']>;
  criteriaAbbreviationLTE?: InputMaybe<Scalars['String']['input']>;
  criteriaAbbreviationNEQ?: InputMaybe<Scalars['String']['input']>;
  criteriaAbbreviationNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  criteriaAbbreviationNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  criteriaContains?: InputMaybe<Scalars['String']['input']>;
  criteriaContainsFold?: InputMaybe<Scalars['String']['input']>;
  criteriaEqualFold?: InputMaybe<Scalars['String']['input']>;
  criteriaGT?: InputMaybe<Scalars['String']['input']>;
  criteriaGTE?: InputMaybe<Scalars['String']['input']>;
  criteriaHasPrefix?: InputMaybe<Scalars['String']['input']>;
  criteriaHasSuffix?: InputMaybe<Scalars['String']['input']>;
  criteriaIn?: InputMaybe<Array<Scalars['String']['input']>>;
  criteriaLT?: InputMaybe<Scalars['String']['input']>;
  criteriaLTE?: InputMaybe<Scalars['String']['input']>;
  criteriaNEQ?: InputMaybe<Scalars['String']['input']>;
  criteriaNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** facet field predicates */
  facet?: InputMaybe<Scalars['String']['input']>;
  facetContains?: InputMaybe<Scalars['String']['input']>;
  facetContainsFold?: InputMaybe<Scalars['String']['input']>;
  facetEqualFold?: InputMaybe<Scalars['String']['input']>;
  facetGT?: InputMaybe<Scalars['String']['input']>;
  facetGTE?: InputMaybe<Scalars['String']['input']>;
  facetHasPrefix?: InputMaybe<Scalars['String']['input']>;
  facetHasSuffix?: InputMaybe<Scalars['String']['input']>;
  facetIn?: InputMaybe<Array<Scalars['String']['input']>>;
  facetIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  facetLT?: InputMaybe<Scalars['String']['input']>;
  facetLTE?: InputMaybe<Scalars['String']['input']>;
  facetNEQ?: InputMaybe<Scalars['String']['input']>;
  facetNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  facetNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** children edge predicates */
  hasChildren?: InputMaybe<Scalars['Boolean']['input']>;
  hasChildrenWith?: InputMaybe<Array<ReflectionCriteriaWhereInput>>;
  /** experiment edge predicates */
  hasExperiment?: InputMaybe<Scalars['Boolean']['input']>;
  hasExperimentWith?: InputMaybe<Array<ReflectionExperimentWhereInput>>;
  /** group edge predicates */
  hasGroup?: InputMaybe<Scalars['Boolean']['input']>;
  hasGroupWith?: InputMaybe<Array<ReflectionCriteriaGroupWhereInput>>;
  /** parent edge predicates */
  hasParent?: InputMaybe<Scalars['Boolean']['input']>;
  hasParentWith?: InputMaybe<Array<ReflectionCriteriaWhereInput>>;
  /** scores edge predicates */
  hasScores?: InputMaybe<Scalars['Boolean']['input']>;
  hasScoresWith?: InputMaybe<Array<ReflectionAnalysisScoreWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<ReflectionCriteriaWhereInput>;
  or?: InputMaybe<Array<ReflectionCriteriaWhereInput>>;
  /** prompt field predicates */
  prompt?: InputMaybe<Scalars['String']['input']>;
  promptContains?: InputMaybe<Scalars['String']['input']>;
  promptContainsFold?: InputMaybe<Scalars['String']['input']>;
  promptEqualFold?: InputMaybe<Scalars['String']['input']>;
  promptGT?: InputMaybe<Scalars['String']['input']>;
  promptGTE?: InputMaybe<Scalars['String']['input']>;
  promptHasPrefix?: InputMaybe<Scalars['String']['input']>;
  promptHasSuffix?: InputMaybe<Scalars['String']['input']>;
  promptIn?: InputMaybe<Array<Scalars['String']['input']>>;
  promptIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  promptLT?: InputMaybe<Scalars['String']['input']>;
  promptLTE?: InputMaybe<Scalars['String']['input']>;
  promptNEQ?: InputMaybe<Scalars['String']['input']>;
  promptNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  promptNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ReflectionExperiment = Node & {
  __typename?: 'ReflectionExperiment';
  /** Whether the experiment is currently active. */
  active: Scalars['Boolean']['output'];
  createdAt: Scalars['Time']['output'];
  criteria?: Maybe<ReflectionCriteria>;
  id: Scalars['ID']['output'];
  runs?: Maybe<Array<ReflectionExperimentRun>>;
  updatedAt: Scalars['Time']['output'];
};

/** Ordering options for ReflectionExperiment connections */
export type ReflectionExperimentOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order ReflectionExperiments. */
  field: ReflectionExperimentOrderField;
};

/** Properties by which ReflectionExperiment connections can be ordered. */
export enum ReflectionExperimentOrderField {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

export type ReflectionExperimentRun = Node & {
  __typename?: 'ReflectionExperimentRun';
  conversations?: Maybe<Array<SparkyConversation>>;
  createdAt: Scalars['Time']['output'];
  experiment?: Maybe<ReflectionExperiment>;
  id: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
};

/** Ordering options for ReflectionExperimentRun connections */
export type ReflectionExperimentRunOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order ReflectionExperimentRuns. */
  field: ReflectionExperimentRunOrderField;
};

/** Properties by which ReflectionExperimentRun connections can be ordered. */
export enum ReflectionExperimentRunOrderField {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * ReflectionExperimentRunWhereInput is used for filtering ReflectionExperimentRun objects.
 * Input was generated by ent.
 */
export type ReflectionExperimentRunWhereInput = {
  and?: InputMaybe<Array<ReflectionExperimentRunWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** conversations edge predicates */
  hasConversations?: InputMaybe<Scalars['Boolean']['input']>;
  hasConversationsWith?: InputMaybe<Array<SparkyConversationWhereInput>>;
  /** experiment edge predicates */
  hasExperiment?: InputMaybe<Scalars['Boolean']['input']>;
  hasExperimentWith?: InputMaybe<Array<ReflectionExperimentWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<ReflectionExperimentRunWhereInput>;
  or?: InputMaybe<Array<ReflectionExperimentRunWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/**
 * ReflectionExperimentWhereInput is used for filtering ReflectionExperiment objects.
 * Input was generated by ent.
 */
export type ReflectionExperimentWhereInput = {
  /** active field predicates */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  activeNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  and?: InputMaybe<Array<ReflectionExperimentWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** criteria edge predicates */
  hasCriteria?: InputMaybe<Scalars['Boolean']['input']>;
  hasCriteriaWith?: InputMaybe<Array<ReflectionCriteriaWhereInput>>;
  /** runs edge predicates */
  hasRuns?: InputMaybe<Scalars['Boolean']['input']>;
  hasRunsWith?: InputMaybe<Array<ReflectionExperimentRunWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<ReflectionExperimentWhereInput>;
  or?: InputMaybe<Array<ReflectionExperimentWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type ReflectionPrompt = {
  __typename?: 'ReflectionPrompt';
  text: Scalars['String']['output'];
};

export type ReflectionResult = {
  __typename?: 'ReflectionResult';
  allTerms?: Maybe<Array<MedicalNreResult>>;
  followUpPrompt?: Maybe<Scalars['String']['output']>;
  isInquisitive?: Maybe<Scalars['Boolean']['output']>;
  isLinguisticallyAcceptable?: Maybe<Scalars['Boolean']['output']>;
  isReflective?: Maybe<Scalars['Boolean']['output']>;
  isToxic?: Maybe<Scalars['Boolean']['output']>;
  medicalDictionaryMatches?: Maybe<Array<MedicalDictionaryMatch>>;
  medicalTermCount?: Maybe<Scalars['Int']['output']>;
  medicalTerms?: Maybe<Array<MedicalNreResult>>;
  personalProperNounCount?: Maybe<Scalars['Int']['output']>;
  qaPrediction?: Maybe<Scalars['String']['output']>;
  sentiments?: Maybe<Array<SentimentResult>>;
  shouldEarnCredits?: Maybe<Scalars['Boolean']['output']>;
  tags?: Maybe<Array<PartOfSpeechTag>>;
  termFrequencies?: Maybe<Scalars['Map']['output']>;
  totalWords?: Maybe<Scalars['Int']['output']>;
  wordcloudURL?: Maybe<Scalars['String']['output']>;
};

export type RegistryResult = {
  __typename?: 'RegistryResult';
  address?: Maybe<Scalars['String']['output']>;
  city?: Maybe<Scalars['String']['output']>;
  claimed?: Maybe<Scalars['Boolean']['output']>;
  credential?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  number: Scalars['String']['output'];
  state?: Maybe<Scalars['String']['output']>;
  taxonomyCode?: Maybe<Scalars['String']['output']>;
  taxonomyDesc?: Maybe<Scalars['String']['output']>;
  zip?: Maybe<Scalars['String']['output']>;
};

export type ReportReason = Node & {
  __typename?: 'ReportReason';
  active: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

/** A connection to a list of items. */
export type ReportReasonConnection = {
  __typename?: 'ReportReasonConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReportReasonEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ReportReasonEdge = {
  __typename?: 'ReportReasonEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<ReportReason>;
};

/**
 * ReportReasonWhereInput is used for filtering ReportReason objects.
 * Input was generated by ent.
 */
export type ReportReasonWhereInput = {
  /** active field predicates */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  activeNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  and?: InputMaybe<Array<ReportReasonWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<ReportReasonWhereInput>;
  or?: InputMaybe<Array<ReportReasonWhereInput>>;
};

export type SandboxCriteriaInput = {
  criteria?: InputMaybe<CreateReflectionCriteriaInput>;
  group?: InputMaybe<CreateReflectionCriteriaGroupInput>;
};

export type Search = Node & {
  __typename?: 'Search';
  /** The conversions that the user made from this search. */
  conversions?: Maybe<Array<SearchConversion>>;
  /** The time that the user converted the search by clicking on a result. */
  convertedAt?: Maybe<Scalars['Time']['output']>;
  /** The time that the search was made. */
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  /** The normalized query that the user entered. */
  normalizedQuery: Scalars['String']['output'];
  /** The raw query that the user entered. */
  query: Scalars['String']['output'];
  /** The number of results that the search returned. */
  resultsCount: Scalars['Int']['output'];
  /** The user that made the search. */
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type SearchConnection = {
  __typename?: 'SearchConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SearchEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

export type SearchConversion = Node & {
  __typename?: 'SearchConversion';
  /** The ID of the entity that the user converted on. */
  convertableID?: Maybe<Scalars['Int']['output']>;
  /** The type of the entity that the user converted on. */
  convertableType?: Maybe<Scalars['String']['output']>;
  /** The time that the user converted. */
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  /** The search that the user converted on. */
  search?: Maybe<Search>;
};

export type SearchConversionInput = {
  convertableId: Scalars['ID']['input'];
  convertableType: Scalars['String']['input'];
  searchId: Scalars['ID']['input'];
};

/**
 * SearchConversionWhereInput is used for filtering SearchConversion objects.
 * Input was generated by ent.
 */
export type SearchConversionWhereInput = {
  and?: InputMaybe<Array<SearchConversionWhereInput>>;
  /** convertable_id field predicates */
  convertableID?: InputMaybe<Scalars['Int']['input']>;
  convertableIDGT?: InputMaybe<Scalars['Int']['input']>;
  convertableIDGTE?: InputMaybe<Scalars['Int']['input']>;
  convertableIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  convertableIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  convertableIDLT?: InputMaybe<Scalars['Int']['input']>;
  convertableIDLTE?: InputMaybe<Scalars['Int']['input']>;
  convertableIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  convertableIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  convertableIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** convertable_type field predicates */
  convertableType?: InputMaybe<Scalars['String']['input']>;
  convertableTypeContains?: InputMaybe<Scalars['String']['input']>;
  convertableTypeContainsFold?: InputMaybe<Scalars['String']['input']>;
  convertableTypeEqualFold?: InputMaybe<Scalars['String']['input']>;
  convertableTypeGT?: InputMaybe<Scalars['String']['input']>;
  convertableTypeGTE?: InputMaybe<Scalars['String']['input']>;
  convertableTypeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  convertableTypeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  convertableTypeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  convertableTypeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  convertableTypeLT?: InputMaybe<Scalars['String']['input']>;
  convertableTypeLTE?: InputMaybe<Scalars['String']['input']>;
  convertableTypeNEQ?: InputMaybe<Scalars['String']['input']>;
  convertableTypeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  convertableTypeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** search edge predicates */
  hasSearch?: InputMaybe<Scalars['Boolean']['input']>;
  hasSearchWith?: InputMaybe<Array<SearchWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<SearchConversionWhereInput>;
  or?: InputMaybe<Array<SearchConversionWhereInput>>;
};

/** An edge in a connection. */
export type SearchEdge = {
  __typename?: 'SearchEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Search>;
};

/** Ordering options for Search connections */
export type SearchOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Searches. */
  field: SearchOrderField;
};

/** Properties by which Search connections can be ordered. */
export enum SearchOrderField {
  CreatedAt = 'CREATED_AT'
}

export type SearchPostFilterInput = {
  /** Return only posts eligible to earn CE from. */
  hasCE?: InputMaybe<Scalars['Boolean']['input']>;
  /** Return only posts that have an image(s). */
  hasImage?: InputMaybe<Scalars['Boolean']['input']>;
  /** Return only posts that have a poll. */
  hasPoll?: InputMaybe<Scalars['Boolean']['input']>;
  /** Return only posts that have a video. */
  hasVideo?: InputMaybe<Scalars['Boolean']['input']>;
  /** The people to include in the search results. Default is All. */
  people?: InputMaybe<SearchPostFilterPeople>;
  /** Return only posts that are in these topics. */
  topicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum SearchPostFilterPeople {
  All = 'All',
  Following = 'Following'
}

export enum SearchPostOrderBy {
  Latest = 'Latest',
  Popular = 'Popular'
}

export type SearchResult = PostSearchResult | TopicSearchResult | UserSearchResult;

export type SearchResultImage = {
  __typename?: 'SearchResultImage';
  id: Scalars['ID']['output'];
  url: Scalars['String']['output'];
};

export type SearchResultVideo = {
  __typename?: 'SearchResultVideo';
  height: Scalars['Int']['output'];
  hlsUrl: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  thumbnailUrl: Scalars['String']['output'];
  width: Scalars['Int']['output'];
};

export type SearchResults = {
  __typename?: 'SearchResults';
  id: Scalars['ID']['output'];
  results: Array<SearchResult>;
};

export type SearchSuggestionResult = {
  __typename?: 'SearchSuggestionResult';
  topics: Array<TopicSearchResult>;
  users: Array<UserSearchResult>;
};

export type SearchSuggestionResultV2 = {
  __typename?: 'SearchSuggestionResultV2';
  posts?: Maybe<Array<Post>>;
  topics?: Maybe<Array<Topic>>;
  users?: Maybe<Array<User>>;
};

export type SearchUserFilterInput = {
  /** Return only users that have this office location. Must be a two digit state code. */
  locations?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Return only users that have at least this many years of experience. */
  minYearsOfExperience?: InputMaybe<Scalars['Int']['input']>;
  /** Return only users that have this organization in their work history. Matches the value of the Institution field in the work history. */
  organizations?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The people to include in the search results. Default is All. */
  people?: InputMaybe<SearchUserFilterPeople>;
  /** Return only users that have these NpiTaxonomy specialties. */
  specialtyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export enum SearchUserFilterPeople {
  All = 'All',
  Following = 'Following'
}

export enum SearchUserOrderBy {
  Latest = 'Latest',
  Popular = 'Popular'
}

/**
 * SearchWhereInput is used for filtering Search objects.
 * Input was generated by ent.
 */
export type SearchWhereInput = {
  and?: InputMaybe<Array<SearchWhereInput>>;
  /** converted_at field predicates */
  convertedAt?: InputMaybe<Scalars['Time']['input']>;
  convertedAtGT?: InputMaybe<Scalars['Time']['input']>;
  convertedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  convertedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  convertedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  convertedAtLT?: InputMaybe<Scalars['Time']['input']>;
  convertedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  convertedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  convertedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  convertedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** conversions edge predicates */
  hasConversions?: InputMaybe<Scalars['Boolean']['input']>;
  hasConversionsWith?: InputMaybe<Array<SearchConversionWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** normalized_query field predicates */
  normalizedQuery?: InputMaybe<Scalars['String']['input']>;
  normalizedQueryContains?: InputMaybe<Scalars['String']['input']>;
  normalizedQueryContainsFold?: InputMaybe<Scalars['String']['input']>;
  normalizedQueryEqualFold?: InputMaybe<Scalars['String']['input']>;
  normalizedQueryGT?: InputMaybe<Scalars['String']['input']>;
  normalizedQueryGTE?: InputMaybe<Scalars['String']['input']>;
  normalizedQueryHasPrefix?: InputMaybe<Scalars['String']['input']>;
  normalizedQueryHasSuffix?: InputMaybe<Scalars['String']['input']>;
  normalizedQueryIn?: InputMaybe<Array<Scalars['String']['input']>>;
  normalizedQueryLT?: InputMaybe<Scalars['String']['input']>;
  normalizedQueryLTE?: InputMaybe<Scalars['String']['input']>;
  normalizedQueryNEQ?: InputMaybe<Scalars['String']['input']>;
  normalizedQueryNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<SearchWhereInput>;
  or?: InputMaybe<Array<SearchWhereInput>>;
  /** query field predicates */
  query?: InputMaybe<Scalars['String']['input']>;
  queryContains?: InputMaybe<Scalars['String']['input']>;
  queryContainsFold?: InputMaybe<Scalars['String']['input']>;
  queryEqualFold?: InputMaybe<Scalars['String']['input']>;
  queryGT?: InputMaybe<Scalars['String']['input']>;
  queryGTE?: InputMaybe<Scalars['String']['input']>;
  queryHasPrefix?: InputMaybe<Scalars['String']['input']>;
  queryHasSuffix?: InputMaybe<Scalars['String']['input']>;
  queryIn?: InputMaybe<Array<Scalars['String']['input']>>;
  queryLT?: InputMaybe<Scalars['String']['input']>;
  queryLTE?: InputMaybe<Scalars['String']['input']>;
  queryNEQ?: InputMaybe<Scalars['String']['input']>;
  queryNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** results_count field predicates */
  resultsCount?: InputMaybe<Scalars['Int']['input']>;
  resultsCountGT?: InputMaybe<Scalars['Int']['input']>;
  resultsCountGTE?: InputMaybe<Scalars['Int']['input']>;
  resultsCountIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  resultsCountLT?: InputMaybe<Scalars['Int']['input']>;
  resultsCountLTE?: InputMaybe<Scalars['Int']['input']>;
  resultsCountNEQ?: InputMaybe<Scalars['Int']['input']>;
  resultsCountNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type Sentiment = {
  __typename?: 'Sentiment';
  label: Scalars['String']['output'];
  score: Scalars['Float']['output'];
};

export type SentimentResult = {
  __typename?: 'SentimentResult';
  label?: Maybe<Scalars['String']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

/** The CreateUserInput is used to create a new user */
export type SignupInput = {
  /** The user's credential, usually MD, DO, etc */
  credential?: InputMaybe<Scalars['String']['input']>;
  /** The user's email address. Must be unique across users */
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** The user's username/handle. Must be unique across users */
  handle: Scalars['String']['input'];
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** The user's NPI number. Must be unique across users */
  npiNumber?: InputMaybe<Scalars['String']['input']>;
  /** The user's phone number. Must be unique across users */
  phone: Scalars['String']['input'];
  phoneVerificationToken: Scalars['String']['input'];
  /** The Image ID of the user's avatar */
  profileImageID?: InputMaybe<Scalars['Int']['input']>;
  /** The user's taxonomy code in the NPI database */
  taxonomyCode?: InputMaybe<Scalars['String']['input']>;
  /** The user's taxonomy description in the NPI database */
  taxonomyDesc?: InputMaybe<Scalars['String']['input']>;
};

export type SignupWithoutNpiInput = {
  email: Scalars['String']['input'];
  firstName: Scalars['String']['input'];
  lastName: Scalars['String']['input'];
  specialty: Scalars['String']['input'];
};

export type SparkyChat = Node & {
  __typename?: 'SparkyChat';
  analysis?: Maybe<ReflectionAnalysis>;
  /** The type of chat this is. Determine how messages will be processed */
  chattype: SparkyChatChatType;
  /** Whether or not this chat is closed. Closed chats cannot process new messages. */
  closed: Scalars['Boolean']['output'];
  /** The comment this chat was started from. */
  comment?: Maybe<Comment>;
  createdAt: Scalars['Time']['output'];
  /** The ID of the entity this chat is associated with. */
  entityid?: Maybe<Scalars['Int']['output']>;
  /** The type of entity this chat is associated with. */
  entitytype?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The messages in this chat. */
  messages?: Maybe<Array<SparkyChatMessage>>;
  post?: Maybe<Post>;
  sparkyQuery?: Maybe<SparkyQuery>;
  updatedAt: Scalars['Time']['output'];
  /** The user who started this chat. */
  user: User;
};

/** SparkyChatChatType is enum for the field chatType */
export enum SparkyChatChatType {
  Ask = 'ASK',
  Reflect = 'REFLECT'
}

export type SparkyChatConfig = Node & {
  __typename?: 'SparkyChatConfig';
  copiedFrom?: Maybe<Array<SparkyChatConfig>>;
  /** The prompt this prompt was copied from */
  copies?: Maybe<SparkyChatConfig>;
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  isDefault: Scalars['Boolean']['output'];
  name?: Maybe<Scalars['String']['output']>;
  reflectionGradingExpression?: Maybe<Scalars['String']['output']>;
  reflectionNudgePrompt: Scalars['String']['output'];
  /** The rules for this prompt */
  rules?: Maybe<Array<SparkyRule>>;
  suggestReflectionPrompt: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
  /** The user who created this prompt */
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type SparkyChatConfigConnection = {
  __typename?: 'SparkyChatConfigConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SparkyChatConfigEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SparkyChatConfigEdge = {
  __typename?: 'SparkyChatConfigEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SparkyChatConfig>;
};

/** Ordering options for SparkyChatConfig connections */
export type SparkyChatConfigOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order SparkyChatConfigs. */
  field: SparkyChatConfigOrderField;
};

/** Properties by which SparkyChatConfig connections can be ordered. */
export enum SparkyChatConfigOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * SparkyChatConfigWhereInput is used for filtering SparkyChatConfig objects.
 * Input was generated by ent.
 */
export type SparkyChatConfigWhereInput = {
  and?: InputMaybe<Array<SparkyChatConfigWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** copied_from edge predicates */
  hasCopiedFrom?: InputMaybe<Scalars['Boolean']['input']>;
  hasCopiedFromWith?: InputMaybe<Array<SparkyChatConfigWhereInput>>;
  /** copies edge predicates */
  hasCopies?: InputMaybe<Scalars['Boolean']['input']>;
  hasCopiesWith?: InputMaybe<Array<SparkyChatConfigWhereInput>>;
  /** rules edge predicates */
  hasRules?: InputMaybe<Scalars['Boolean']['input']>;
  hasRulesWith?: InputMaybe<Array<SparkyRuleWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_default field predicates */
  isDefault?: InputMaybe<Scalars['Boolean']['input']>;
  isDefaultNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<SparkyChatConfigWhereInput>;
  or?: InputMaybe<Array<SparkyChatConfigWhereInput>>;
  /** reflection_grading_expression field predicates */
  reflectionGradingExpression?: InputMaybe<Scalars['String']['input']>;
  reflectionGradingExpressionContains?: InputMaybe<Scalars['String']['input']>;
  reflectionGradingExpressionContainsFold?: InputMaybe<Scalars['String']['input']>;
  reflectionGradingExpressionEqualFold?: InputMaybe<Scalars['String']['input']>;
  reflectionGradingExpressionGT?: InputMaybe<Scalars['String']['input']>;
  reflectionGradingExpressionGTE?: InputMaybe<Scalars['String']['input']>;
  reflectionGradingExpressionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  reflectionGradingExpressionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  reflectionGradingExpressionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  reflectionGradingExpressionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  reflectionGradingExpressionLT?: InputMaybe<Scalars['String']['input']>;
  reflectionGradingExpressionLTE?: InputMaybe<Scalars['String']['input']>;
  reflectionGradingExpressionNEQ?: InputMaybe<Scalars['String']['input']>;
  reflectionGradingExpressionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  reflectionGradingExpressionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** reflection_nudge_prompt field predicates */
  reflectionNudgePrompt?: InputMaybe<Scalars['String']['input']>;
  reflectionNudgePromptContains?: InputMaybe<Scalars['String']['input']>;
  reflectionNudgePromptContainsFold?: InputMaybe<Scalars['String']['input']>;
  reflectionNudgePromptEqualFold?: InputMaybe<Scalars['String']['input']>;
  reflectionNudgePromptGT?: InputMaybe<Scalars['String']['input']>;
  reflectionNudgePromptGTE?: InputMaybe<Scalars['String']['input']>;
  reflectionNudgePromptHasPrefix?: InputMaybe<Scalars['String']['input']>;
  reflectionNudgePromptHasSuffix?: InputMaybe<Scalars['String']['input']>;
  reflectionNudgePromptIn?: InputMaybe<Array<Scalars['String']['input']>>;
  reflectionNudgePromptLT?: InputMaybe<Scalars['String']['input']>;
  reflectionNudgePromptLTE?: InputMaybe<Scalars['String']['input']>;
  reflectionNudgePromptNEQ?: InputMaybe<Scalars['String']['input']>;
  reflectionNudgePromptNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** suggest_reflection_prompt field predicates */
  suggestReflectionPrompt?: InputMaybe<Scalars['String']['input']>;
  suggestReflectionPromptContains?: InputMaybe<Scalars['String']['input']>;
  suggestReflectionPromptContainsFold?: InputMaybe<Scalars['String']['input']>;
  suggestReflectionPromptEqualFold?: InputMaybe<Scalars['String']['input']>;
  suggestReflectionPromptGT?: InputMaybe<Scalars['String']['input']>;
  suggestReflectionPromptGTE?: InputMaybe<Scalars['String']['input']>;
  suggestReflectionPromptHasPrefix?: InputMaybe<Scalars['String']['input']>;
  suggestReflectionPromptHasSuffix?: InputMaybe<Scalars['String']['input']>;
  suggestReflectionPromptIn?: InputMaybe<Array<Scalars['String']['input']>>;
  suggestReflectionPromptLT?: InputMaybe<Scalars['String']['input']>;
  suggestReflectionPromptLTE?: InputMaybe<Scalars['String']['input']>;
  suggestReflectionPromptNEQ?: InputMaybe<Scalars['String']['input']>;
  suggestReflectionPromptNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/** A connection to a list of items. */
export type SparkyChatConnection = {
  __typename?: 'SparkyChatConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SparkyChatEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SparkyChatEdge = {
  __typename?: 'SparkyChatEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SparkyChat>;
};

export type SparkyChatMessage = Node & {
  __typename?: 'SparkyChatMessage';
  body: Scalars['String']['output'];
  chat?: Maybe<SparkyChat>;
  createdAt: Scalars['Time']['output'];
  handler?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  sentBySparky: Scalars['Boolean']['output'];
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type SparkyChatMessageConnection = {
  __typename?: 'SparkyChatMessageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SparkyChatMessageEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SparkyChatMessageEdge = {
  __typename?: 'SparkyChatMessageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SparkyChatMessage>;
};

export type SparkyChatMessageEnvelope = {
  __typename?: 'SparkyChatMessageEnvelope';
  chatID: Scalars['ID']['output'];
  message?: Maybe<SparkyChatMessage>;
  showWaitingIndicator?: Maybe<Scalars['Boolean']['output']>;
};

/** Ordering options for SparkyChatMessage connections */
export type SparkyChatMessageOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order SparkyChatMessages. */
  field: SparkyChatMessageOrderField;
};

/** Properties by which SparkyChatMessage connections can be ordered. */
export enum SparkyChatMessageOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * SparkyChatMessageWhereInput is used for filtering SparkyChatMessage objects.
 * Input was generated by ent.
 */
export type SparkyChatMessageWhereInput = {
  and?: InputMaybe<Array<SparkyChatMessageWhereInput>>;
  /** body field predicates */
  body?: InputMaybe<Scalars['String']['input']>;
  bodyContains?: InputMaybe<Scalars['String']['input']>;
  bodyContainsFold?: InputMaybe<Scalars['String']['input']>;
  bodyEqualFold?: InputMaybe<Scalars['String']['input']>;
  bodyGT?: InputMaybe<Scalars['String']['input']>;
  bodyGTE?: InputMaybe<Scalars['String']['input']>;
  bodyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bodyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bodyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bodyLT?: InputMaybe<Scalars['String']['input']>;
  bodyLTE?: InputMaybe<Scalars['String']['input']>;
  bodyNEQ?: InputMaybe<Scalars['String']['input']>;
  bodyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** handler field predicates */
  handler?: InputMaybe<Scalars['String']['input']>;
  handlerContains?: InputMaybe<Scalars['String']['input']>;
  handlerContainsFold?: InputMaybe<Scalars['String']['input']>;
  handlerEqualFold?: InputMaybe<Scalars['String']['input']>;
  handlerGT?: InputMaybe<Scalars['String']['input']>;
  handlerGTE?: InputMaybe<Scalars['String']['input']>;
  handlerHasPrefix?: InputMaybe<Scalars['String']['input']>;
  handlerHasSuffix?: InputMaybe<Scalars['String']['input']>;
  handlerIn?: InputMaybe<Array<Scalars['String']['input']>>;
  handlerIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  handlerLT?: InputMaybe<Scalars['String']['input']>;
  handlerLTE?: InputMaybe<Scalars['String']['input']>;
  handlerNEQ?: InputMaybe<Scalars['String']['input']>;
  handlerNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  handlerNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** chat edge predicates */
  hasChat?: InputMaybe<Scalars['Boolean']['input']>;
  hasChatWith?: InputMaybe<Array<SparkyChatWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<SparkyChatMessageWhereInput>;
  or?: InputMaybe<Array<SparkyChatMessageWhereInput>>;
  /** sent_by_sparky field predicates */
  sentBySparky?: InputMaybe<Scalars['Boolean']['input']>;
  sentBySparkyNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/** Ordering options for SparkyChat connections */
export type SparkyChatOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order SparkyChats. */
  field: SparkyChatOrderField;
};

/** Properties by which SparkyChat connections can be ordered. */
export enum SparkyChatOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * SparkyChatWhereInput is used for filtering SparkyChat objects.
 * Input was generated by ent.
 */
export type SparkyChatWhereInput = {
  and?: InputMaybe<Array<SparkyChatWhereInput>>;
  /** chatType field predicates */
  chattype?: InputMaybe<SparkyChatChatType>;
  chattypeIn?: InputMaybe<Array<SparkyChatChatType>>;
  chattypeNEQ?: InputMaybe<SparkyChatChatType>;
  chattypeNotIn?: InputMaybe<Array<SparkyChatChatType>>;
  /** closed field predicates */
  closed?: InputMaybe<Scalars['Boolean']['input']>;
  closedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** entityID field predicates */
  entityid?: InputMaybe<Scalars['Int']['input']>;
  entityidGT?: InputMaybe<Scalars['Int']['input']>;
  entityidGTE?: InputMaybe<Scalars['Int']['input']>;
  entityidIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  entityidIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  entityidLT?: InputMaybe<Scalars['Int']['input']>;
  entityidLTE?: InputMaybe<Scalars['Int']['input']>;
  entityidNEQ?: InputMaybe<Scalars['Int']['input']>;
  entityidNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  entityidNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** entityType field predicates */
  entitytype?: InputMaybe<Scalars['String']['input']>;
  entitytypeContains?: InputMaybe<Scalars['String']['input']>;
  entitytypeContainsFold?: InputMaybe<Scalars['String']['input']>;
  entitytypeEqualFold?: InputMaybe<Scalars['String']['input']>;
  entitytypeGT?: InputMaybe<Scalars['String']['input']>;
  entitytypeGTE?: InputMaybe<Scalars['String']['input']>;
  entitytypeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  entitytypeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  entitytypeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  entitytypeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  entitytypeLT?: InputMaybe<Scalars['String']['input']>;
  entitytypeLTE?: InputMaybe<Scalars['String']['input']>;
  entitytypeNEQ?: InputMaybe<Scalars['String']['input']>;
  entitytypeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  entitytypeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** analysis edge predicates */
  hasAnalysis?: InputMaybe<Scalars['Boolean']['input']>;
  hasAnalysisWith?: InputMaybe<Array<ReflectionAnalysisWhereInput>>;
  /** comment edge predicates */
  hasComment?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommentWith?: InputMaybe<Array<CommentWhereInput>>;
  /** messages edge predicates */
  hasMessages?: InputMaybe<Scalars['Boolean']['input']>;
  hasMessagesWith?: InputMaybe<Array<SparkyChatMessageWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<SparkyChatWhereInput>;
  or?: InputMaybe<Array<SparkyChatWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type SparkyConversation = Node & {
  __typename?: 'SparkyConversation';
  /** The clinically relevant terms extracted from the conversation. */
  clinicalTerms?: Maybe<Scalars['Map']['output']>;
  /** The word cloud image of the clinically relevant terms extracted from the conversation. */
  clinicalTermsWordcloudURL?: Maybe<Scalars['String']['output']>;
  /** The collection of posts this conversation was started from. */
  collection?: Maybe<Array<Collection>>;
  /** The comment this conversation was started from. */
  comment?: Maybe<Comment>;
  /** The configuration for this conversation. */
  config?: Maybe<SparkyChatConfig>;
  convertedFromModel?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Time']['output'];
  /** Whether this is a demo conversation. */
  demo: Scalars['Boolean']['output'];
  educationCredit?: Maybe<EducationCredit>;
  experimentRuns?: Maybe<Array<ReflectionExperimentRun>>;
  id: Scalars['ID']['output'];
  initialNudge?: Maybe<Scalars['String']['output']>;
  /** The medical dictionary terms extracted from the conversation. */
  medicalTerms?: Maybe<Scalars['Map']['output']>;
  /** The word cloud image of the medical terms extracted from the conversation. */
  medicalTermsWordcloudURL?: Maybe<Scalars['String']['output']>;
  /** The messages in this conversation. */
  messages?: Maybe<Array<SparkyMessage>>;
  model?: Maybe<Scalars['String']['output']>;
  /** The post this conversation was started from. */
  post?: Maybe<Post>;
  reflectableID?: Maybe<Scalars['Int']['output']>;
  reflectableType?: Maybe<Scalars['String']['output']>;
  /** The results of the reflection analysis, generated from all user sent messages in this conversation. */
  reflectionAnalysisResult?: Maybe<ReflectionResult>;
  scores?: Maybe<Array<ReflectionAnalysisScore>>;
  /** The entity this conversation was started from. Used to determine which entity to link to when displaying the conversation. */
  startedFrom: SparkyConversationStartedFrom;
  streamChannelCID: Scalars['String']['output'];
  streamChannelID?: Maybe<Scalars['String']['output']>;
  streamChannelType?: Maybe<Scalars['String']['output']>;
  /** The conversation this conversation is targeting for earning reflective CE. */
  targetConversation?: Maybe<SparkyConversation>;
  tenant?: Maybe<Tenant>;
  token?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Time']['output'];
  /** The user who started this conversation. */
  user: User;
  /** The video this conversation was started from */
  video?: Maybe<Video>;
};

export type SparkyConversationConfigSet = Node & {
  __typename?: 'SparkyConversationConfigSet';
  config?: Maybe<Scalars['Map']['output']>;
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  isDefault: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
  /** The user who created this config set */
  user?: Maybe<User>;
};

/**
 * SparkyConversationConfigSetWhereInput is used for filtering SparkyConversationConfigSet objects.
 * Input was generated by ent.
 */
export type SparkyConversationConfigSetWhereInput = {
  and?: InputMaybe<Array<SparkyConversationConfigSetWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_default field predicates */
  isDefault?: InputMaybe<Scalars['Boolean']['input']>;
  isDefaultNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<SparkyConversationConfigSetWhereInput>;
  or?: InputMaybe<Array<SparkyConversationConfigSetWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/** A connection to a list of items. */
export type SparkyConversationConnection = {
  __typename?: 'SparkyConversationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SparkyConversationEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SparkyConversationEdge = {
  __typename?: 'SparkyConversationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SparkyConversation>;
};

/** Ordering options for SparkyConversation connections */
export type SparkyConversationOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order SparkyConversations. */
  field: SparkyConversationOrderField;
};

/** Properties by which SparkyConversation connections can be ordered. */
export enum SparkyConversationOrderField {
  CreatedAt = 'CREATED_AT'
}

/** SparkyConversationStartedFrom is enum for the field started_from */
export enum SparkyConversationStartedFrom {
  Collection = 'collection',
  Comment = 'comment',
  Post = 'post',
  Video = 'video'
}

/**
 * SparkyConversationWhereInput is used for filtering SparkyConversation objects.
 * Input was generated by ent.
 */
export type SparkyConversationWhereInput = {
  and?: InputMaybe<Array<SparkyConversationWhereInput>>;
  /** clinical_terms_wordcloud_url field predicates */
  clinicalTermsWordcloudURL?: InputMaybe<Scalars['String']['input']>;
  clinicalTermsWordcloudURLContains?: InputMaybe<Scalars['String']['input']>;
  clinicalTermsWordcloudURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  clinicalTermsWordcloudURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  clinicalTermsWordcloudURLGT?: InputMaybe<Scalars['String']['input']>;
  clinicalTermsWordcloudURLGTE?: InputMaybe<Scalars['String']['input']>;
  clinicalTermsWordcloudURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  clinicalTermsWordcloudURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  clinicalTermsWordcloudURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  clinicalTermsWordcloudURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  clinicalTermsWordcloudURLLT?: InputMaybe<Scalars['String']['input']>;
  clinicalTermsWordcloudURLLTE?: InputMaybe<Scalars['String']['input']>;
  clinicalTermsWordcloudURLNEQ?: InputMaybe<Scalars['String']['input']>;
  clinicalTermsWordcloudURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  clinicalTermsWordcloudURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** converted_from_model field predicates */
  convertedFromModel?: InputMaybe<Scalars['String']['input']>;
  convertedFromModelContains?: InputMaybe<Scalars['String']['input']>;
  convertedFromModelContainsFold?: InputMaybe<Scalars['String']['input']>;
  convertedFromModelEqualFold?: InputMaybe<Scalars['String']['input']>;
  convertedFromModelGT?: InputMaybe<Scalars['String']['input']>;
  convertedFromModelGTE?: InputMaybe<Scalars['String']['input']>;
  convertedFromModelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  convertedFromModelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  convertedFromModelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  convertedFromModelIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  convertedFromModelLT?: InputMaybe<Scalars['String']['input']>;
  convertedFromModelLTE?: InputMaybe<Scalars['String']['input']>;
  convertedFromModelNEQ?: InputMaybe<Scalars['String']['input']>;
  convertedFromModelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  convertedFromModelNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** demo field predicates */
  demo?: InputMaybe<Scalars['Boolean']['input']>;
  demoNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** collection edge predicates */
  hasCollection?: InputMaybe<Scalars['Boolean']['input']>;
  hasCollectionWith?: InputMaybe<Array<CollectionWhereInput>>;
  /** comment edge predicates */
  hasComment?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommentWith?: InputMaybe<Array<CommentWhereInput>>;
  /** config edge predicates */
  hasConfig?: InputMaybe<Scalars['Boolean']['input']>;
  hasConfigWith?: InputMaybe<Array<SparkyChatConfigWhereInput>>;
  /** education_credit edge predicates */
  hasEducationCredit?: InputMaybe<Scalars['Boolean']['input']>;
  hasEducationCreditWith?: InputMaybe<Array<EducationCreditWhereInput>>;
  /** experiment_runs edge predicates */
  hasExperimentRuns?: InputMaybe<Scalars['Boolean']['input']>;
  hasExperimentRunsWith?: InputMaybe<Array<ReflectionExperimentRunWhereInput>>;
  /** messages edge predicates */
  hasMessages?: InputMaybe<Scalars['Boolean']['input']>;
  hasMessagesWith?: InputMaybe<Array<SparkyMessageWhereInput>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** scores edge predicates */
  hasScores?: InputMaybe<Scalars['Boolean']['input']>;
  hasScoresWith?: InputMaybe<Array<ReflectionAnalysisScoreWhereInput>>;
  /** target_conversation edge predicates */
  hasTargetConversation?: InputMaybe<Scalars['Boolean']['input']>;
  hasTargetConversationWith?: InputMaybe<Array<SparkyConversationWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']['input']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** video edge predicates */
  hasVideo?: InputMaybe<Scalars['Boolean']['input']>;
  hasVideoWith?: InputMaybe<Array<VideoWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** initial_nudge field predicates */
  initialNudge?: InputMaybe<Scalars['String']['input']>;
  initialNudgeContains?: InputMaybe<Scalars['String']['input']>;
  initialNudgeContainsFold?: InputMaybe<Scalars['String']['input']>;
  initialNudgeEqualFold?: InputMaybe<Scalars['String']['input']>;
  initialNudgeGT?: InputMaybe<Scalars['String']['input']>;
  initialNudgeGTE?: InputMaybe<Scalars['String']['input']>;
  initialNudgeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  initialNudgeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  initialNudgeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  initialNudgeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  initialNudgeLT?: InputMaybe<Scalars['String']['input']>;
  initialNudgeLTE?: InputMaybe<Scalars['String']['input']>;
  initialNudgeNEQ?: InputMaybe<Scalars['String']['input']>;
  initialNudgeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  initialNudgeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** medical_terms_wordcloud_url field predicates */
  medicalTermsWordcloudURL?: InputMaybe<Scalars['String']['input']>;
  medicalTermsWordcloudURLContains?: InputMaybe<Scalars['String']['input']>;
  medicalTermsWordcloudURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  medicalTermsWordcloudURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  medicalTermsWordcloudURLGT?: InputMaybe<Scalars['String']['input']>;
  medicalTermsWordcloudURLGTE?: InputMaybe<Scalars['String']['input']>;
  medicalTermsWordcloudURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  medicalTermsWordcloudURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  medicalTermsWordcloudURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  medicalTermsWordcloudURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  medicalTermsWordcloudURLLT?: InputMaybe<Scalars['String']['input']>;
  medicalTermsWordcloudURLLTE?: InputMaybe<Scalars['String']['input']>;
  medicalTermsWordcloudURLNEQ?: InputMaybe<Scalars['String']['input']>;
  medicalTermsWordcloudURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  medicalTermsWordcloudURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** model field predicates */
  model?: InputMaybe<Scalars['String']['input']>;
  modelContains?: InputMaybe<Scalars['String']['input']>;
  modelContainsFold?: InputMaybe<Scalars['String']['input']>;
  modelEqualFold?: InputMaybe<Scalars['String']['input']>;
  modelGT?: InputMaybe<Scalars['String']['input']>;
  modelGTE?: InputMaybe<Scalars['String']['input']>;
  modelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  modelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  modelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  modelLT?: InputMaybe<Scalars['String']['input']>;
  modelLTE?: InputMaybe<Scalars['String']['input']>;
  modelNEQ?: InputMaybe<Scalars['String']['input']>;
  modelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<SparkyConversationWhereInput>;
  or?: InputMaybe<Array<SparkyConversationWhereInput>>;
  /** reflectable_id field predicates */
  reflectableID?: InputMaybe<Scalars['Int']['input']>;
  reflectableIDGT?: InputMaybe<Scalars['Int']['input']>;
  reflectableIDGTE?: InputMaybe<Scalars['Int']['input']>;
  reflectableIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  reflectableIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  reflectableIDLT?: InputMaybe<Scalars['Int']['input']>;
  reflectableIDLTE?: InputMaybe<Scalars['Int']['input']>;
  reflectableIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  reflectableIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  reflectableIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** reflectable_type field predicates */
  reflectableType?: InputMaybe<Scalars['String']['input']>;
  reflectableTypeContains?: InputMaybe<Scalars['String']['input']>;
  reflectableTypeContainsFold?: InputMaybe<Scalars['String']['input']>;
  reflectableTypeEqualFold?: InputMaybe<Scalars['String']['input']>;
  reflectableTypeGT?: InputMaybe<Scalars['String']['input']>;
  reflectableTypeGTE?: InputMaybe<Scalars['String']['input']>;
  reflectableTypeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  reflectableTypeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  reflectableTypeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  reflectableTypeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  reflectableTypeLT?: InputMaybe<Scalars['String']['input']>;
  reflectableTypeLTE?: InputMaybe<Scalars['String']['input']>;
  reflectableTypeNEQ?: InputMaybe<Scalars['String']['input']>;
  reflectableTypeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  reflectableTypeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** started_from field predicates */
  startedFrom?: InputMaybe<SparkyConversationStartedFrom>;
  startedFromIn?: InputMaybe<Array<SparkyConversationStartedFrom>>;
  startedFromNEQ?: InputMaybe<SparkyConversationStartedFrom>;
  startedFromNotIn?: InputMaybe<Array<SparkyConversationStartedFrom>>;
  /** stream_channel_id field predicates */
  streamChannelID?: InputMaybe<Scalars['String']['input']>;
  streamChannelIDContains?: InputMaybe<Scalars['String']['input']>;
  streamChannelIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  streamChannelIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  streamChannelIDGT?: InputMaybe<Scalars['String']['input']>;
  streamChannelIDGTE?: InputMaybe<Scalars['String']['input']>;
  streamChannelIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  streamChannelIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  streamChannelIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  streamChannelIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  streamChannelIDLT?: InputMaybe<Scalars['String']['input']>;
  streamChannelIDLTE?: InputMaybe<Scalars['String']['input']>;
  streamChannelIDNEQ?: InputMaybe<Scalars['String']['input']>;
  streamChannelIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  streamChannelIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** stream_channel_type field predicates */
  streamChannelType?: InputMaybe<Scalars['String']['input']>;
  streamChannelTypeContains?: InputMaybe<Scalars['String']['input']>;
  streamChannelTypeContainsFold?: InputMaybe<Scalars['String']['input']>;
  streamChannelTypeEqualFold?: InputMaybe<Scalars['String']['input']>;
  streamChannelTypeGT?: InputMaybe<Scalars['String']['input']>;
  streamChannelTypeGTE?: InputMaybe<Scalars['String']['input']>;
  streamChannelTypeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  streamChannelTypeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  streamChannelTypeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  streamChannelTypeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  streamChannelTypeLT?: InputMaybe<Scalars['String']['input']>;
  streamChannelTypeLTE?: InputMaybe<Scalars['String']['input']>;
  streamChannelTypeNEQ?: InputMaybe<Scalars['String']['input']>;
  streamChannelTypeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  streamChannelTypeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** token field predicates */
  token?: InputMaybe<Scalars['String']['input']>;
  tokenContains?: InputMaybe<Scalars['String']['input']>;
  tokenContainsFold?: InputMaybe<Scalars['String']['input']>;
  tokenEqualFold?: InputMaybe<Scalars['String']['input']>;
  tokenGT?: InputMaybe<Scalars['String']['input']>;
  tokenGTE?: InputMaybe<Scalars['String']['input']>;
  tokenHasPrefix?: InputMaybe<Scalars['String']['input']>;
  tokenHasSuffix?: InputMaybe<Scalars['String']['input']>;
  tokenIn?: InputMaybe<Array<Scalars['String']['input']>>;
  tokenIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  tokenLT?: InputMaybe<Scalars['String']['input']>;
  tokenLTE?: InputMaybe<Scalars['String']['input']>;
  tokenNEQ?: InputMaybe<Scalars['String']['input']>;
  tokenNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  tokenNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type SparkyIcebreakerSandboxInput = {
  /** The text being reflected on. This could be from a video transcript, a text post or the result of a medical search */
  context?: InputMaybe<Scalars['String']['input']>;
  initialNudge?: InputMaybe<Scalars['String']['input']>;
};

export type SparkyInsights = {
  __typename?: 'SparkyInsights';
  discussionPoints?: Maybe<Array<Scalars['String']['output']>>;
  learningObjectives?: Maybe<Array<Scalars['String']['output']>>;
};

export type SparkyMessage = Node & {
  __typename?: 'SparkyMessage';
  addendum: Array<SparkyMessageAddendum>;
  body: Scalars['String']['output'];
  conversation?: Maybe<SparkyConversation>;
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  invalidMessage: Scalars['Boolean']['output'];
  isHelpful: Scalars['Boolean']['output'];
  isNudge: Scalars['Boolean']['output'];
  notHelpful: Scalars['Boolean']['output'];
  opengraphReferences?: Maybe<Array<OpenGraphReference>>;
  /** The value of the prompt that was used to generate this message */
  promptValue?: Maybe<Scalars['String']['output']>;
  references?: Maybe<Array<OpenEvidenceReference>>;
  /** The results of the reflection analysis */
  reflectionAnalysisResultsV1?: Maybe<ReflectionResult>;
  scores?: Maybe<Array<ReflectionAnalysisScore>>;
  sentBySparky: Scalars['Boolean']['output'];
  shouldEarnCredits: Scalars['Boolean']['output'];
  streamMessageID?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Time']['output'];
};

export type SparkyMessageAddendum = {
  __typename?: 'SparkyMessageAddendum';
  text: Scalars['String']['output'];
  type: Scalars['String']['output'];
};

/** A connection to a list of items. */
export type SparkyMessageConnection = {
  __typename?: 'SparkyMessageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SparkyMessageEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SparkyMessageEdge = {
  __typename?: 'SparkyMessageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SparkyMessage>;
};

/** Ordering options for SparkyMessage connections */
export type SparkyMessageOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order SparkyMessages. */
  field: SparkyMessageOrderField;
};

/** Properties by which SparkyMessage connections can be ordered. */
export enum SparkyMessageOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * SparkyMessageWhereInput is used for filtering SparkyMessage objects.
 * Input was generated by ent.
 */
export type SparkyMessageWhereInput = {
  and?: InputMaybe<Array<SparkyMessageWhereInput>>;
  /** body field predicates */
  body?: InputMaybe<Scalars['String']['input']>;
  bodyContains?: InputMaybe<Scalars['String']['input']>;
  bodyContainsFold?: InputMaybe<Scalars['String']['input']>;
  bodyEqualFold?: InputMaybe<Scalars['String']['input']>;
  bodyGT?: InputMaybe<Scalars['String']['input']>;
  bodyGTE?: InputMaybe<Scalars['String']['input']>;
  bodyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bodyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bodyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bodyLT?: InputMaybe<Scalars['String']['input']>;
  bodyLTE?: InputMaybe<Scalars['String']['input']>;
  bodyNEQ?: InputMaybe<Scalars['String']['input']>;
  bodyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** conversation edge predicates */
  hasConversation?: InputMaybe<Scalars['Boolean']['input']>;
  hasConversationWith?: InputMaybe<Array<SparkyConversationWhereInput>>;
  /** scores edge predicates */
  hasScores?: InputMaybe<Scalars['Boolean']['input']>;
  hasScoresWith?: InputMaybe<Array<ReflectionAnalysisScoreWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** invalid_message field predicates */
  invalidMessage?: InputMaybe<Scalars['Boolean']['input']>;
  invalidMessageNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** is_helpful field predicates */
  isHelpful?: InputMaybe<Scalars['Boolean']['input']>;
  isHelpfulNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** is_nudge field predicates */
  isNudge?: InputMaybe<Scalars['Boolean']['input']>;
  isNudgeNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<SparkyMessageWhereInput>;
  /** not_helpful field predicates */
  notHelpful?: InputMaybe<Scalars['Boolean']['input']>;
  notHelpfulNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  or?: InputMaybe<Array<SparkyMessageWhereInput>>;
  /** prompt_value field predicates */
  promptValue?: InputMaybe<Scalars['String']['input']>;
  promptValueContains?: InputMaybe<Scalars['String']['input']>;
  promptValueContainsFold?: InputMaybe<Scalars['String']['input']>;
  promptValueEqualFold?: InputMaybe<Scalars['String']['input']>;
  promptValueGT?: InputMaybe<Scalars['String']['input']>;
  promptValueGTE?: InputMaybe<Scalars['String']['input']>;
  promptValueHasPrefix?: InputMaybe<Scalars['String']['input']>;
  promptValueHasSuffix?: InputMaybe<Scalars['String']['input']>;
  promptValueIn?: InputMaybe<Array<Scalars['String']['input']>>;
  promptValueIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  promptValueLT?: InputMaybe<Scalars['String']['input']>;
  promptValueLTE?: InputMaybe<Scalars['String']['input']>;
  promptValueNEQ?: InputMaybe<Scalars['String']['input']>;
  promptValueNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  promptValueNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** sent_by_sparky field predicates */
  sentBySparky?: InputMaybe<Scalars['Boolean']['input']>;
  sentBySparkyNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** should_earn_credits field predicates */
  shouldEarnCredits?: InputMaybe<Scalars['Boolean']['input']>;
  shouldEarnCreditsNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** stream_message_id field predicates */
  streamMessageID?: InputMaybe<Scalars['String']['input']>;
  streamMessageIDContains?: InputMaybe<Scalars['String']['input']>;
  streamMessageIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  streamMessageIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  streamMessageIDGT?: InputMaybe<Scalars['String']['input']>;
  streamMessageIDGTE?: InputMaybe<Scalars['String']['input']>;
  streamMessageIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  streamMessageIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  streamMessageIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  streamMessageIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  streamMessageIDLT?: InputMaybe<Scalars['String']['input']>;
  streamMessageIDLTE?: InputMaybe<Scalars['String']['input']>;
  streamMessageIDNEQ?: InputMaybe<Scalars['String']['input']>;
  streamMessageIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  streamMessageIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type SparkyPrompt = Node & {
  __typename?: 'SparkyPrompt';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  isDefault: Scalars['Boolean']['output'];
  key: Scalars['String']['output'];
  label: Scalars['String']['output'];
  prompt: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
  /** The user who created this prompt */
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type SparkyPromptConnection = {
  __typename?: 'SparkyPromptConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SparkyPromptEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SparkyPromptEdge = {
  __typename?: 'SparkyPromptEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SparkyPrompt>;
};

/** Ordering options for SparkyPrompt connections */
export type SparkyPromptOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order SparkyPrompts. */
  field: SparkyPromptOrderField;
};

/** Properties by which SparkyPrompt connections can be ordered. */
export enum SparkyPromptOrderField {
  CreatedAt = 'CREATED_AT',
  Key = 'KEY',
  Label = 'LABEL'
}

/**
 * SparkyPromptWhereInput is used for filtering SparkyPrompt objects.
 * Input was generated by ent.
 */
export type SparkyPromptWhereInput = {
  and?: InputMaybe<Array<SparkyPromptWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_default field predicates */
  isDefault?: InputMaybe<Scalars['Boolean']['input']>;
  isDefaultNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** key field predicates */
  key?: InputMaybe<Scalars['String']['input']>;
  keyContains?: InputMaybe<Scalars['String']['input']>;
  keyContainsFold?: InputMaybe<Scalars['String']['input']>;
  keyEqualFold?: InputMaybe<Scalars['String']['input']>;
  keyGT?: InputMaybe<Scalars['String']['input']>;
  keyGTE?: InputMaybe<Scalars['String']['input']>;
  keyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  keyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  keyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  keyLT?: InputMaybe<Scalars['String']['input']>;
  keyLTE?: InputMaybe<Scalars['String']['input']>;
  keyNEQ?: InputMaybe<Scalars['String']['input']>;
  keyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']['input']>;
  labelContains?: InputMaybe<Scalars['String']['input']>;
  labelContainsFold?: InputMaybe<Scalars['String']['input']>;
  labelEqualFold?: InputMaybe<Scalars['String']['input']>;
  labelGT?: InputMaybe<Scalars['String']['input']>;
  labelGTE?: InputMaybe<Scalars['String']['input']>;
  labelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  labelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  labelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  labelLT?: InputMaybe<Scalars['String']['input']>;
  labelLTE?: InputMaybe<Scalars['String']['input']>;
  labelNEQ?: InputMaybe<Scalars['String']['input']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<SparkyPromptWhereInput>;
  or?: InputMaybe<Array<SparkyPromptWhereInput>>;
  /** prompt field predicates */
  prompt?: InputMaybe<Scalars['String']['input']>;
  promptContains?: InputMaybe<Scalars['String']['input']>;
  promptContainsFold?: InputMaybe<Scalars['String']['input']>;
  promptEqualFold?: InputMaybe<Scalars['String']['input']>;
  promptGT?: InputMaybe<Scalars['String']['input']>;
  promptGTE?: InputMaybe<Scalars['String']['input']>;
  promptHasPrefix?: InputMaybe<Scalars['String']['input']>;
  promptHasSuffix?: InputMaybe<Scalars['String']['input']>;
  promptIn?: InputMaybe<Array<Scalars['String']['input']>>;
  promptLT?: InputMaybe<Scalars['String']['input']>;
  promptLTE?: InputMaybe<Scalars['String']['input']>;
  promptNEQ?: InputMaybe<Scalars['String']['input']>;
  promptNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type SparkyQuery = Node & {
  __typename?: 'SparkyQuery';
  candidateIds: Array<Scalars['String']['output']>;
  completedAt?: Maybe<Scalars['Time']['output']>;
  createdAt: Scalars['Time']['output'];
  draftResponse?: Maybe<Scalars['String']['output']>;
  finalResponse?: Maybe<Scalars['String']['output']>;
  hydePrompt?: Maybe<Scalars['String']['output']>;
  hydeResponse?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  prompt?: Maybe<Scalars['String']['output']>;
  query: Scalars['String']['output'];
  rankedCandidateIds: Array<Scalars['String']['output']>;
  references?: Maybe<Array<PubmedArticle>>;
  sparkyChat?: Maybe<SparkyChat>;
  step: SparkyQueryStep;
  stepBackPrompt?: Maybe<Scalars['String']['output']>;
  stepBackResponse?: Maybe<Scalars['String']['output']>;
  tokens?: Maybe<Scalars['Int']['output']>;
  updatedAt: Scalars['Time']['output'];
  /** The user who created this prompt */
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type SparkyQueryConnection = {
  __typename?: 'SparkyQueryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SparkyQueryEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SparkyQueryEdge = {
  __typename?: 'SparkyQueryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<SparkyQuery>;
};

/** Ordering options for SparkyQuery connections */
export type SparkyQueryOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order SparkyQueries. */
  field: SparkyQueryOrderField;
};

/** Properties by which SparkyQuery connections can be ordered. */
export enum SparkyQueryOrderField {
  CreatedAt = 'CREATED_AT'
}

/** SparkyQueryStep is enum for the field step */
export enum SparkyQueryStep {
  CandidateSelection = 'candidate_selection',
  Completed = 'completed',
  Error = 'error',
  Query = 'query',
  QueryTransformation = 'query_transformation',
  Ranking = 'ranking',
  Summarizing = 'summarizing'
}

/**
 * SparkyQueryWhereInput is used for filtering SparkyQuery objects.
 * Input was generated by ent.
 */
export type SparkyQueryWhereInput = {
  and?: InputMaybe<Array<SparkyQueryWhereInput>>;
  /** completed_at field predicates */
  completedAt?: InputMaybe<Scalars['Time']['input']>;
  completedAtGT?: InputMaybe<Scalars['Time']['input']>;
  completedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  completedAtLT?: InputMaybe<Scalars['Time']['input']>;
  completedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  completedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** draft_response field predicates */
  draftResponse?: InputMaybe<Scalars['String']['input']>;
  draftResponseContains?: InputMaybe<Scalars['String']['input']>;
  draftResponseContainsFold?: InputMaybe<Scalars['String']['input']>;
  draftResponseEqualFold?: InputMaybe<Scalars['String']['input']>;
  draftResponseGT?: InputMaybe<Scalars['String']['input']>;
  draftResponseGTE?: InputMaybe<Scalars['String']['input']>;
  draftResponseHasPrefix?: InputMaybe<Scalars['String']['input']>;
  draftResponseHasSuffix?: InputMaybe<Scalars['String']['input']>;
  draftResponseIn?: InputMaybe<Array<Scalars['String']['input']>>;
  draftResponseIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  draftResponseLT?: InputMaybe<Scalars['String']['input']>;
  draftResponseLTE?: InputMaybe<Scalars['String']['input']>;
  draftResponseNEQ?: InputMaybe<Scalars['String']['input']>;
  draftResponseNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  draftResponseNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** final_response field predicates */
  finalResponse?: InputMaybe<Scalars['String']['input']>;
  finalResponseContains?: InputMaybe<Scalars['String']['input']>;
  finalResponseContainsFold?: InputMaybe<Scalars['String']['input']>;
  finalResponseEqualFold?: InputMaybe<Scalars['String']['input']>;
  finalResponseGT?: InputMaybe<Scalars['String']['input']>;
  finalResponseGTE?: InputMaybe<Scalars['String']['input']>;
  finalResponseHasPrefix?: InputMaybe<Scalars['String']['input']>;
  finalResponseHasSuffix?: InputMaybe<Scalars['String']['input']>;
  finalResponseIn?: InputMaybe<Array<Scalars['String']['input']>>;
  finalResponseIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  finalResponseLT?: InputMaybe<Scalars['String']['input']>;
  finalResponseLTE?: InputMaybe<Scalars['String']['input']>;
  finalResponseNEQ?: InputMaybe<Scalars['String']['input']>;
  finalResponseNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  finalResponseNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** references edge predicates */
  hasReferences?: InputMaybe<Scalars['Boolean']['input']>;
  hasReferencesWith?: InputMaybe<Array<PubmedArticleWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** hyde_prompt field predicates */
  hydePrompt?: InputMaybe<Scalars['String']['input']>;
  hydePromptContains?: InputMaybe<Scalars['String']['input']>;
  hydePromptContainsFold?: InputMaybe<Scalars['String']['input']>;
  hydePromptEqualFold?: InputMaybe<Scalars['String']['input']>;
  hydePromptGT?: InputMaybe<Scalars['String']['input']>;
  hydePromptGTE?: InputMaybe<Scalars['String']['input']>;
  hydePromptHasPrefix?: InputMaybe<Scalars['String']['input']>;
  hydePromptHasSuffix?: InputMaybe<Scalars['String']['input']>;
  hydePromptIn?: InputMaybe<Array<Scalars['String']['input']>>;
  hydePromptIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  hydePromptLT?: InputMaybe<Scalars['String']['input']>;
  hydePromptLTE?: InputMaybe<Scalars['String']['input']>;
  hydePromptNEQ?: InputMaybe<Scalars['String']['input']>;
  hydePromptNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  hydePromptNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** hyde_response field predicates */
  hydeResponse?: InputMaybe<Scalars['String']['input']>;
  hydeResponseContains?: InputMaybe<Scalars['String']['input']>;
  hydeResponseContainsFold?: InputMaybe<Scalars['String']['input']>;
  hydeResponseEqualFold?: InputMaybe<Scalars['String']['input']>;
  hydeResponseGT?: InputMaybe<Scalars['String']['input']>;
  hydeResponseGTE?: InputMaybe<Scalars['String']['input']>;
  hydeResponseHasPrefix?: InputMaybe<Scalars['String']['input']>;
  hydeResponseHasSuffix?: InputMaybe<Scalars['String']['input']>;
  hydeResponseIn?: InputMaybe<Array<Scalars['String']['input']>>;
  hydeResponseIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  hydeResponseLT?: InputMaybe<Scalars['String']['input']>;
  hydeResponseLTE?: InputMaybe<Scalars['String']['input']>;
  hydeResponseNEQ?: InputMaybe<Scalars['String']['input']>;
  hydeResponseNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  hydeResponseNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<SparkyQueryWhereInput>;
  or?: InputMaybe<Array<SparkyQueryWhereInput>>;
  /** prompt field predicates */
  prompt?: InputMaybe<Scalars['String']['input']>;
  promptContains?: InputMaybe<Scalars['String']['input']>;
  promptContainsFold?: InputMaybe<Scalars['String']['input']>;
  promptEqualFold?: InputMaybe<Scalars['String']['input']>;
  promptGT?: InputMaybe<Scalars['String']['input']>;
  promptGTE?: InputMaybe<Scalars['String']['input']>;
  promptHasPrefix?: InputMaybe<Scalars['String']['input']>;
  promptHasSuffix?: InputMaybe<Scalars['String']['input']>;
  promptIn?: InputMaybe<Array<Scalars['String']['input']>>;
  promptIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  promptLT?: InputMaybe<Scalars['String']['input']>;
  promptLTE?: InputMaybe<Scalars['String']['input']>;
  promptNEQ?: InputMaybe<Scalars['String']['input']>;
  promptNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  promptNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** query field predicates */
  query?: InputMaybe<Scalars['String']['input']>;
  queryContains?: InputMaybe<Scalars['String']['input']>;
  queryContainsFold?: InputMaybe<Scalars['String']['input']>;
  queryEqualFold?: InputMaybe<Scalars['String']['input']>;
  queryGT?: InputMaybe<Scalars['String']['input']>;
  queryGTE?: InputMaybe<Scalars['String']['input']>;
  queryHasPrefix?: InputMaybe<Scalars['String']['input']>;
  queryHasSuffix?: InputMaybe<Scalars['String']['input']>;
  queryIn?: InputMaybe<Array<Scalars['String']['input']>>;
  queryLT?: InputMaybe<Scalars['String']['input']>;
  queryLTE?: InputMaybe<Scalars['String']['input']>;
  queryNEQ?: InputMaybe<Scalars['String']['input']>;
  queryNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** step field predicates */
  step?: InputMaybe<SparkyQueryStep>;
  /** step_back_prompt field predicates */
  stepBackPrompt?: InputMaybe<Scalars['String']['input']>;
  stepBackPromptContains?: InputMaybe<Scalars['String']['input']>;
  stepBackPromptContainsFold?: InputMaybe<Scalars['String']['input']>;
  stepBackPromptEqualFold?: InputMaybe<Scalars['String']['input']>;
  stepBackPromptGT?: InputMaybe<Scalars['String']['input']>;
  stepBackPromptGTE?: InputMaybe<Scalars['String']['input']>;
  stepBackPromptHasPrefix?: InputMaybe<Scalars['String']['input']>;
  stepBackPromptHasSuffix?: InputMaybe<Scalars['String']['input']>;
  stepBackPromptIn?: InputMaybe<Array<Scalars['String']['input']>>;
  stepBackPromptIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  stepBackPromptLT?: InputMaybe<Scalars['String']['input']>;
  stepBackPromptLTE?: InputMaybe<Scalars['String']['input']>;
  stepBackPromptNEQ?: InputMaybe<Scalars['String']['input']>;
  stepBackPromptNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  stepBackPromptNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** step_back_response field predicates */
  stepBackResponse?: InputMaybe<Scalars['String']['input']>;
  stepBackResponseContains?: InputMaybe<Scalars['String']['input']>;
  stepBackResponseContainsFold?: InputMaybe<Scalars['String']['input']>;
  stepBackResponseEqualFold?: InputMaybe<Scalars['String']['input']>;
  stepBackResponseGT?: InputMaybe<Scalars['String']['input']>;
  stepBackResponseGTE?: InputMaybe<Scalars['String']['input']>;
  stepBackResponseHasPrefix?: InputMaybe<Scalars['String']['input']>;
  stepBackResponseHasSuffix?: InputMaybe<Scalars['String']['input']>;
  stepBackResponseIn?: InputMaybe<Array<Scalars['String']['input']>>;
  stepBackResponseIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  stepBackResponseLT?: InputMaybe<Scalars['String']['input']>;
  stepBackResponseLTE?: InputMaybe<Scalars['String']['input']>;
  stepBackResponseNEQ?: InputMaybe<Scalars['String']['input']>;
  stepBackResponseNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  stepBackResponseNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  stepIn?: InputMaybe<Array<SparkyQueryStep>>;
  stepNEQ?: InputMaybe<SparkyQueryStep>;
  stepNotIn?: InputMaybe<Array<SparkyQueryStep>>;
  /** tokens field predicates */
  tokens?: InputMaybe<Scalars['Int']['input']>;
  tokensGT?: InputMaybe<Scalars['Int']['input']>;
  tokensGTE?: InputMaybe<Scalars['Int']['input']>;
  tokensIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  tokensIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  tokensLT?: InputMaybe<Scalars['Int']['input']>;
  tokensLTE?: InputMaybe<Scalars['Int']['input']>;
  tokensNEQ?: InputMaybe<Scalars['Int']['input']>;
  tokensNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  tokensNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type SparkyRule = Node & {
  __typename?: 'SparkyRule';
  /** The conditions for this rule */
  conditions?: Maybe<Array<SparkyRuleCondition>>;
  /** The config this rule belongs to */
  config?: Maybe<SparkyChatConfig>;
  id: Scalars['ID']['output'];
  name?: Maybe<Scalars['String']['output']>;
};

export type SparkyRuleCondition = Node & {
  __typename?: 'SparkyRuleCondition';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  operator: SparkyRuleConditionOperator;
  /** The rule this condition belongs to */
  rule?: Maybe<SparkyRule>;
  type: SparkyRuleConditionType;
  value: Scalars['String']['output'];
};

export type SparkyRuleConditionInput = {
  id?: InputMaybe<Scalars['ID']['input']>;
  name: Scalars['String']['input'];
  operator: Scalars['String']['input'];
  type: Scalars['String']['input'];
  value: Scalars['String']['input'];
};

/** SparkyRuleConditionOperator is enum for the field operator */
export enum SparkyRuleConditionOperator {
  Eq = 'eq',
  Gt = 'gt',
  Lt = 'lt',
  Ne = 'ne'
}

/** SparkyRuleConditionType is enum for the field type */
export enum SparkyRuleConditionType {
  Bool = 'bool',
  Number = 'number'
}

/**
 * SparkyRuleConditionWhereInput is used for filtering SparkyRuleCondition objects.
 * Input was generated by ent.
 */
export type SparkyRuleConditionWhereInput = {
  and?: InputMaybe<Array<SparkyRuleConditionWhereInput>>;
  /** rule edge predicates */
  hasRule?: InputMaybe<Scalars['Boolean']['input']>;
  hasRuleWith?: InputMaybe<Array<SparkyRuleWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<SparkyRuleConditionWhereInput>;
  /** operator field predicates */
  operator?: InputMaybe<SparkyRuleConditionOperator>;
  operatorIn?: InputMaybe<Array<SparkyRuleConditionOperator>>;
  operatorNEQ?: InputMaybe<SparkyRuleConditionOperator>;
  operatorNotIn?: InputMaybe<Array<SparkyRuleConditionOperator>>;
  or?: InputMaybe<Array<SparkyRuleConditionWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<SparkyRuleConditionType>;
  typeIn?: InputMaybe<Array<SparkyRuleConditionType>>;
  typeNEQ?: InputMaybe<SparkyRuleConditionType>;
  typeNotIn?: InputMaybe<Array<SparkyRuleConditionType>>;
  /** value field predicates */
  value?: InputMaybe<Scalars['String']['input']>;
  valueContains?: InputMaybe<Scalars['String']['input']>;
  valueContainsFold?: InputMaybe<Scalars['String']['input']>;
  valueEqualFold?: InputMaybe<Scalars['String']['input']>;
  valueGT?: InputMaybe<Scalars['String']['input']>;
  valueGTE?: InputMaybe<Scalars['String']['input']>;
  valueHasPrefix?: InputMaybe<Scalars['String']['input']>;
  valueHasSuffix?: InputMaybe<Scalars['String']['input']>;
  valueIn?: InputMaybe<Array<Scalars['String']['input']>>;
  valueLT?: InputMaybe<Scalars['String']['input']>;
  valueLTE?: InputMaybe<Scalars['String']['input']>;
  valueNEQ?: InputMaybe<Scalars['String']['input']>;
  valueNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type SparkyRuleField = Node & {
  __typename?: 'SparkyRuleField';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  type: SparkyRuleFieldType;
  value: Scalars['String']['output'];
};

/** SparkyRuleFieldType is enum for the field type */
export enum SparkyRuleFieldType {
  Bool = 'bool',
  Float = 'float',
  Int = 'int',
  String = 'string'
}

/**
 * SparkyRuleFieldWhereInput is used for filtering SparkyRuleField objects.
 * Input was generated by ent.
 */
export type SparkyRuleFieldWhereInput = {
  and?: InputMaybe<Array<SparkyRuleFieldWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<SparkyRuleFieldWhereInput>;
  or?: InputMaybe<Array<SparkyRuleFieldWhereInput>>;
  /** type field predicates */
  type?: InputMaybe<SparkyRuleFieldType>;
  typeIn?: InputMaybe<Array<SparkyRuleFieldType>>;
  typeNEQ?: InputMaybe<SparkyRuleFieldType>;
  typeNotIn?: InputMaybe<Array<SparkyRuleFieldType>>;
  /** value field predicates */
  value?: InputMaybe<Scalars['String']['input']>;
  valueContains?: InputMaybe<Scalars['String']['input']>;
  valueContainsFold?: InputMaybe<Scalars['String']['input']>;
  valueEqualFold?: InputMaybe<Scalars['String']['input']>;
  valueGT?: InputMaybe<Scalars['String']['input']>;
  valueGTE?: InputMaybe<Scalars['String']['input']>;
  valueHasPrefix?: InputMaybe<Scalars['String']['input']>;
  valueHasSuffix?: InputMaybe<Scalars['String']['input']>;
  valueIn?: InputMaybe<Array<Scalars['String']['input']>>;
  valueLT?: InputMaybe<Scalars['String']['input']>;
  valueLTE?: InputMaybe<Scalars['String']['input']>;
  valueNEQ?: InputMaybe<Scalars['String']['input']>;
  valueNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type SparkyRuleInput = {
  conditions: Array<SparkyRuleConditionInput>;
  id?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/**
 * SparkyRuleWhereInput is used for filtering SparkyRule objects.
 * Input was generated by ent.
 */
export type SparkyRuleWhereInput = {
  and?: InputMaybe<Array<SparkyRuleWhereInput>>;
  /** conditions edge predicates */
  hasConditions?: InputMaybe<Scalars['Boolean']['input']>;
  hasConditionsWith?: InputMaybe<Array<SparkyRuleConditionWhereInput>>;
  /** config edge predicates */
  hasConfig?: InputMaybe<Scalars['Boolean']['input']>;
  hasConfigWith?: InputMaybe<Array<SparkyChatConfigWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<SparkyRuleWhereInput>;
  or?: InputMaybe<Array<SparkyRuleWhereInput>>;
};

export type SparkySandboxInput = {
  /** The text being reflected on. This could be from a video transcript, a text post or the result of a medical search */
  context?: InputMaybe<Scalars['String']['input']>;
  criteria: Array<SandboxCriteriaInput>;
  initialNudge?: InputMaybe<Scalars['String']['input']>;
  /** The reflective message */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Previous messages in the conversation */
  messageHistory: Array<Scalars['String']['input']>;
};

export type SparkySandboxOutput = {
  __typename?: 'SparkySandboxOutput';
  grading: GradeResult;
  scores: Array<ReflectionAnalysisScore>;
};

export type SparkyTestMessage = {
  __typename?: 'SparkyTestMessage';
  name: Scalars['String']['output'];
  ruleId: Scalars['String']['output'];
  text: Scalars['String']['output'];
};

export type SparkyTestRuleResult = {
  __typename?: 'SparkyTestRuleResult';
  messages: Array<SparkyTestMessage>;
  result: ReflectionResult;
  shouldEarnCredits: Scalars['Boolean']['output'];
};

export type SpeakInsightResult = {
  __typename?: 'SpeakInsightResult';
  data?: Maybe<Scalars['Any']['output']>;
  status: Scalars['String']['output'];
};

export type SubmitVerificationRequestInput = {
  dob: Scalars['String']['input'];
  zip: Scalars['String']['input'];
};

export type Subscription = {
  __typename?: 'Subscription';
  medicalSearchResponse: MedicalSearchEvent;
};


export type SubscriptionMedicalSearchResponseArgs = {
  token: Scalars['String']['input'];
};

export type TableData = {
  __typename?: 'TableData';
  columns: Array<TableDataColumn>;
  rowData: Array<Array<Scalars['String']['output']>>;
  sortDirection?: Maybe<Scalars['String']['output']>;
  sortField?: Maybe<Scalars['String']['output']>;
};

export type TableDataColumn = {
  __typename?: 'TableDataColumn';
  dataType: Scalars['String']['output'];
  displayName: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

export type TableSeries = {
  __typename?: 'TableSeries';
  series: Array<TableSeriesItem>;
};

export type TableSeriesItem = {
  __typename?: 'TableSeriesItem';
  data: TableData;
  name: Scalars['String']['output'];
};

export type Tag = Node & {
  __typename?: 'Tag';
  /** The number of posts that have this tag. */
  count: Scalars['Int']['output'];
  id: Scalars['ID']['output'];
  /** The posts that have this tag. */
  taggedPosts?: Maybe<Array<Post>>;
  /** The text value of the tag. */
  value: Scalars['String']['output'];
};

/** A connection to a list of items. */
export type TagConnection = {
  __typename?: 'TagConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TagEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type TagEdge = {
  __typename?: 'TagEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Tag>;
};

/**
 * TagWhereInput is used for filtering Tag objects.
 * Input was generated by ent.
 */
export type TagWhereInput = {
  and?: InputMaybe<Array<TagWhereInput>>;
  /** count field predicates */
  count?: InputMaybe<Scalars['Int']['input']>;
  countGT?: InputMaybe<Scalars['Int']['input']>;
  countGTE?: InputMaybe<Scalars['Int']['input']>;
  countIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  countLT?: InputMaybe<Scalars['Int']['input']>;
  countLTE?: InputMaybe<Scalars['Int']['input']>;
  countNEQ?: InputMaybe<Scalars['Int']['input']>;
  countNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** tagged_posts edge predicates */
  hasTaggedPosts?: InputMaybe<Scalars['Boolean']['input']>;
  hasTaggedPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<TagWhereInput>;
  or?: InputMaybe<Array<TagWhereInput>>;
  /** value field predicates */
  value?: InputMaybe<Scalars['String']['input']>;
  valueContains?: InputMaybe<Scalars['String']['input']>;
  valueContainsFold?: InputMaybe<Scalars['String']['input']>;
  valueEqualFold?: InputMaybe<Scalars['String']['input']>;
  valueGT?: InputMaybe<Scalars['String']['input']>;
  valueGTE?: InputMaybe<Scalars['String']['input']>;
  valueHasPrefix?: InputMaybe<Scalars['String']['input']>;
  valueHasSuffix?: InputMaybe<Scalars['String']['input']>;
  valueIn?: InputMaybe<Array<Scalars['String']['input']>>;
  valueLT?: InputMaybe<Scalars['String']['input']>;
  valueLTE?: InputMaybe<Scalars['String']['input']>;
  valueNEQ?: InputMaybe<Scalars['String']['input']>;
  valueNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type Tenant = Node & {
  __typename?: 'Tenant';
  default: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  users?: Maybe<Array<User>>;
};

/**
 * TenantWhereInput is used for filtering Tenant objects.
 * Input was generated by ent.
 */
export type TenantWhereInput = {
  and?: InputMaybe<Array<TenantWhereInput>>;
  /** default field predicates */
  default?: InputMaybe<Scalars['Boolean']['input']>;
  defaultNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** users edge predicates */
  hasUsers?: InputMaybe<Scalars['Boolean']['input']>;
  hasUsersWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<TenantWhereInput>;
  or?: InputMaybe<Array<TenantWhereInput>>;
};

export type Topic = Node & {
  __typename?: 'Topic';
  /** The articles that are tagged with the topic. */
  articles?: Maybe<Array<Article>>;
  children?: Maybe<Array<Topic>>;
  /** The classifications of the topic. */
  classifications?: Maybe<Array<TopicClassification>>;
  clusterID?: Maybe<Scalars['Int']['output']>;
  clusterLabel?: Maybe<Scalars['String']['output']>;
  /** The cover image of the topic. */
  cover?: Maybe<MediaItem>;
  /** The cover image of the topic. */
  coverImage?: Maybe<Image>;
  generatedLabel?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  modelID?: Maybe<Scalars['String']['output']>;
  modelVersion?: Maybe<Scalars['String']['output']>;
  /** The name of the topic. */
  name: Scalars['String']['output'];
  /** The NPI taxonomies that are tagged with the topic. */
  npiTaxonomies?: Maybe<Array<NpiTaxonomy>>;
  /** The ordinal of the topic. */
  ordinal: Scalars['Int']['output'];
  /** The children topics of the topic. */
  parent?: Maybe<Topic>;
  /** The posts that are tagged with the topic. */
  posts?: Maybe<Array<Post>>;
  /** The articles that are tagged with the topic. */
  pubmedArticles?: Maybe<Array<PubmedArticle>>;
  pubmedTopicClusters?: Maybe<Array<PubmedTopicCluster>>;
  /** The tenant that the topic belongs to. */
  tenant?: Maybe<Tenant>;
  topicNpiTaxonomies?: Maybe<Array<TopicNpiTaxonomy>>;
  topicPubmedTopicCluster?: Maybe<Array<TopicPubmedTopicCluster>>;
  /** The total number of posts that are tagged with the topic. */
  totalPosts: Scalars['Int']['output'];
  /** The trending boost of the topic. */
  trendingBoost: Scalars['Float']['output'];
  /** The type of the topic. */
  type: TopicType;
  /** The users that are subscribed to the topic. */
  users?: Maybe<Array<User>>;
  wordFrequencies?: Maybe<Scalars['Map']['output']>;
  words?: Maybe<Array<Scalars['String']['output']>>;
};

export type TopicClassification = Node & {
  __typename?: 'TopicClassification';
  active: Scalars['Boolean']['output'];
  createdAt: Scalars['Time']['output'];
  entityID: Scalars['Int']['output'];
  entityType: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  modelVersion?: Maybe<Scalars['String']['output']>;
  score: Scalars['Float']['output'];
  suggested: Scalars['Boolean']['output'];
  topic: Topic;
  topicID: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type TopicClassificationConnection = {
  __typename?: 'TopicClassificationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TopicClassificationEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type TopicClassificationEdge = {
  __typename?: 'TopicClassificationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<TopicClassification>;
};

/**
 * TopicClassificationWhereInput is used for filtering TopicClassification objects.
 * Input was generated by ent.
 */
export type TopicClassificationWhereInput = {
  /** active field predicates */
  active?: InputMaybe<Scalars['Boolean']['input']>;
  activeNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  and?: InputMaybe<Array<TopicClassificationWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** entity_id field predicates */
  entityID?: InputMaybe<Scalars['Int']['input']>;
  entityIDGT?: InputMaybe<Scalars['Int']['input']>;
  entityIDGTE?: InputMaybe<Scalars['Int']['input']>;
  entityIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  entityIDLT?: InputMaybe<Scalars['Int']['input']>;
  entityIDLTE?: InputMaybe<Scalars['Int']['input']>;
  entityIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  entityIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** entity_type field predicates */
  entityType?: InputMaybe<Scalars['String']['input']>;
  entityTypeContains?: InputMaybe<Scalars['String']['input']>;
  entityTypeContainsFold?: InputMaybe<Scalars['String']['input']>;
  entityTypeEqualFold?: InputMaybe<Scalars['String']['input']>;
  entityTypeGT?: InputMaybe<Scalars['String']['input']>;
  entityTypeGTE?: InputMaybe<Scalars['String']['input']>;
  entityTypeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  entityTypeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  entityTypeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  entityTypeLT?: InputMaybe<Scalars['String']['input']>;
  entityTypeLTE?: InputMaybe<Scalars['String']['input']>;
  entityTypeNEQ?: InputMaybe<Scalars['String']['input']>;
  entityTypeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** topic edge predicates */
  hasTopic?: InputMaybe<Scalars['Boolean']['input']>;
  hasTopicWith?: InputMaybe<Array<TopicWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** model_version field predicates */
  modelVersion?: InputMaybe<Scalars['String']['input']>;
  modelVersionContains?: InputMaybe<Scalars['String']['input']>;
  modelVersionContainsFold?: InputMaybe<Scalars['String']['input']>;
  modelVersionEqualFold?: InputMaybe<Scalars['String']['input']>;
  modelVersionGT?: InputMaybe<Scalars['String']['input']>;
  modelVersionGTE?: InputMaybe<Scalars['String']['input']>;
  modelVersionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  modelVersionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  modelVersionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelVersionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  modelVersionLT?: InputMaybe<Scalars['String']['input']>;
  modelVersionLTE?: InputMaybe<Scalars['String']['input']>;
  modelVersionNEQ?: InputMaybe<Scalars['String']['input']>;
  modelVersionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelVersionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<TopicClassificationWhereInput>;
  or?: InputMaybe<Array<TopicClassificationWhereInput>>;
  /** score field predicates */
  score?: InputMaybe<Scalars['Float']['input']>;
  scoreGT?: InputMaybe<Scalars['Float']['input']>;
  scoreGTE?: InputMaybe<Scalars['Float']['input']>;
  scoreIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  scoreLT?: InputMaybe<Scalars['Float']['input']>;
  scoreLTE?: InputMaybe<Scalars['Float']['input']>;
  scoreNEQ?: InputMaybe<Scalars['Float']['input']>;
  scoreNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** suggested field predicates */
  suggested?: InputMaybe<Scalars['Boolean']['input']>;
  suggestedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** topic_id field predicates */
  topicID?: InputMaybe<Scalars['ID']['input']>;
  topicIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  topicIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  topicIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type TopicCluster = Node & {
  __typename?: 'TopicCluster';
  clusterID: Scalars['Int']['output'];
  clusterLabel: Scalars['String']['output'];
  generatedLabel?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  label?: Maybe<Scalars['String']['output']>;
  modelID: Scalars['String']['output'];
  wordFrequencies?: Maybe<Scalars['Map']['output']>;
  words: Array<Scalars['String']['output']>;
};

/** A connection to a list of items. */
export type TopicClusterConnection = {
  __typename?: 'TopicClusterConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TopicClusterEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type TopicClusterEdge = {
  __typename?: 'TopicClusterEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<TopicCluster>;
};

/**
 * TopicClusterWhereInput is used for filtering TopicCluster objects.
 * Input was generated by ent.
 */
export type TopicClusterWhereInput = {
  and?: InputMaybe<Array<TopicClusterWhereInput>>;
  /** cluster_id field predicates */
  clusterID?: InputMaybe<Scalars['Int']['input']>;
  clusterIDGT?: InputMaybe<Scalars['Int']['input']>;
  clusterIDGTE?: InputMaybe<Scalars['Int']['input']>;
  clusterIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  clusterIDLT?: InputMaybe<Scalars['Int']['input']>;
  clusterIDLTE?: InputMaybe<Scalars['Int']['input']>;
  clusterIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  clusterIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** cluster_label field predicates */
  clusterLabel?: InputMaybe<Scalars['String']['input']>;
  clusterLabelContains?: InputMaybe<Scalars['String']['input']>;
  clusterLabelContainsFold?: InputMaybe<Scalars['String']['input']>;
  clusterLabelEqualFold?: InputMaybe<Scalars['String']['input']>;
  clusterLabelGT?: InputMaybe<Scalars['String']['input']>;
  clusterLabelGTE?: InputMaybe<Scalars['String']['input']>;
  clusterLabelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  clusterLabelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  clusterLabelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  clusterLabelLT?: InputMaybe<Scalars['String']['input']>;
  clusterLabelLTE?: InputMaybe<Scalars['String']['input']>;
  clusterLabelNEQ?: InputMaybe<Scalars['String']['input']>;
  clusterLabelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** generated_label field predicates */
  generatedLabel?: InputMaybe<Scalars['String']['input']>;
  generatedLabelContains?: InputMaybe<Scalars['String']['input']>;
  generatedLabelContainsFold?: InputMaybe<Scalars['String']['input']>;
  generatedLabelEqualFold?: InputMaybe<Scalars['String']['input']>;
  generatedLabelGT?: InputMaybe<Scalars['String']['input']>;
  generatedLabelGTE?: InputMaybe<Scalars['String']['input']>;
  generatedLabelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  generatedLabelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  generatedLabelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  generatedLabelIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  generatedLabelLT?: InputMaybe<Scalars['String']['input']>;
  generatedLabelLTE?: InputMaybe<Scalars['String']['input']>;
  generatedLabelNEQ?: InputMaybe<Scalars['String']['input']>;
  generatedLabelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  generatedLabelNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']['input']>;
  labelContains?: InputMaybe<Scalars['String']['input']>;
  labelContainsFold?: InputMaybe<Scalars['String']['input']>;
  labelEqualFold?: InputMaybe<Scalars['String']['input']>;
  labelGT?: InputMaybe<Scalars['String']['input']>;
  labelGTE?: InputMaybe<Scalars['String']['input']>;
  labelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  labelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  labelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  labelIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  labelLT?: InputMaybe<Scalars['String']['input']>;
  labelLTE?: InputMaybe<Scalars['String']['input']>;
  labelNEQ?: InputMaybe<Scalars['String']['input']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  labelNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** model_id field predicates */
  modelID?: InputMaybe<Scalars['String']['input']>;
  modelIDContains?: InputMaybe<Scalars['String']['input']>;
  modelIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  modelIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  modelIDGT?: InputMaybe<Scalars['String']['input']>;
  modelIDGTE?: InputMaybe<Scalars['String']['input']>;
  modelIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  modelIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  modelIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelIDLT?: InputMaybe<Scalars['String']['input']>;
  modelIDLTE?: InputMaybe<Scalars['String']['input']>;
  modelIDNEQ?: InputMaybe<Scalars['String']['input']>;
  modelIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<TopicClusterWhereInput>;
  or?: InputMaybe<Array<TopicClusterWhereInput>>;
};

/** A connection to a list of items. */
export type TopicConnection = {
  __typename?: 'TopicConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TopicEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type TopicEdge = {
  __typename?: 'TopicEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Topic>;
};

export type TopicNpiTaxonomy = Node & {
  __typename?: 'TopicNpiTaxonomy';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  npiTaxonomy: NpiTaxonomy;
  npiTaxonomyID: Scalars['ID']['output'];
  topic: Topic;
  topicID: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
};

/**
 * TopicNpiTaxonomyWhereInput is used for filtering TopicNpiTaxonomy objects.
 * Input was generated by ent.
 */
export type TopicNpiTaxonomyWhereInput = {
  and?: InputMaybe<Array<TopicNpiTaxonomyWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<TopicNpiTaxonomyWhereInput>;
  or?: InputMaybe<Array<TopicNpiTaxonomyWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/** Ordering options for Topic connections */
export type TopicOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Topics. */
  field: TopicOrderField;
};

export enum TopicOrderBy {
  Latest = 'Latest',
  Popular = 'Popular'
}

/** Properties by which Topic connections can be ordered. */
export enum TopicOrderField {
  Name = 'NAME',
  TotalPosts = 'TOTAL_POSTS',
  TrendingBoost = 'TRENDING_BOOST'
}

export type TopicPubmedTopicCluster = Node & {
  __typename?: 'TopicPubmedTopicCluster';
  id: Scalars['ID']['output'];
  pubmedTopicCluster: PubmedTopicCluster;
  pubmedTopicClusterID: Scalars['ID']['output'];
  topic: Topic;
  topicID: Scalars['ID']['output'];
};

/**
 * TopicPubmedTopicClusterWhereInput is used for filtering TopicPubmedTopicCluster objects.
 * Input was generated by ent.
 */
export type TopicPubmedTopicClusterWhereInput = {
  and?: InputMaybe<Array<TopicPubmedTopicClusterWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<TopicPubmedTopicClusterWhereInput>;
  or?: InputMaybe<Array<TopicPubmedTopicClusterWhereInput>>;
};

export type TopicSearchConnection = {
  __typename?: 'TopicSearchConnection';
  edges?: Maybe<Array<Maybe<TopicEdge>>>;
  pageInfo: PageInfo;
  totalCount: Scalars['Int']['output'];
};

export type TopicSearchResult = {
  __typename?: 'TopicSearchResult';
  id: Scalars['ID']['output'];
  title: Scalars['String']['output'];
  totalPosts: Scalars['Int']['output'];
};

/** TopicType is enum for the field type */
export enum TopicType {
  Editorial = 'editorial',
  Misc = 'misc',
  Other = 'other',
  Specialty = 'specialty',
  TopicCluster = 'topic_cluster'
}

/**
 * TopicWhereInput is used for filtering Topic objects.
 * Input was generated by ent.
 */
export type TopicWhereInput = {
  and?: InputMaybe<Array<TopicWhereInput>>;
  /** cluster_id field predicates */
  clusterID?: InputMaybe<Scalars['Int']['input']>;
  clusterIDGT?: InputMaybe<Scalars['Int']['input']>;
  clusterIDGTE?: InputMaybe<Scalars['Int']['input']>;
  clusterIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  clusterIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  clusterIDLT?: InputMaybe<Scalars['Int']['input']>;
  clusterIDLTE?: InputMaybe<Scalars['Int']['input']>;
  clusterIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  clusterIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  clusterIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** cluster_label field predicates */
  clusterLabel?: InputMaybe<Scalars['String']['input']>;
  clusterLabelContains?: InputMaybe<Scalars['String']['input']>;
  clusterLabelContainsFold?: InputMaybe<Scalars['String']['input']>;
  clusterLabelEqualFold?: InputMaybe<Scalars['String']['input']>;
  clusterLabelGT?: InputMaybe<Scalars['String']['input']>;
  clusterLabelGTE?: InputMaybe<Scalars['String']['input']>;
  clusterLabelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  clusterLabelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  clusterLabelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  clusterLabelIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  clusterLabelLT?: InputMaybe<Scalars['String']['input']>;
  clusterLabelLTE?: InputMaybe<Scalars['String']['input']>;
  clusterLabelNEQ?: InputMaybe<Scalars['String']['input']>;
  clusterLabelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  clusterLabelNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** generated_label field predicates */
  generatedLabel?: InputMaybe<Scalars['String']['input']>;
  generatedLabelContains?: InputMaybe<Scalars['String']['input']>;
  generatedLabelContainsFold?: InputMaybe<Scalars['String']['input']>;
  generatedLabelEqualFold?: InputMaybe<Scalars['String']['input']>;
  generatedLabelGT?: InputMaybe<Scalars['String']['input']>;
  generatedLabelGTE?: InputMaybe<Scalars['String']['input']>;
  generatedLabelHasPrefix?: InputMaybe<Scalars['String']['input']>;
  generatedLabelHasSuffix?: InputMaybe<Scalars['String']['input']>;
  generatedLabelIn?: InputMaybe<Array<Scalars['String']['input']>>;
  generatedLabelIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  generatedLabelLT?: InputMaybe<Scalars['String']['input']>;
  generatedLabelLTE?: InputMaybe<Scalars['String']['input']>;
  generatedLabelNEQ?: InputMaybe<Scalars['String']['input']>;
  generatedLabelNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  generatedLabelNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** articles edge predicates */
  hasArticles?: InputMaybe<Scalars['Boolean']['input']>;
  hasArticlesWith?: InputMaybe<Array<ArticleWhereInput>>;
  /** children edge predicates */
  hasChildren?: InputMaybe<Scalars['Boolean']['input']>;
  hasChildrenWith?: InputMaybe<Array<TopicWhereInput>>;
  /** classifications edge predicates */
  hasClassifications?: InputMaybe<Scalars['Boolean']['input']>;
  hasClassificationsWith?: InputMaybe<Array<TopicClassificationWhereInput>>;
  /** cover edge predicates */
  hasCover?: InputMaybe<Scalars['Boolean']['input']>;
  /** cover_image edge predicates */
  hasCoverImage?: InputMaybe<Scalars['Boolean']['input']>;
  hasCoverImageWith?: InputMaybe<Array<ImageWhereInput>>;
  hasCoverWith?: InputMaybe<Array<MediaItemWhereInput>>;
  /** npi_taxonomies edge predicates */
  hasNpiTaxonomies?: InputMaybe<Scalars['Boolean']['input']>;
  hasNpiTaxonomiesWith?: InputMaybe<Array<NpiTaxonomyWhereInput>>;
  /** parent edge predicates */
  hasParent?: InputMaybe<Scalars['Boolean']['input']>;
  hasParentWith?: InputMaybe<Array<TopicWhereInput>>;
  /** posts edge predicates */
  hasPosts?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** pubmed_articles edge predicates */
  hasPubmedArticles?: InputMaybe<Scalars['Boolean']['input']>;
  hasPubmedArticlesWith?: InputMaybe<Array<PubmedArticleWhereInput>>;
  /** pubmed_topic_clusters edge predicates */
  hasPubmedTopicClusters?: InputMaybe<Scalars['Boolean']['input']>;
  hasPubmedTopicClustersWith?: InputMaybe<Array<PubmedTopicClusterWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']['input']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** topic_npi_taxonomies edge predicates */
  hasTopicNpiTaxonomies?: InputMaybe<Scalars['Boolean']['input']>;
  hasTopicNpiTaxonomiesWith?: InputMaybe<Array<TopicNpiTaxonomyWhereInput>>;
  /** topic_pubmed_topic_cluster edge predicates */
  hasTopicPubmedTopicCluster?: InputMaybe<Scalars['Boolean']['input']>;
  hasTopicPubmedTopicClusterWith?: InputMaybe<Array<TopicPubmedTopicClusterWhereInput>>;
  /** users edge predicates */
  hasUsers?: InputMaybe<Scalars['Boolean']['input']>;
  hasUsersWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** model_id field predicates */
  modelID?: InputMaybe<Scalars['String']['input']>;
  modelIDContains?: InputMaybe<Scalars['String']['input']>;
  modelIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  modelIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  modelIDGT?: InputMaybe<Scalars['String']['input']>;
  modelIDGTE?: InputMaybe<Scalars['String']['input']>;
  modelIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  modelIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  modelIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  modelIDLT?: InputMaybe<Scalars['String']['input']>;
  modelIDLTE?: InputMaybe<Scalars['String']['input']>;
  modelIDNEQ?: InputMaybe<Scalars['String']['input']>;
  modelIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** model_version field predicates */
  modelVersion?: InputMaybe<Scalars['String']['input']>;
  modelVersionContains?: InputMaybe<Scalars['String']['input']>;
  modelVersionContainsFold?: InputMaybe<Scalars['String']['input']>;
  modelVersionEqualFold?: InputMaybe<Scalars['String']['input']>;
  modelVersionGT?: InputMaybe<Scalars['String']['input']>;
  modelVersionGTE?: InputMaybe<Scalars['String']['input']>;
  modelVersionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  modelVersionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  modelVersionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelVersionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  modelVersionLT?: InputMaybe<Scalars['String']['input']>;
  modelVersionLTE?: InputMaybe<Scalars['String']['input']>;
  modelVersionNEQ?: InputMaybe<Scalars['String']['input']>;
  modelVersionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  modelVersionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<TopicWhereInput>;
  or?: InputMaybe<Array<TopicWhereInput>>;
  /** ordinal field predicates */
  ordinal?: InputMaybe<Scalars['Int']['input']>;
  ordinalGT?: InputMaybe<Scalars['Int']['input']>;
  ordinalGTE?: InputMaybe<Scalars['Int']['input']>;
  ordinalIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  ordinalLT?: InputMaybe<Scalars['Int']['input']>;
  ordinalLTE?: InputMaybe<Scalars['Int']['input']>;
  ordinalNEQ?: InputMaybe<Scalars['Int']['input']>;
  ordinalNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** total_posts field predicates */
  totalPosts?: InputMaybe<Scalars['Int']['input']>;
  totalPostsGT?: InputMaybe<Scalars['Int']['input']>;
  totalPostsGTE?: InputMaybe<Scalars['Int']['input']>;
  totalPostsIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalPostsLT?: InputMaybe<Scalars['Int']['input']>;
  totalPostsLTE?: InputMaybe<Scalars['Int']['input']>;
  totalPostsNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalPostsNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** trending_boost field predicates */
  trendingBoost?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostGT?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostGTE?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  trendingBoostLT?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostLTE?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostNEQ?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** type field predicates */
  type?: InputMaybe<TopicType>;
  typeIn?: InputMaybe<Array<TopicType>>;
  typeNEQ?: InputMaybe<TopicType>;
  typeNotIn?: InputMaybe<Array<TopicType>>;
};

export type TranscriptionRequest = Node & {
  __typename?: 'TranscriptionRequest';
  error?: Maybe<Scalars['String']['output']>;
  finishedAt?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  mediaID?: Maybe<Scalars['String']['output']>;
  result?: Maybe<SpeakInsightResult>;
  signedURL?: Maybe<Scalars['String']['output']>;
  status?: Maybe<TranscriptionRequestStatus>;
  storageKey?: Maybe<Scalars['String']['output']>;
  transcription?: Maybe<Scalars['String']['output']>;
  uploadedAt?: Maybe<Scalars['Time']['output']>;
};

/** TranscriptionRequestStatus is enum for the field status */
export enum TranscriptionRequestStatus {
  Failed = 'failed',
  Success = 'success',
  Uploaded = 'uploaded'
}

/**
 * TranscriptionRequestWhereInput is used for filtering TranscriptionRequest objects.
 * Input was generated by ent.
 */
export type TranscriptionRequestWhereInput = {
  and?: InputMaybe<Array<TranscriptionRequestWhereInput>>;
  /** error field predicates */
  error?: InputMaybe<Scalars['String']['input']>;
  errorContains?: InputMaybe<Scalars['String']['input']>;
  errorContainsFold?: InputMaybe<Scalars['String']['input']>;
  errorEqualFold?: InputMaybe<Scalars['String']['input']>;
  errorGT?: InputMaybe<Scalars['String']['input']>;
  errorGTE?: InputMaybe<Scalars['String']['input']>;
  errorHasPrefix?: InputMaybe<Scalars['String']['input']>;
  errorHasSuffix?: InputMaybe<Scalars['String']['input']>;
  errorIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  errorLT?: InputMaybe<Scalars['String']['input']>;
  errorLTE?: InputMaybe<Scalars['String']['input']>;
  errorNEQ?: InputMaybe<Scalars['String']['input']>;
  errorNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  errorNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** finished_at field predicates */
  finishedAt?: InputMaybe<Scalars['Time']['input']>;
  finishedAtGT?: InputMaybe<Scalars['Time']['input']>;
  finishedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  finishedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  finishedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  finishedAtLT?: InputMaybe<Scalars['Time']['input']>;
  finishedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  finishedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  finishedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  finishedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** media_id field predicates */
  mediaID?: InputMaybe<Scalars['String']['input']>;
  mediaIDContains?: InputMaybe<Scalars['String']['input']>;
  mediaIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  mediaIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  mediaIDGT?: InputMaybe<Scalars['String']['input']>;
  mediaIDGTE?: InputMaybe<Scalars['String']['input']>;
  mediaIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  mediaIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  mediaIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  mediaIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  mediaIDLT?: InputMaybe<Scalars['String']['input']>;
  mediaIDLTE?: InputMaybe<Scalars['String']['input']>;
  mediaIDNEQ?: InputMaybe<Scalars['String']['input']>;
  mediaIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  mediaIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<TranscriptionRequestWhereInput>;
  or?: InputMaybe<Array<TranscriptionRequestWhereInput>>;
  /** signed_url field predicates */
  signedURL?: InputMaybe<Scalars['String']['input']>;
  signedURLContains?: InputMaybe<Scalars['String']['input']>;
  signedURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  signedURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  signedURLGT?: InputMaybe<Scalars['String']['input']>;
  signedURLGTE?: InputMaybe<Scalars['String']['input']>;
  signedURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  signedURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  signedURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  signedURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  signedURLLT?: InputMaybe<Scalars['String']['input']>;
  signedURLLTE?: InputMaybe<Scalars['String']['input']>;
  signedURLNEQ?: InputMaybe<Scalars['String']['input']>;
  signedURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  signedURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** status field predicates */
  status?: InputMaybe<TranscriptionRequestStatus>;
  statusIn?: InputMaybe<Array<TranscriptionRequestStatus>>;
  statusIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  statusNEQ?: InputMaybe<TranscriptionRequestStatus>;
  statusNotIn?: InputMaybe<Array<TranscriptionRequestStatus>>;
  statusNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** storage_key field predicates */
  storageKey?: InputMaybe<Scalars['String']['input']>;
  storageKeyContains?: InputMaybe<Scalars['String']['input']>;
  storageKeyContainsFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyEqualFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyGT?: InputMaybe<Scalars['String']['input']>;
  storageKeyGTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  storageKeyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  storageKeyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  storageKeyLT?: InputMaybe<Scalars['String']['input']>;
  storageKeyLTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyNEQ?: InputMaybe<Scalars['String']['input']>;
  storageKeyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  storageKeyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** transcription field predicates */
  transcription?: InputMaybe<Scalars['String']['input']>;
  transcriptionContains?: InputMaybe<Scalars['String']['input']>;
  transcriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  transcriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  transcriptionGT?: InputMaybe<Scalars['String']['input']>;
  transcriptionGTE?: InputMaybe<Scalars['String']['input']>;
  transcriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  transcriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  transcriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  transcriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  transcriptionLT?: InputMaybe<Scalars['String']['input']>;
  transcriptionLTE?: InputMaybe<Scalars['String']['input']>;
  transcriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  transcriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  transcriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** uploaded_at field predicates */
  uploadedAt?: InputMaybe<Scalars['Time']['input']>;
  uploadedAtGT?: InputMaybe<Scalars['Time']['input']>;
  uploadedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  uploadedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  uploadedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  uploadedAtLT?: InputMaybe<Scalars['Time']['input']>;
  uploadedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  uploadedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  uploadedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  uploadedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

/**
 * UpdateAnatomicalModelInput is used for update AnatomicalModel object.
 * Input was generated by ent.
 */
export type UpdateAnatomicalModelInput = {
  appendKeywords?: InputMaybe<Array<Scalars['String']['input']>>;
  clearDescription?: InputMaybe<Scalars['Boolean']['input']>;
  clearKeywords?: InputMaybe<Scalars['Boolean']['input']>;
  clearRenderedImage?: InputMaybe<Scalars['Boolean']['input']>;
  clearVideo?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** A description of the model. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Keywords for the model. These are used to help users find the model. */
  keywords?: InputMaybe<Array<Scalars['String']['input']>>;
  name?: InputMaybe<Scalars['String']['input']>;
  renderedImageID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  videoID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateArticleInput is used for update Article object.
 * Input was generated by ent.
 */
export type UpdateArticleInput = {
  addTopicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  body?: InputMaybe<Scalars['String']['input']>;
  clearBody?: InputMaybe<Scalars['Boolean']['input']>;
  clearDescription?: InputMaybe<Scalars['Boolean']['input']>;
  clearFeed?: InputMaybe<Scalars['Boolean']['input']>;
  clearImageURL?: InputMaybe<Scalars['Boolean']['input']>;
  clearOriginalImageURL?: InputMaybe<Scalars['Boolean']['input']>;
  clearPost?: InputMaybe<Scalars['Boolean']['input']>;
  clearPublicationDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearRawContent?: InputMaybe<Scalars['Boolean']['input']>;
  clearSummary?: InputMaybe<Scalars['Boolean']['input']>;
  clearTitle?: InputMaybe<Scalars['Boolean']['input']>;
  clearTopics?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The description of the article, either from the RSS feed or the opengraph meta tag */
  description?: InputMaybe<Scalars['String']['input']>;
  feedID?: InputMaybe<Scalars['ID']['input']>;
  /** The Cloudflare CDN url of the image */
  imageURL?: InputMaybe<Scalars['String']['input']>;
  /** The original image URL from the RSS feed or the opengraph meta tag */
  originalImageURL?: InputMaybe<Scalars['String']['input']>;
  postID?: InputMaybe<Scalars['ID']['input']>;
  publicationDate?: InputMaybe<Scalars['Time']['input']>;
  /** The raw HTML content of the article */
  rawContent?: InputMaybe<Scalars['String']['input']>;
  removeTopicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  status?: InputMaybe<ArticleStatus>;
  /** The AI generated summary of the article */
  summary?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateAudienceInput is used for update Audience object.
 * Input was generated by ent.
 */
export type UpdateAudienceInput = {
  addNpiTaxonomyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearNpiTaxonomies?: InputMaybe<Scalars['Boolean']['input']>;
  clearPosts?: InputMaybe<Scalars['Boolean']['input']>;
  clearTenant?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The raw text template for the designation text that will be displayed on the certificate. Use the designation field to get the rendered text. */
  designationtemplate?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  removeNpiTaxonomyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removePostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateBoardCertificationInput is used for update BoardCertification object.
 * Input was generated by ent.
 */
export type UpdateBoardCertificationInput = {
  clearSubSpecialty?: InputMaybe<Scalars['Boolean']['input']>;
  clearUser?: InputMaybe<Scalars['Boolean']['input']>;
  /** Name of the certifying board */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Sub-specialty of the certification */
  subSpecialty?: InputMaybe<Scalars['String']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateBookmarkInput is used for update Bookmark object.
 * Input was generated by ent.
 */
export type UpdateBookmarkInput = {
  /** The time that the user bookmarked the post. */
  bookmarkedAt?: InputMaybe<Scalars['Time']['input']>;
  postID?: InputMaybe<Scalars['ID']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateCertificateSurveyAnswerInput is used for update CertificateSurveyAnswer object.
 * Input was generated by ent.
 */
export type UpdateCertificateSurveyAnswerInput = {
  /** The answer to the question. */
  answer?: InputMaybe<Scalars['String']['input']>;
  certificateID?: InputMaybe<Scalars['ID']['input']>;
  certificateSurveyQuestionID?: InputMaybe<Scalars['ID']['input']>;
  choiceID?: InputMaybe<Scalars['ID']['input']>;
  clearCertificate?: InputMaybe<Scalars['Boolean']['input']>;
  clearCertificateSurveyQuestion?: InputMaybe<Scalars['Boolean']['input']>;
  clearChoice?: InputMaybe<Scalars['Boolean']['input']>;
  clearUser?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateCertificateSurveyQuestionChoiceInput is used for update CertificateSurveyQuestionChoice object.
 * Input was generated by ent.
 */
export type UpdateCertificateSurveyQuestionChoiceInput = {
  clearQuestion?: InputMaybe<Scalars['Boolean']['input']>;
  /** The emoji for the choice. */
  emoji?: InputMaybe<Scalars['String']['input']>;
  /** The label for the choice. */
  label?: InputMaybe<Scalars['String']['input']>;
  questionID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateCertificateSurveyQuestionInput is used for update CertificateSurveyQuestion object.
 * Input was generated by ent.
 */
export type UpdateCertificateSurveyQuestionInput = {
  addChoiceIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearChoices?: InputMaybe<Scalars['Boolean']['input']>;
  clearLearningObjective?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  learningObjectiveID?: InputMaybe<Scalars['ID']['input']>;
  /** The question to ask the user. */
  question?: InputMaybe<Scalars['String']['input']>;
  removeChoiceIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateCertifyingBoardInput is used for update CertifyingBoard object.
 * Input was generated by ent.
 */
export type UpdateCertifyingBoardInput = {
  /** Name of the certifying board */
  name?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateCollectionInput is used for update Collection object.
 * Input was generated by ent.
 */
export type UpdateCollectionInput = {
  addPostcollectionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addUserCompletionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearCover?: InputMaybe<Scalars['Boolean']['input']>;
  clearDescription?: InputMaybe<Scalars['Boolean']['input']>;
  clearPostcollections?: InputMaybe<Scalars['Boolean']['input']>;
  clearTenant?: InputMaybe<Scalars['Boolean']['input']>;
  clearUserCompletions?: InputMaybe<Scalars['Boolean']['input']>;
  coverID?: InputMaybe<Scalars['ID']['input']>;
  /** The description of the collection. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** The name of the collection. */
  name?: InputMaybe<Scalars['String']['input']>;
  removePostcollectionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeUserCompletionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  /** The total duration of all the posts in the collection. */
  totalDuration?: InputMaybe<Scalars['Int']['input']>;
  /** The total number of posts in the collection. */
  totalPosts?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * UpdateCommentInput is used for update Comment object.
 * Input was generated by ent.
 */
export type UpdateCommentInput = {
  addCommentNamedEntityIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addLikedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addReplyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addSparkyConversationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  authorID?: InputMaybe<Scalars['ID']['input']>;
  /** Body of the comment */
  body?: InputMaybe<Scalars['String']['input']>;
  clearAuthor?: InputMaybe<Scalars['Boolean']['input']>;
  clearCommentNamedEntities?: InputMaybe<Scalars['Boolean']['input']>;
  clearCreditWasApproved?: InputMaybe<Scalars['Boolean']['input']>;
  clearEducationCredit?: InputMaybe<Scalars['Boolean']['input']>;
  clearLikedUsers?: InputMaybe<Scalars['Boolean']['input']>;
  clearParent?: InputMaybe<Scalars['Boolean']['input']>;
  clearPost?: InputMaybe<Scalars['Boolean']['input']>;
  clearReflectionAnalysis?: InputMaybe<Scalars['Boolean']['input']>;
  clearReflectionPrompt?: InputMaybe<Scalars['Boolean']['input']>;
  clearReplies?: InputMaybe<Scalars['Boolean']['input']>;
  clearReviewedBy?: InputMaybe<Scalars['Boolean']['input']>;
  clearSparkyChat?: InputMaybe<Scalars['Boolean']['input']>;
  clearSparkyConversations?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Whether or not the credit was approved */
  creditWasApproved?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not the user earned credits for this comment */
  didEarnCredits?: InputMaybe<Scalars['Boolean']['input']>;
  educationCreditID?: InputMaybe<Scalars['ID']['input']>;
  parentID?: InputMaybe<Scalars['ID']['input']>;
  postID?: InputMaybe<Scalars['ID']['input']>;
  reflectionAnalysisID?: InputMaybe<Scalars['ID']['input']>;
  /** The reflection prompt the user chose for this comment */
  reflectionPrompt?: InputMaybe<Scalars['String']['input']>;
  /**
   * The version of the reflection analysis algorithm used to analyze this comment.
   *
   * Version 1 is the original version, and is synchronous and the results are available immediately.
   *  - DidEarnCredits is set to true if the comment is approved.
   *  - ReflectionAnalysisResults is set to the results of the analysis.
   *
   * Version 2 is the newest version, and is asynchronous. Poll completedAt on the ReflectionAnalysis field to see if the comment was approved.
   *  - DidEarnCredits is set to true if the comment is approved.
   *           - ReflectionAnalysisResults is NOT set
   *           - See the ReflectionAnalysis field for details on the analysis.
   *  - If the comment was not approved, use the linked SparkyChat to continue the reflective process.
   */
  reflectionVersion?: InputMaybe<Scalars['Int']['input']>;
  removeCommentNamedEntityIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeLikedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeReplyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeSparkyConversationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  reviewedByID?: InputMaybe<Scalars['ID']['input']>;
  /** Whether or not the user should earn credits for this comment */
  shouldEarnCredits?: InputMaybe<Scalars['Boolean']['input']>;
  sparkyChatID?: InputMaybe<Scalars['ID']['input']>;
  /** The total number of likes this comment has */
  totalLikes?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateCommentLikeInput is used for update CommentLike object.
 * Input was generated by ent.
 */
export type UpdateCommentLikeInput = {
  commentID?: InputMaybe<Scalars['ID']['input']>;
  /** The time that the user liked the comment.  */
  likedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateCourseInput is used for update Course object.
 * Input was generated by ent.
 */
export type UpdateCourseInput = {
  addFacultyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  authorID?: InputMaybe<Scalars['ID']['input']>;
  clearAuthor?: InputMaybe<Scalars['Boolean']['input']>;
  clearDescription?: InputMaybe<Scalars['Boolean']['input']>;
  clearDisclosure?: InputMaybe<Scalars['Boolean']['input']>;
  clearFaculty?: InputMaybe<Scalars['Boolean']['input']>;
  clearReviewedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearReviewedBy?: InputMaybe<Scalars['Boolean']['input']>;
  clearStartDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearTenant?: InputMaybe<Scalars['Boolean']['input']>;
  clearVideo?: InputMaybe<Scalars['Boolean']['input']>;
  clearWebsite?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  creditHours?: InputMaybe<Scalars['Float']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  disclosure?: InputMaybe<Scalars['String']['input']>;
  isRaceApproved?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  price?: InputMaybe<Scalars['Float']['input']>;
  removeFacultyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  reviewedAt?: InputMaybe<Scalars['Time']['input']>;
  reviewedByID?: InputMaybe<Scalars['ID']['input']>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  status?: InputMaybe<CourseStatus>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  type?: InputMaybe<CourseType>;
  videoID?: InputMaybe<Scalars['ID']['input']>;
  website?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateDashboardInput is used for update Dashboard object.
 * Input was generated by ent.
 */
export type UpdateDashboardInput = {
  clearDefaultOrderBy?: InputMaybe<Scalars['Boolean']['input']>;
  clearDefaultOrderDirection?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  defaultOrderBy?: InputMaybe<Scalars['String']['input']>;
  defaultOrderDirection?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  query?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateEducationCreditInput is used for update EducationCredit object.
 * Input was generated by ent.
 */
export type UpdateEducationCreditInput = {
  addUserCollectionCompletionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  certificateID?: InputMaybe<Scalars['ID']['input']>;
  clearCertificate?: InputMaybe<Scalars['Boolean']['input']>;
  clearComment?: InputMaybe<Scalars['Boolean']['input']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearDeletedBy?: InputMaybe<Scalars['Boolean']['input']>;
  clearDeletedReason?: InputMaybe<Scalars['Boolean']['input']>;
  clearLearningObjective?: InputMaybe<Scalars['Boolean']['input']>;
  clearPost?: InputMaybe<Scalars['Boolean']['input']>;
  clearRedeemedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearSparkyConversation?: InputMaybe<Scalars['Boolean']['input']>;
  clearSurvey?: InputMaybe<Scalars['Boolean']['input']>;
  clearTenant?: InputMaybe<Scalars['Boolean']['input']>;
  clearUserCollectionCompletions?: InputMaybe<Scalars['Boolean']['input']>;
  commentID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The time that the credit was deleted. */
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  deletedByID?: InputMaybe<Scalars['ID']['input']>;
  /** The reason that the credit was deleted. */
  deletedReason?: InputMaybe<Scalars['String']['input']>;
  learningObjectiveID?: InputMaybe<Scalars['ID']['input']>;
  postID?: InputMaybe<Scalars['ID']['input']>;
  /** The time that the credit was redeemed. */
  redeemedAt?: InputMaybe<Scalars['Time']['input']>;
  removeUserCollectionCompletionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  sparkyConversationID?: InputMaybe<Scalars['ID']['input']>;
  /** The survey for the credit. */
  survey?: InputMaybe<Scalars['Map']['input']>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  /** The type of the credit. */
  type?: InputMaybe<EducationCreditType>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
  /** The value of the credit. */
  value?: InputMaybe<Scalars['Float']['input']>;
  /** The version of the credit. */
  version?: InputMaybe<EducationCreditVersion>;
};

/**
 * UpdateEducationHistoryInput is used for update EducationHistory object.
 * Input was generated by ent.
 */
export type UpdateEducationHistoryInput = {
  clearDegree?: InputMaybe<Scalars['Boolean']['input']>;
  clearEndDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearMajor?: InputMaybe<Scalars['Boolean']['input']>;
  clearStartDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearUser?: InputMaybe<Scalars['Boolean']['input']>;
  /** The degree attained for this education history entry. */
  degree?: InputMaybe<Scalars['String']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  /** The institution/school name for this education history entry. */
  institution?: InputMaybe<Scalars['String']['input']>;
  /** The major for this education history entry. */
  major?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  type?: InputMaybe<EducationHistoryType>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateEducationRequirementInput is used for update EducationRequirement object.
 * Input was generated by ent.
 */
export type UpdateEducationRequirementInput = {
  clearProfession?: InputMaybe<Scalars['Boolean']['input']>;
  clearReferenceURL?: InputMaybe<Scalars['Boolean']['input']>;
  countryCode?: InputMaybe<Scalars['String']['input']>;
  periodInYears?: InputMaybe<Scalars['Int']['input']>;
  profession?: InputMaybe<Scalars['String']['input']>;
  referenceURL?: InputMaybe<Scalars['String']['input']>;
  stateCode?: InputMaybe<Scalars['String']['input']>;
  totalCmeCategoryOneRequired?: InputMaybe<Scalars['Int']['input']>;
  totalCmeRequired?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * UpdateFinancialDisclosureInput is used for update FinancialDisclosure object.
 * Input was generated by ent.
 */
export type UpdateFinancialDisclosureInput = {
  clearDeletedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearStatement?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of the company the user is declaring this financial disclosure for */
  companyName?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** If true, the relationship with the company has ended */
  hasEnded?: InputMaybe<Scalars['Boolean']['input']>;
  roleID?: InputMaybe<Scalars['ID']['input']>;
  statementID?: InputMaybe<Scalars['ID']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateFinancialDisclosurePrintTemplateInput is used for update FinancialDisclosurePrintTemplate object.
 * Input was generated by ent.
 */
export type UpdateFinancialDisclosurePrintTemplateInput = {
  clearTemplate?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  template?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateFinancialDisclosureRoleInput is used for update FinancialDisclosureRole object.
 * Input was generated by ent.
 */
export type UpdateFinancialDisclosureRoleInput = {
  /** If true, financial disclosures with this role will be rejected automatically */
  automaticallyReject?: InputMaybe<Scalars['Boolean']['input']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  /** (DEPRECATED) this value is ignored */
  requiresApproval?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateFinancialDisclosureStatementInput is used for update FinancialDisclosureStatement object.
 * Input was generated by ent.
 */
export type UpdateFinancialDisclosureStatementInput = {
  addRelationshipIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** If true, the user agrees to disclose unlabeled/unapproved users of drugs or products */
  agreesToDisclose?: InputMaybe<Scalars['Boolean']['input']>;
  /** The date the financial disclosure statement was approved (Admin Only) */
  approvedAt?: InputMaybe<Scalars['Time']['input']>;
  clearApprovedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearDeletedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearDeniedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearRelationships?: InputMaybe<Scalars['Boolean']['input']>;
  clearUser?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  deletedAt?: InputMaybe<Scalars['Time']['input']>;
  /** The date the financial disclosure statement was denied (Admin Only) */
  deniedAt?: InputMaybe<Scalars['Time']['input']>;
  /** If true, the user attests that the information provided is true and accurate */
  doesAttest?: InputMaybe<Scalars['Boolean']['input']>;
  /** If true, the user has financial relationships */
  hasFinancialRelationships?: InputMaybe<Scalars['Boolean']['input']>;
  /** The initials of the user */
  initials?: InputMaybe<Scalars['String']['input']>;
  /**
   * Input for creating or updating a relationship with a company. If the ID is not provided, a new relationship will be created.
   * Pass in all existing relationships, even if they are not being updated. If a relationship is not passed in, it will be deleted.
   */
  relationships?: InputMaybe<Array<FinancialDisclosureInput>>;
  removeRelationshipIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** If true, at least one of the relationships has a role requiring approval (Admin Only) */
  requiresApproval?: InputMaybe<Scalars['Boolean']['input']>;
  /** The date the user signed the financial disclosure statement */
  signatureDate?: InputMaybe<Scalars['Time']['input']>;
  /** The status of the financial disclosure statement (Admin Only) */
  status?: InputMaybe<FinancialDisclosureStatementStatus>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateGoogleDriveFileInput is used for update GoogleDriveFile object.
 * Input was generated by ent.
 */
export type UpdateGoogleDriveFileInput = {
  appendParents?: InputMaybe<Array<Scalars['String']['input']>>;
  clearCopyCompletedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearCopyErrorMessage?: InputMaybe<Scalars['Boolean']['input']>;
  clearCopyStartedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearCreatedTime?: InputMaybe<Scalars['Boolean']['input']>;
  clearDurationMillis?: InputMaybe<Scalars['Boolean']['input']>;
  clearFolder?: InputMaybe<Scalars['Boolean']['input']>;
  clearParents?: InputMaybe<Scalars['Boolean']['input']>;
  clearSize?: InputMaybe<Scalars['Boolean']['input']>;
  clearVideo?: InputMaybe<Scalars['Boolean']['input']>;
  copyCompletedAt?: InputMaybe<Scalars['Time']['input']>;
  copyErrorMessage?: InputMaybe<Scalars['String']['input']>;
  copyStartedAt?: InputMaybe<Scalars['Time']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdTime?: InputMaybe<Scalars['Time']['input']>;
  driveID?: InputMaybe<Scalars['String']['input']>;
  durationMillis?: InputMaybe<Scalars['Int']['input']>;
  fileID?: InputMaybe<Scalars['String']['input']>;
  folder?: InputMaybe<Scalars['String']['input']>;
  mimeType?: InputMaybe<Scalars['String']['input']>;
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  parents?: InputMaybe<Array<Scalars['String']['input']>>;
  size?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  videoID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateLearningObjectiveInput is used for update LearningObjective object.
 * Input was generated by ent.
 */
export type UpdateLearningObjectiveInput = {
  addCertificateSurveyQuestionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addEducationCreditIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addVideoIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearCertificateSurveyQuestions?: InputMaybe<Scalars['Boolean']['input']>;
  clearEducationCredits?: InputMaybe<Scalars['Boolean']['input']>;
  clearPosts?: InputMaybe<Scalars['Boolean']['input']>;
  clearSurveyQuestion?: InputMaybe<Scalars['Boolean']['input']>;
  clearTenant?: InputMaybe<Scalars['Boolean']['input']>;
  clearVideos?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  removeCertificateSurveyQuestionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeEducationCreditIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removePostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeVideoIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  surveyQuestion?: InputMaybe<Scalars['String']['input']>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateLicenseHistoryInput is used for update LicenseHistory object.
 * Input was generated by ent.
 */
export type UpdateLicenseHistoryInput = {
  clearEndDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearInstitution?: InputMaybe<Scalars['Boolean']['input']>;
  clearLicenseNumber?: InputMaybe<Scalars['Boolean']['input']>;
  clearStartDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearState?: InputMaybe<Scalars['Boolean']['input']>;
  clearUser?: InputMaybe<Scalars['Boolean']['input']>;
  endDate?: InputMaybe<Scalars['Time']['input']>;
  /** The institution that issued the license. */
  institution?: InputMaybe<Scalars['String']['input']>;
  /** The license number. */
  licenseNumber?: InputMaybe<Scalars['String']['input']>;
  startDate?: InputMaybe<Scalars['Time']['input']>;
  /** The state in which the license was issued. */
  state?: InputMaybe<Scalars['String']['input']>;
  /** The title of the license. */
  title?: InputMaybe<Scalars['String']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateLikeInput is used for update Like object.
 * Input was generated by ent.
 */
export type UpdateLikeInput = {
  /** The time that the user liked the post.  */
  likedAt?: InputMaybe<Scalars['Time']['input']>;
  postID?: InputMaybe<Scalars['ID']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateMediaItemInput is used for update MediaItem object.
 * Input was generated by ent.
 */
export type UpdateMediaItemInput = {
  /** The size of the media item in bytes. */
  bytes?: InputMaybe<Scalars['Int']['input']>;
  clearDuration?: InputMaybe<Scalars['Boolean']['input']>;
  clearPost?: InputMaybe<Scalars['Boolean']['input']>;
  /** The duration of the media item in seconds. */
  duration?: InputMaybe<Scalars['Int']['input']>;
  /** The format of the media item. ie jpg, png, gif, etc. */
  format?: InputMaybe<Scalars['String']['input']>;
  /** The height of the media item in pixels. */
  height?: InputMaybe<Scalars['Int']['input']>;
  /** The type of media item. Will be image or video */
  mediaType?: InputMaybe<Scalars['String']['input']>;
  ordinal?: InputMaybe<Scalars['Int']['input']>;
  /** The original filename of the media item. */
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  postID?: InputMaybe<Scalars['ID']['input']>;
  /** [Deprecated] The public ID in Cloudinary of the media item. */
  publicID?: InputMaybe<Scalars['String']['input']>;
  /** The URL of the media item. */
  url?: InputMaybe<Scalars['String']['input']>;
  /** The width of the media item in pixels. */
  width?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * UpdateNotificationConfigInput is used for update NotificationConfig object.
 * Input was generated by ent.
 */
export type UpdateNotificationConfigInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The message template for follow notifications. */
  followUserMessage?: InputMaybe<Scalars['String']['input']>;
  /** The message template for like notifications. */
  likedPostMessage?: InputMaybe<Scalars['String']['input']>;
  /** The message template for comment notifications. */
  reflectedPostMessage?: InputMaybe<Scalars['String']['input']>;
  /** The message template for reflection approved notifications. */
  reflectionApproved?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateNotificationInput is used for update Notification object.
 * Input was generated by ent.
 */
export type UpdateNotificationInput = {
  /**
   * The body of the notification. This is the fully rendered message minus the user's name
   * ie. liked your post "Test Post"
   * or  reflected on your post "Test Post"
   */
  body?: InputMaybe<Scalars['String']['input']>;
  clearFrom?: InputMaybe<Scalars['Boolean']['input']>;
  clearImage?: InputMaybe<Scalars['Boolean']['input']>;
  clearPushSentAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearReadAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearUser?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  fromID?: InputMaybe<Scalars['ID']['input']>;
  imageID?: InputMaybe<Scalars['ID']['input']>;
  /** (DEPRECATED - Use body instead) The message of the notification. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** The type of notification. */
  notificationType?: InputMaybe<NotificationNotificationType>;
  pushSentAt?: InputMaybe<Scalars['Time']['input']>;
  /** The time that the notification was read. */
  readAt?: InputMaybe<Scalars['Time']['input']>;
  /** The ID of the resource that the notification is for. */
  resourceID?: InputMaybe<Scalars['String']['input']>;
  /** The type of resource that the notification is for. */
  resourceType?: InputMaybe<Scalars['String']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateNpiTaxonomyInput is used for update NpiTaxonomy object.
 * Input was generated by ent.
 */
export type UpdateNpiTaxonomyInput = {
  addAudienceIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addTopicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  classification?: InputMaybe<Scalars['String']['input']>;
  clearAudiences?: InputMaybe<Scalars['Boolean']['input']>;
  clearSpecialization?: InputMaybe<Scalars['Boolean']['input']>;
  clearTopics?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  grouping?: InputMaybe<Scalars['String']['input']>;
  removeAudienceIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeTopicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  specialization?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateOfficeInput is used for update Office object.
 * Input was generated by ent.
 */
export type UpdateOfficeInput = {
  /** The first line of the address. Typically the street address or PO Box number. */
  address1?: InputMaybe<Scalars['String']['input']>;
  /** The second line of the address. Typically the number of the apartment, suite, or unit. */
  address2?: InputMaybe<Scalars['String']['input']>;
  /** The city of the office */
  city?: InputMaybe<Scalars['String']['input']>;
  clearAddress2?: InputMaybe<Scalars['Boolean']['input']>;
  clearCountryCode?: InputMaybe<Scalars['Boolean']['input']>;
  clearEmail?: InputMaybe<Scalars['Boolean']['input']>;
  clearFax?: InputMaybe<Scalars['Boolean']['input']>;
  clearPhone?: InputMaybe<Scalars['Boolean']['input']>;
  clearUser?: InputMaybe<Scalars['Boolean']['input']>;
  /** The two-letter code for the country of the address. For example US for United States. */
  countryCode?: InputMaybe<Scalars['String']['input']>;
  /** The email address for the office */
  email?: InputMaybe<Scalars['String']['input']>;
  /** The fax number of the office. Formatted using E.164 standard. */
  fax?: InputMaybe<Scalars['String']['input']>;
  /** The phone number of the office, Formatted using E.164 standard. */
  phone?: InputMaybe<Scalars['String']['input']>;
  /** Whether the office is the primary office location. */
  primary?: InputMaybe<Scalars['Boolean']['input']>;
  /** The two-letter code for the region. For example CA for California. */
  stateCode?: InputMaybe<Scalars['String']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
  /** The zip or postal code of the address. */
  zip?: InputMaybe<Scalars['String']['input']>;
};

/** The field used to update an existing PollAnswer. */
export type UpdatePollAnswerInput = {
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  pollID?: InputMaybe<Scalars['ID']['input']>;
  questionID?: InputMaybe<Scalars['ID']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/** The field used to update an existing PollAnswer. */
export type UpdatePollQuestionInput = {
  clearPoll?: InputMaybe<Scalars['Boolean']['input']>;
  pollID?: InputMaybe<Scalars['ID']['input']>;
  /** The question to ask the user. */
  question?: InputMaybe<Scalars['String']['input']>;
  totalVotes?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * UpdatePostCitationInput is used for update PostCitation object.
 * Input was generated by ent.
 */
export type UpdatePostCitationInput = {
  clearPost?: InputMaybe<Scalars['Boolean']['input']>;
  /** The name of the citation. */
  name?: InputMaybe<Scalars['String']['input']>;
  postID?: InputMaybe<Scalars['ID']['input']>;
  /** The url of the citation. */
  url?: InputMaybe<Scalars['String']['input']>;
};

/** The field used to update an existing Post. */
export type UpdatePostInput = {
  accreditedLearningObjectiveID?: InputMaybe<Scalars['ID']['input']>;
  addAudienceIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addBookmarkedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addCitationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addCommentIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addEducationCreditIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addEmbeddingIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addFeedHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addImageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addLearningObjectiveIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addLikedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addMediaItemIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addMentionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addPostCollectionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addPostReportIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addPostTagIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addTopicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addVideoIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  appendDiscussionPoints?: InputMaybe<Array<Scalars['String']['input']>>;
  appendReflectiveNudges?: InputMaybe<Array<Scalars['String']['input']>>;
  appendSyntheticSuggestedSearches?: InputMaybe<Array<Scalars['String']['input']>>;
  appendTerms?: InputMaybe<Array<Scalars['String']['input']>>;
  authorID?: InputMaybe<Scalars['ID']['input']>;
  /** Body of the post. Tags (starting with a #) and Mentions (starting with an @) are allowed */
  body?: InputMaybe<Scalars['String']['input']>;
  /** Whether this post is accredited for CE credits */
  ce?: InputMaybe<Scalars['Boolean']['input']>;
  /** The disclosure statements for this post */
  ceDisclosureStatements?: InputMaybe<Scalars['String']['input']>;
  clearAccreditedLearningObjective?: InputMaybe<Scalars['Boolean']['input']>;
  clearAudiences?: InputMaybe<Scalars['Boolean']['input']>;
  clearAuthor?: InputMaybe<Scalars['Boolean']['input']>;
  clearBookmarkedUsers?: InputMaybe<Scalars['Boolean']['input']>;
  clearCeDisclosureStatements?: InputMaybe<Scalars['Boolean']['input']>;
  clearCitations?: InputMaybe<Scalars['Boolean']['input']>;
  clearComments?: InputMaybe<Scalars['Boolean']['input']>;
  clearCoverImage?: InputMaybe<Scalars['Boolean']['input']>;
  clearDiscussionPoints?: InputMaybe<Scalars['Boolean']['input']>;
  clearEducationCredits?: InputMaybe<Scalars['Boolean']['input']>;
  clearEmbeddings?: InputMaybe<Scalars['Boolean']['input']>;
  clearExternalURL?: InputMaybe<Scalars['Boolean']['input']>;
  clearFeedHistories?: InputMaybe<Scalars['Boolean']['input']>;
  clearImages?: InputMaybe<Scalars['Boolean']['input']>;
  clearLearningObjectives?: InputMaybe<Scalars['Boolean']['input']>;
  clearLikedUsers?: InputMaybe<Scalars['Boolean']['input']>;
  clearMediaItems?: InputMaybe<Scalars['Boolean']['input']>;
  clearMentions?: InputMaybe<Scalars['Boolean']['input']>;
  clearPoll?: InputMaybe<Scalars['Boolean']['input']>;
  clearPostCollections?: InputMaybe<Scalars['Boolean']['input']>;
  clearPostReports?: InputMaybe<Scalars['Boolean']['input']>;
  clearPostTags?: InputMaybe<Scalars['Boolean']['input']>;
  clearReflectiveNudges?: InputMaybe<Scalars['Boolean']['input']>;
  clearShareURL?: InputMaybe<Scalars['Boolean']['input']>;
  clearSortKey?: InputMaybe<Scalars['Boolean']['input']>;
  clearSourceArticle?: InputMaybe<Scalars['Boolean']['input']>;
  clearSyntheticSuggestedSearches?: InputMaybe<Scalars['Boolean']['input']>;
  clearTenant?: InputMaybe<Scalars['Boolean']['input']>;
  clearTermFrequencies?: InputMaybe<Scalars['Boolean']['input']>;
  clearTerms?: InputMaybe<Scalars['Boolean']['input']>;
  clearTopics?: InputMaybe<Scalars['Boolean']['input']>;
  clearVideos?: InputMaybe<Scalars['Boolean']['input']>;
  clearWordcloud?: InputMaybe<Scalars['Boolean']['input']>;
  coverImageID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The number of CE credits this post is accredited for */
  creditHours?: InputMaybe<Scalars['Float']['input']>;
  /** The main discussion points for this post. If the post has an attached sourceArticle, the discussionPoints have been copied from there and are identical.  */
  discussionPoints?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Whether this post should be excluded from the feed */
  excludeFromFeed?: InputMaybe<Scalars['Boolean']['input']>;
  /** The external URL for this post. This is used for articles and other external content */
  externalURL?: InputMaybe<Scalars['String']['input']>;
  /** Whether this post is featured */
  featured?: InputMaybe<Scalars['Boolean']['input']>;
  pollID?: InputMaybe<Scalars['ID']['input']>;
  reflectiveNudges?: InputMaybe<Array<Scalars['String']['input']>>;
  removeAudienceIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeBookmarkedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeCitationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeCommentIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeEducationCreditIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeEmbeddingIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeFeedHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeImageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeLearningObjectiveIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeLikedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeMediaItemIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeMentionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** Remove the poll questions for the post, based on the provided IDs */
  removePollQuestionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removePostCollectionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removePostReportIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removePostTagIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeTopicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeVideoIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The URL to use in the share sheet, social media or other sharing mechanisms */
  shareURL?: InputMaybe<Scalars['String']['input']>;
  sortKey?: InputMaybe<Scalars['Int']['input']>;
  sourceArticleID?: InputMaybe<Scalars['ID']['input']>;
  /**
   * The status of the post.
   * - draft: The post is in draft mode and is only visible to the post author.
   * - published: The post is published and visible in the feed and searchable.
   * - archived: The post is archived and not visible to anyone except an admin.
   * - deleted: The post is deleted and not visible to anyone except an admin.
   * - processing: The post is being processed and is only visible to the post author.
   */
  status?: InputMaybe<PostStatus>;
  syntheticSuggestedSearches?: InputMaybe<Array<Scalars['String']['input']>>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  termFrequencies?: InputMaybe<Scalars['Map']['input']>;
  terms?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Title of the post */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The trending boost of the post. */
  trendingBoost?: InputMaybe<Scalars['Float']['input']>;
  /** The type of the post */
  type?: InputMaybe<PostType>;
  /** Update a Citation for the post */
  updateCitations?: InputMaybe<Array<UpsertPostCitationInput>>;
  /** Update the questions for the post */
  updatePollQuestions?: InputMaybe<Array<UpsertPollQuestionInput>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  wordcloud?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdatePostReactionInput is used for update PostReaction object.
 * Input was generated by ent.
 */
export type UpdatePostReactionInput = {
  postID?: InputMaybe<Scalars['ID']['input']>;
  /** The time that the user reacted to the post. */
  reactedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
  /** The text value of the reaction. */
  value?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdatePostReportInput is used for update PostReport object.
 * Input was generated by ent.
 */
export type UpdatePostReportInput = {
  authorID?: InputMaybe<Scalars['ID']['input']>;
  clearAuthor?: InputMaybe<Scalars['Boolean']['input']>;
  clearDescription?: InputMaybe<Scalars['Boolean']['input']>;
  clearReportReason?: InputMaybe<Scalars['Boolean']['input']>;
  clearReportedPost?: InputMaybe<Scalars['Boolean']['input']>;
  clearReviewedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearReviewedBy?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The description of the user report */
  description?: InputMaybe<Scalars['String']['input']>;
  reportReasonID?: InputMaybe<Scalars['ID']['input']>;
  reportedPostID?: InputMaybe<Scalars['ID']['input']>;
  /** The time the report was reviewed */
  reviewedAt?: InputMaybe<Scalars['Time']['input']>;
  reviewedByID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdatePubmedTopicClusterInput is used for update PubmedTopicCluster object.
 * Input was generated by ent.
 */
export type UpdatePubmedTopicClusterInput = {
  addPubmedArticleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addTopicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  appendClusterWords?: InputMaybe<Array<Scalars['String']['input']>>;
  clearLabel?: InputMaybe<Scalars['Boolean']['input']>;
  clearPubmedArticles?: InputMaybe<Scalars['Boolean']['input']>;
  clearTopics?: InputMaybe<Scalars['Boolean']['input']>;
  clusterID?: InputMaybe<Scalars['Int']['input']>;
  clusterLabel?: InputMaybe<Scalars['String']['input']>;
  clusterWords?: InputMaybe<Array<Scalars['String']['input']>>;
  label?: InputMaybe<Scalars['String']['input']>;
  removePubmedArticleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeTopicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * UpdateReflectionCriteriaGroupInput is used for update ReflectionCriteriaGroup object.
 * Input was generated by ent.
 */
export type UpdateReflectionCriteriaGroupInput = {
  addCriteriaIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearCriterias?: InputMaybe<Scalars['Boolean']['input']>;
  clearExpression?: InputMaybe<Scalars['Boolean']['input']>;
  clearFacetKey?: InputMaybe<Scalars['Boolean']['input']>;
  clearPromptFooter?: InputMaybe<Scalars['Boolean']['input']>;
  clearPromptHeader?: InputMaybe<Scalars['Boolean']['input']>;
  clearResponseFormat?: InputMaybe<Scalars['Boolean']['input']>;
  expression?: InputMaybe<Scalars['String']['input']>;
  facetKey?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  promptFooter?: InputMaybe<Scalars['String']['input']>;
  promptHeader?: InputMaybe<Scalars['String']['input']>;
  removeCriteriaIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  responseFormat?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateReflectionCriteriaInput is used for update ReflectionCriteria object.
 * Input was generated by ent.
 */
export type UpdateReflectionCriteriaInput = {
  addChildIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addScoreIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  appendModels?: InputMaybe<Array<Scalars['String']['input']>>;
  appendRubric?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The footer from the group edge, if it exists */
  cachedFooter?: InputMaybe<Scalars['String']['input']>;
  /** The header from the group edge, if it exists */
  cachedHeader?: InputMaybe<Scalars['String']['input']>;
  clearCachedFooter?: InputMaybe<Scalars['Boolean']['input']>;
  clearCachedHeader?: InputMaybe<Scalars['Boolean']['input']>;
  clearChildren?: InputMaybe<Scalars['Boolean']['input']>;
  clearCriteriaAbbreviation?: InputMaybe<Scalars['Boolean']['input']>;
  clearExperiment?: InputMaybe<Scalars['Boolean']['input']>;
  clearFacet?: InputMaybe<Scalars['Boolean']['input']>;
  clearGroup?: InputMaybe<Scalars['Boolean']['input']>;
  clearModels?: InputMaybe<Scalars['Boolean']['input']>;
  clearParent?: InputMaybe<Scalars['Boolean']['input']>;
  clearPrompt?: InputMaybe<Scalars['Boolean']['input']>;
  clearScores?: InputMaybe<Scalars['Boolean']['input']>;
  criteria?: InputMaybe<Scalars['String']['input']>;
  criteriaAbbreviation?: InputMaybe<Scalars['String']['input']>;
  experimentID?: InputMaybe<Scalars['ID']['input']>;
  /** The facet of the criteria. Ie AACME, Oog, Developing Reflective Practice */
  facet?: InputMaybe<Scalars['String']['input']>;
  groupID?: InputMaybe<Scalars['ID']['input']>;
  /** The models for the criteria should run on. Leave empty to run on all models. */
  models?: InputMaybe<Array<Scalars['String']['input']>>;
  parentID?: InputMaybe<Scalars['ID']['input']>;
  prompt?: InputMaybe<Scalars['String']['input']>;
  removeChildIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeScoreIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The rubric for the criteria */
  rubric?: InputMaybe<Array<Scalars['String']['input']>>;
};

/**
 * UpdateReportReasonInput is used for update ReportReason object.
 * Input was generated by ent.
 */
export type UpdateReportReasonInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateSparkyChatConfigInput is used for update SparkyChatConfig object.
 * Input was generated by ent.
 */
export type UpdateSparkyChatConfigInput = {
  addCopiedFromIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addRuleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearCopiedFrom?: InputMaybe<Scalars['Boolean']['input']>;
  clearCopies?: InputMaybe<Scalars['Boolean']['input']>;
  clearName?: InputMaybe<Scalars['Boolean']['input']>;
  clearReflectionGradingExpression?: InputMaybe<Scalars['Boolean']['input']>;
  clearRules?: InputMaybe<Scalars['Boolean']['input']>;
  clearUser?: InputMaybe<Scalars['Boolean']['input']>;
  copiesID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  isDefault?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  reflectionGradingExpression?: InputMaybe<Scalars['String']['input']>;
  reflectionNudgePrompt?: InputMaybe<Scalars['String']['input']>;
  removeCopiedFromIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeRuleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  suggestReflectionPrompt?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateSparkyChatInput is used for update SparkyChat object.
 * Input was generated by ent.
 */
export type UpdateSparkyChatInput = {
  addMessageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  analysisID?: InputMaybe<Scalars['ID']['input']>;
  /** The type of chat this is. Determine how messages will be processed */
  chattype?: InputMaybe<SparkyChatChatType>;
  clearAnalysis?: InputMaybe<Scalars['Boolean']['input']>;
  clearComment?: InputMaybe<Scalars['Boolean']['input']>;
  clearEntityID?: InputMaybe<Scalars['Boolean']['input']>;
  clearEntityType?: InputMaybe<Scalars['Boolean']['input']>;
  clearMessages?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether or not this chat is closed. Closed chats cannot process new messages. */
  closed?: InputMaybe<Scalars['Boolean']['input']>;
  commentID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The ID of the entity this chat is associated with. */
  entityid?: InputMaybe<Scalars['Int']['input']>;
  /** The type of entity this chat is associated with. */
  entitytype?: InputMaybe<Scalars['String']['input']>;
  removeMessageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateSparkyChatMessageInput is used for update SparkyChatMessage object.
 * Input was generated by ent.
 */
export type UpdateSparkyChatMessageInput = {
  body?: InputMaybe<Scalars['String']['input']>;
  chatID?: InputMaybe<Scalars['ID']['input']>;
  clearChat?: InputMaybe<Scalars['Boolean']['input']>;
  clearHandler?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  handler?: InputMaybe<Scalars['String']['input']>;
  sentBySparky?: InputMaybe<Scalars['Boolean']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateSparkyConversationInput is used for update SparkyConversation object.
 * Input was generated by ent.
 */
export type UpdateSparkyConversationInput = {
  addCollectionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addExperimentRunIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addMessageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addScoreIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearClinicalTerms?: InputMaybe<Scalars['Boolean']['input']>;
  clearClinicalTermsWordcloudURL?: InputMaybe<Scalars['Boolean']['input']>;
  clearCollection?: InputMaybe<Scalars['Boolean']['input']>;
  clearComment?: InputMaybe<Scalars['Boolean']['input']>;
  clearConfig?: InputMaybe<Scalars['Boolean']['input']>;
  clearEducationCredit?: InputMaybe<Scalars['Boolean']['input']>;
  clearExperimentRuns?: InputMaybe<Scalars['Boolean']['input']>;
  clearInitialNudge?: InputMaybe<Scalars['Boolean']['input']>;
  clearMedicalTerms?: InputMaybe<Scalars['Boolean']['input']>;
  clearMedicalTermsWordcloudURL?: InputMaybe<Scalars['Boolean']['input']>;
  clearMessages?: InputMaybe<Scalars['Boolean']['input']>;
  clearPost?: InputMaybe<Scalars['Boolean']['input']>;
  clearReflectableID?: InputMaybe<Scalars['Boolean']['input']>;
  clearReflectableType?: InputMaybe<Scalars['Boolean']['input']>;
  clearScores?: InputMaybe<Scalars['Boolean']['input']>;
  clearTargetConversation?: InputMaybe<Scalars['Boolean']['input']>;
  clearTenant?: InputMaybe<Scalars['Boolean']['input']>;
  clearToken?: InputMaybe<Scalars['Boolean']['input']>;
  clearVideo?: InputMaybe<Scalars['Boolean']['input']>;
  /** The clinically relevant terms extracted from the conversation. */
  clinicalTerms?: InputMaybe<Scalars['Map']['input']>;
  /** The word cloud image of the clinically relevant terms extracted from the conversation. */
  clinicalTermsWordcloudURL?: InputMaybe<Scalars['String']['input']>;
  commentID?: InputMaybe<Scalars['ID']['input']>;
  configID?: InputMaybe<Scalars['ID']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** Whether this is a demo conversation. */
  demo?: InputMaybe<Scalars['Boolean']['input']>;
  educationCreditID?: InputMaybe<Scalars['ID']['input']>;
  initialNudge?: InputMaybe<Scalars['String']['input']>;
  /** The medical dictionary terms extracted from the conversation. */
  medicalTerms?: InputMaybe<Scalars['Map']['input']>;
  /** The word cloud image of the medical terms extracted from the conversation. */
  medicalTermsWordcloudURL?: InputMaybe<Scalars['String']['input']>;
  postID?: InputMaybe<Scalars['ID']['input']>;
  reflectableID?: InputMaybe<Scalars['Int']['input']>;
  reflectableType?: InputMaybe<Scalars['String']['input']>;
  removeCollectionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeExperimentRunIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeMessageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeScoreIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The entity this conversation was started from. Used to determine which entity to link to when displaying the conversation. */
  startedFrom?: InputMaybe<SparkyConversationStartedFrom>;
  targetConversationID?: InputMaybe<Scalars['ID']['input']>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  token?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
  videoID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateSparkyPromptInput is used for update SparkyPrompt object.
 * Input was generated by ent.
 */
export type UpdateSparkyPromptInput = {
  clearUser?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  isDefault?: InputMaybe<Scalars['Boolean']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  prompt?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateSparkyRuleConditionInput is used for update SparkyRuleCondition object.
 * Input was generated by ent.
 */
export type UpdateSparkyRuleConditionInput = {
  clearRule?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  operator?: InputMaybe<SparkyRuleConditionOperator>;
  ruleID?: InputMaybe<Scalars['ID']['input']>;
  type?: InputMaybe<SparkyRuleConditionType>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateSparkyRuleInput is used for update SparkyRule object.
 * Input was generated by ent.
 */
export type UpdateSparkyRuleInput = {
  addConditionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearConditions?: InputMaybe<Scalars['Boolean']['input']>;
  clearConfig?: InputMaybe<Scalars['Boolean']['input']>;
  clearName?: InputMaybe<Scalars['Boolean']['input']>;
  configID?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  removeConditionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * UpdateTagInput is used for update Tag object.
 * Input was generated by ent.
 */
export type UpdateTagInput = {
  addTaggedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearTaggedPosts?: InputMaybe<Scalars['Boolean']['input']>;
  /** The number of posts that have this tag. */
  count?: InputMaybe<Scalars['Int']['input']>;
  removeTaggedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The text value of the tag. */
  value?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateTopicClusterInput is used for update TopicCluster object.
 * Input was generated by ent.
 */
export type UpdateTopicClusterInput = {
  appendWords?: InputMaybe<Array<Scalars['String']['input']>>;
  clearGeneratedLabel?: InputMaybe<Scalars['Boolean']['input']>;
  clearLabel?: InputMaybe<Scalars['Boolean']['input']>;
  clearWordFrequencies?: InputMaybe<Scalars['Boolean']['input']>;
  clusterID?: InputMaybe<Scalars['Int']['input']>;
  clusterLabel?: InputMaybe<Scalars['String']['input']>;
  generatedLabel?: InputMaybe<Scalars['String']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  modelID?: InputMaybe<Scalars['String']['input']>;
  wordFrequencies?: InputMaybe<Scalars['Map']['input']>;
  words?: InputMaybe<Array<Scalars['String']['input']>>;
};

/**
 * UpdateTopicInput is used for update Topic object.
 * Input was generated by ent.
 */
export type UpdateTopicInput = {
  addArticleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addChildIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addClassificationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addNpiTaxonomyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addPubmedArticleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addPubmedTopicClusterIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  appendWords?: InputMaybe<Array<Scalars['String']['input']>>;
  clearArticles?: InputMaybe<Scalars['Boolean']['input']>;
  clearChildren?: InputMaybe<Scalars['Boolean']['input']>;
  clearClassifications?: InputMaybe<Scalars['Boolean']['input']>;
  clearClusterID?: InputMaybe<Scalars['Boolean']['input']>;
  clearClusterLabel?: InputMaybe<Scalars['Boolean']['input']>;
  clearCover?: InputMaybe<Scalars['Boolean']['input']>;
  clearCoverImage?: InputMaybe<Scalars['Boolean']['input']>;
  clearGeneratedLabel?: InputMaybe<Scalars['Boolean']['input']>;
  clearModelID?: InputMaybe<Scalars['Boolean']['input']>;
  clearModelVersion?: InputMaybe<Scalars['Boolean']['input']>;
  clearNpiTaxonomies?: InputMaybe<Scalars['Boolean']['input']>;
  clearParent?: InputMaybe<Scalars['Boolean']['input']>;
  clearPosts?: InputMaybe<Scalars['Boolean']['input']>;
  clearPubmedArticles?: InputMaybe<Scalars['Boolean']['input']>;
  clearPubmedTopicClusters?: InputMaybe<Scalars['Boolean']['input']>;
  clearTenant?: InputMaybe<Scalars['Boolean']['input']>;
  clearUsers?: InputMaybe<Scalars['Boolean']['input']>;
  clearWordFrequencies?: InputMaybe<Scalars['Boolean']['input']>;
  clearWords?: InputMaybe<Scalars['Boolean']['input']>;
  clusterID?: InputMaybe<Scalars['Int']['input']>;
  clusterLabel?: InputMaybe<Scalars['String']['input']>;
  coverID?: InputMaybe<Scalars['ID']['input']>;
  coverImageID?: InputMaybe<Scalars['ID']['input']>;
  generatedLabel?: InputMaybe<Scalars['String']['input']>;
  modelID?: InputMaybe<Scalars['String']['input']>;
  modelVersion?: InputMaybe<Scalars['String']['input']>;
  /** The name of the topic. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The ordinal of the topic. */
  ordinal?: InputMaybe<Scalars['Int']['input']>;
  parentID?: InputMaybe<Scalars['ID']['input']>;
  removeArticleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeChildIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeClassificationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeNpiTaxonomyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removePostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removePubmedArticleIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removePubmedTopicClusterIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  tenantID?: InputMaybe<Scalars['ID']['input']>;
  /** The total number of posts that are tagged with the topic. */
  totalPosts?: InputMaybe<Scalars['Int']['input']>;
  /** The trending boost of the topic. */
  trendingBoost?: InputMaybe<Scalars['Float']['input']>;
  /** The type of the topic. */
  type?: InputMaybe<TopicType>;
  wordFrequencies?: InputMaybe<Scalars['Map']['input']>;
  words?: InputMaybe<Array<Scalars['String']['input']>>;
};

/**
 * UpdateUploadInput is used for update Upload object.
 * Input was generated by ent.
 */
export type UpdateUploadInput = {
  bucket?: InputMaybe<Scalars['String']['input']>;
  clearContentType?: InputMaybe<Scalars['Boolean']['input']>;
  clearName?: InputMaybe<Scalars['Boolean']['input']>;
  clearURL?: InputMaybe<Scalars['Boolean']['input']>;
  contentType?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  key?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateUserBlockInput is used for update UserBlock object.
 * Input was generated by ent.
 */
export type UpdateUserBlockInput = {
  blockedUserID?: InputMaybe<Scalars['ID']['input']>;
  clearBlockedUser?: InputMaybe<Scalars['Boolean']['input']>;
  clearOwner?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  ownerID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateUserCohortInput is used for update UserCohort object.
 * Input was generated by ent.
 */
export type UpdateUserCohortInput = {
  addUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  clearUsers?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  removeUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  addAPITokenIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addAccountConnectionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addBlockedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addBoardCertificationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addBookmarkedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addCohortIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addCommentIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addCoursesCreatedIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addCoursesFacultyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addCoursesReviewedIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addEducationCreditIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addEducationHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addFeedHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addFollowerIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addFollowingIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addImportedVideoIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addLicenseHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addLikedCommentIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addLikedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addLinkIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addMentionedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addMutedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addNotificationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addNotificationTokenIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addOfficeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addOutgoingNotificationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addPostReportIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addReportedByIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addSearchIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addTenantIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addTopicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addUserCompletionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addUserReportIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addWorkHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  appendLimitedRoles?: InputMaybe<Array<Scalars['String']['input']>>;
  avatarID?: InputMaybe<Scalars['ID']['input']>;
  /** The bio of the user */
  bio?: InputMaybe<Scalars['String']['input']>;
  /** The city the user is located in */
  city?: InputMaybe<Scalars['String']['input']>;
  clearAPITokens?: InputMaybe<Scalars['Boolean']['input']>;
  clearAccountConnections?: InputMaybe<Scalars['Boolean']['input']>;
  clearAvatar?: InputMaybe<Scalars['Boolean']['input']>;
  clearBio?: InputMaybe<Scalars['Boolean']['input']>;
  clearBlockedUsers?: InputMaybe<Scalars['Boolean']['input']>;
  clearBoardCertifications?: InputMaybe<Scalars['Boolean']['input']>;
  clearBookmarkedPosts?: InputMaybe<Scalars['Boolean']['input']>;
  clearCity?: InputMaybe<Scalars['Boolean']['input']>;
  clearCmeGoalDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearCmeGoalValue?: InputMaybe<Scalars['Boolean']['input']>;
  clearCohorts?: InputMaybe<Scalars['Boolean']['input']>;
  clearComments?: InputMaybe<Scalars['Boolean']['input']>;
  clearCountry?: InputMaybe<Scalars['Boolean']['input']>;
  clearCoursesCreated?: InputMaybe<Scalars['Boolean']['input']>;
  clearCoursesFaculty?: InputMaybe<Scalars['Boolean']['input']>;
  clearCoursesReviewed?: InputMaybe<Scalars['Boolean']['input']>;
  clearCredential?: InputMaybe<Scalars['Boolean']['input']>;
  clearDob?: InputMaybe<Scalars['Boolean']['input']>;
  clearEducationCredits?: InputMaybe<Scalars['Boolean']['input']>;
  clearEducationHistory?: InputMaybe<Scalars['Boolean']['input']>;
  clearEmail?: InputMaybe<Scalars['Boolean']['input']>;
  clearFeed?: InputMaybe<Scalars['Boolean']['input']>;
  clearFeedHistories?: InputMaybe<Scalars['Boolean']['input']>;
  clearFinancialDisclosureStatement?: InputMaybe<Scalars['Boolean']['input']>;
  clearFinancialDisclosures?: InputMaybe<Scalars['Boolean']['input']>;
  clearFirstName?: InputMaybe<Scalars['Boolean']['input']>;
  clearFollowers?: InputMaybe<Scalars['Boolean']['input']>;
  clearFollowing?: InputMaybe<Scalars['Boolean']['input']>;
  clearImportedVideos?: InputMaybe<Scalars['Boolean']['input']>;
  clearLastLoginAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearLastName?: InputMaybe<Scalars['Boolean']['input']>;
  clearLicenseHistory?: InputMaybe<Scalars['Boolean']['input']>;
  clearLikedComments?: InputMaybe<Scalars['Boolean']['input']>;
  clearLikedPosts?: InputMaybe<Scalars['Boolean']['input']>;
  clearLimitedRoles?: InputMaybe<Scalars['Boolean']['input']>;
  clearLinks?: InputMaybe<Scalars['Boolean']['input']>;
  clearMentionedPosts?: InputMaybe<Scalars['Boolean']['input']>;
  clearMutedUsers?: InputMaybe<Scalars['Boolean']['input']>;
  clearNotificationTokens?: InputMaybe<Scalars['Boolean']['input']>;
  clearNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  clearNpiNumber?: InputMaybe<Scalars['Boolean']['input']>;
  clearNpiTaxonomyCode?: InputMaybe<Scalars['Boolean']['input']>;
  clearNpiTaxonomyDescription?: InputMaybe<Scalars['Boolean']['input']>;
  clearOffices?: InputMaybe<Scalars['Boolean']['input']>;
  clearOutgoingNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  clearPassword?: InputMaybe<Scalars['Boolean']['input']>;
  clearPhone?: InputMaybe<Scalars['Boolean']['input']>;
  clearPostReports?: InputMaybe<Scalars['Boolean']['input']>;
  clearPosts?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfessionalExperienceStartDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearProfileImage?: InputMaybe<Scalars['Boolean']['input']>;
  clearReportedBy?: InputMaybe<Scalars['Boolean']['input']>;
  clearSearches?: InputMaybe<Scalars['Boolean']['input']>;
  clearSpecialty?: InputMaybe<Scalars['Boolean']['input']>;
  clearState?: InputMaybe<Scalars['Boolean']['input']>;
  clearTenants?: InputMaybe<Scalars['Boolean']['input']>;
  clearTopics?: InputMaybe<Scalars['Boolean']['input']>;
  clearTotalCmeEarned?: InputMaybe<Scalars['Boolean']['input']>;
  clearUserCompletions?: InputMaybe<Scalars['Boolean']['input']>;
  clearUserReports?: InputMaybe<Scalars['Boolean']['input']>;
  clearUsername?: InputMaybe<Scalars['Boolean']['input']>;
  clearWorkHistory?: InputMaybe<Scalars['Boolean']['input']>;
  /** The CME goal date of the user */
  cmeGoalDate?: InputMaybe<Scalars['Time']['input']>;
  /** The CME goal value of the user */
  cmeGoalValue?: InputMaybe<Scalars['String']['input']>;
  /** The country the user is located in, as a 2 digit ISO code */
  country?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The credential of the user, ie MD, DO, PA, NP, etc. Note: Credentials are normalized to uppercase and any periods are removed. */
  credential?: InputMaybe<Scalars['String']['input']>;
  /** (Deprecated, use status instead) Whether the user is disabled */
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** The date of birth of the user */
  dob?: InputMaybe<Scalars['Time']['input']>;
  /** The email address of the user */
  email?: InputMaybe<Scalars['String']['input']>;
  feedID?: InputMaybe<Scalars['ID']['input']>;
  financialDisclosureStatementID?: InputMaybe<Scalars['ID']['input']>;
  /** The financial disclosures for the user */
  financialDisclosures?: InputMaybe<Scalars['String']['input']>;
  /** The first name of the user */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Whether the user has disclosures needing review */
  hasDisclosuresNeedingReview?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user has submitted a disclosure */
  hasSubmittedDisclosure?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user is an oog staff user */
  isStaff?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user is a student */
  isStudent?: InputMaybe<Scalars['Boolean']['input']>;
  /** The last time the user logged in */
  lastLoginAt?: InputMaybe<Scalars['Time']['input']>;
  /** The last name of the user */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** The limited roles of the user. Null or Empty array means no limited roles. */
  limitedRoles?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The NPI number of the user */
  npiNumber?: InputMaybe<Scalars['String']['input']>;
  /** The NPI taxonomy code of the user */
  npiTaxonomyCode?: InputMaybe<Scalars['String']['input']>;
  /** The NPI taxonomy description of the user */
  npiTaxonomyDescription?: InputMaybe<Scalars['String']['input']>;
  /** The password of the user, stored as a bcrypt hash */
  password?: InputMaybe<Scalars['String']['input']>;
  /** The phone number of the user, stored in E.164 format */
  phone?: InputMaybe<Scalars['String']['input']>;
  /** The start date of the professional experience of the user */
  professionalExperienceStartDate?: InputMaybe<Scalars['Time']['input']>;
  profileImageID?: InputMaybe<Scalars['ID']['input']>;
  /** Whether reflections are disabled on posts authored by this user */
  reflectionsOnAuthoredPostsDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  removeAPITokenIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeAccountConnectionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeBlockedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeBoardCertificationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeBookmarkedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeCohortIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeCommentIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeCoursesCreatedIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeCoursesFacultyIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeCoursesReviewedIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeEducationCreditIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeEducationHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeFeedHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeFollowerIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeFollowingIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeImportedVideoIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeLicenseHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeLikedCommentIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeLikedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeLinkIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeMentionedPostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeMutedUserIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeNotificationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeNotificationTokenIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeOfficeIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeOutgoingNotificationIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removePostIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removePostReportIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeReportedByIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeSearchIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeTenantIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeTopicIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeUserCompletionIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeUserReportIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeWorkHistoryIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The role of the user */
  role?: InputMaybe<UserRole>;
  specialtyID?: InputMaybe<Scalars['ID']['input']>;
  /** The state or province the user is located in, as a 2 digit ISO code */
  state?: InputMaybe<Scalars['String']['input']>;
  /** The status of the user */
  status?: InputMaybe<UserStatus>;
  /** Whether the user has should appear in the suggested users list */
  suggested?: InputMaybe<Scalars['Boolean']['input']>;
  /** Whether the user is synthetic ie. not a human user */
  synthetic?: InputMaybe<Scalars['Boolean']['input']>;
  /** The total CME earned by the user */
  totalCmeEarned?: InputMaybe<Scalars['Float']['input']>;
  /** The total number of followers the user has */
  totalFollowers?: InputMaybe<Scalars['Int']['input']>;
  /** The total number of users the user is following */
  totalFollowing?: InputMaybe<Scalars['Int']['input']>;
  /** The trending boost of the user. */
  trendingBoost?: InputMaybe<Scalars['Float']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  /** The username of the user */
  username?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateUserLinkInput is used for update UserLink object.
 * Input was generated by ent.
 */
export type UpdateUserLinkInput = {
  clearUser?: InputMaybe<Scalars['Boolean']['input']>;
  /** The ordinal of the link. */
  ordinal?: InputMaybe<Scalars['Int']['input']>;
  /** The title of the link. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** The url of the link. */
  url?: InputMaybe<Scalars['String']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateUserMuteInput is used for update UserMute object.
 * Input was generated by ent.
 */
export type UpdateUserMuteInput = {
  clearMutedUser?: InputMaybe<Scalars['Boolean']['input']>;
  clearOwner?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  mutedUserID?: InputMaybe<Scalars['ID']['input']>;
  ownerID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateUserNotificationTokenInput is used for update UserNotificationToken object.
 * Input was generated by ent.
 */
export type UpdateUserNotificationTokenInput = {
  clearUser?: InputMaybe<Scalars['Boolean']['input']>;
  /** The platform of the notification token was generated on. */
  platform?: InputMaybe<Scalars['String']['input']>;
  /** The token of the notification token. */
  token?: InputMaybe<Scalars['String']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateUserReportInput is used for update UserReport object.
 * Input was generated by ent.
 */
export type UpdateUserReportInput = {
  authorID?: InputMaybe<Scalars['ID']['input']>;
  clearAuthor?: InputMaybe<Scalars['Boolean']['input']>;
  clearDescription?: InputMaybe<Scalars['Boolean']['input']>;
  clearReportReason?: InputMaybe<Scalars['Boolean']['input']>;
  clearReportedUser?: InputMaybe<Scalars['Boolean']['input']>;
  clearReviewedAt?: InputMaybe<Scalars['Boolean']['input']>;
  clearReviewedBy?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The description of the user report */
  description?: InputMaybe<Scalars['String']['input']>;
  reportReasonID?: InputMaybe<Scalars['ID']['input']>;
  reportedUserID?: InputMaybe<Scalars['ID']['input']>;
  /** The time the report was reviewed */
  reviewedAt?: InputMaybe<Scalars['Time']['input']>;
  reviewedByID?: InputMaybe<Scalars['ID']['input']>;
};

/**
 * UpdateVerificationRequestInput is used for update VerificationRequest object.
 * Input was generated by ent.
 */
export type UpdateVerificationRequestInput = {
  clearDob?: InputMaybe<Scalars['Boolean']['input']>;
  clearZip?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  dob?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<VerificationRequestStatus>;
  storageKey?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  url?: InputMaybe<Scalars['String']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
  zip?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateVideoInput is used for update Video object.
 * Input was generated by ent.
 */
export type UpdateVideoInput = {
  addCourseIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addFaceDetectionRequestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addFrameIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addImageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addSuggestedLearningObjectiveIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  addUserVideoEventIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  appendTerms?: InputMaybe<Array<Scalars['String']['input']>>;
  clearCloudflareUploadStatus?: InputMaybe<Scalars['Boolean']['input']>;
  clearCourse?: InputMaybe<Scalars['Boolean']['input']>;
  clearDashURL?: InputMaybe<Scalars['Boolean']['input']>;
  clearDuration?: InputMaybe<Scalars['Boolean']['input']>;
  clearFaceDetectionRequest?: InputMaybe<Scalars['Boolean']['input']>;
  clearFrames?: InputMaybe<Scalars['Boolean']['input']>;
  clearGenerateInsightsStatus?: InputMaybe<Scalars['Boolean']['input']>;
  clearGoogleDriveFile?: InputMaybe<Scalars['Boolean']['input']>;
  clearHeight?: InputMaybe<Scalars['Boolean']['input']>;
  clearHlsURL?: InputMaybe<Scalars['Boolean']['input']>;
  clearImages?: InputMaybe<Scalars['Boolean']['input']>;
  clearImportedVideo?: InputMaybe<Scalars['Boolean']['input']>;
  clearLikelyAudience?: InputMaybe<Scalars['Boolean']['input']>;
  clearPost?: InputMaybe<Scalars['Boolean']['input']>;
  clearSize?: InputMaybe<Scalars['Boolean']['input']>;
  clearSpeakMediaID?: InputMaybe<Scalars['Boolean']['input']>;
  clearStorageKey?: InputMaybe<Scalars['Boolean']['input']>;
  clearSuggestedLearningObjectives?: InputMaybe<Scalars['Boolean']['input']>;
  clearTermFrequencies?: InputMaybe<Scalars['Boolean']['input']>;
  clearTerms?: InputMaybe<Scalars['Boolean']['input']>;
  clearThumbnailURL?: InputMaybe<Scalars['Boolean']['input']>;
  clearTranscodeStatus?: InputMaybe<Scalars['Boolean']['input']>;
  clearTranscribeStatus?: InputMaybe<Scalars['Boolean']['input']>;
  clearUserVideoEvents?: InputMaybe<Scalars['Boolean']['input']>;
  clearVerticalDashURL?: InputMaybe<Scalars['Boolean']['input']>;
  clearVerticalHeight?: InputMaybe<Scalars['Boolean']['input']>;
  clearVerticalHlsURL?: InputMaybe<Scalars['Boolean']['input']>;
  clearVerticalThumbnailURL?: InputMaybe<Scalars['Boolean']['input']>;
  clearVerticalUID?: InputMaybe<Scalars['Boolean']['input']>;
  clearVerticalWidth?: InputMaybe<Scalars['Boolean']['input']>;
  clearWidth?: InputMaybe<Scalars['Boolean']['input']>;
  clearWordcloud?: InputMaybe<Scalars['Boolean']['input']>;
  clearWorkflowID?: InputMaybe<Scalars['Boolean']['input']>;
  clearWorkflowRunID?: InputMaybe<Scalars['Boolean']['input']>;
  /** The processing status of the video. */
  cloudflareUploadStatus?: InputMaybe<VideoCloudflareUploadStatus>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  /** The URL of the DASH stream of the video. */
  dashURL?: InputMaybe<Scalars['String']['input']>;
  /** The duration of the video in seconds. */
  duration?: InputMaybe<Scalars['Int']['input']>;
  /** The processing status of the video. */
  generateInsightsStatus?: InputMaybe<VideoGenerateInsightsStatus>;
  googleDriveFileID?: InputMaybe<Scalars['ID']['input']>;
  /** The height of the video in pixels. */
  height?: InputMaybe<Scalars['Int']['input']>;
  /** The URL of the HLS stream of the video. */
  hlsURL?: InputMaybe<Scalars['String']['input']>;
  importedVideoID?: InputMaybe<Scalars['ID']['input']>;
  /** The likely audience for this video */
  likelyAudience?: InputMaybe<Scalars['String']['input']>;
  postID?: InputMaybe<Scalars['ID']['input']>;
  removeCourseIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeFaceDetectionRequestIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeFrameIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeImageIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeSuggestedLearningObjectiveIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  removeUserVideoEventIDs?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** The size of the video in bytes */
  size?: InputMaybe<Scalars['Int']['input']>;
  /** The media ID of the video in SpeakAI */
  speakMediaID?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the video. */
  status?: InputMaybe<VideoStatus>;
  /** The storage key of the video. */
  storageKey?: InputMaybe<Scalars['String']['input']>;
  termFrequencies?: InputMaybe<Scalars['Map']['input']>;
  terms?: InputMaybe<Array<Scalars['String']['input']>>;
  /** The number of terms per minute in the video */
  termsPerMinute?: InputMaybe<Scalars['Float']['input']>;
  /** The URL of the thumbnail image of the video. */
  thumbnailURL?: InputMaybe<Scalars['String']['input']>;
  /** The processing status of the video. */
  transcodeStatus?: InputMaybe<VideoTranscodeStatus>;
  /** The processing status of the video. */
  transcribeStatus?: InputMaybe<VideoTranscribeStatus>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  /** The vertical DASH URL of the video. */
  verticalDashURL?: InputMaybe<Scalars['String']['input']>;
  /** The vertical height of the video in pixels. */
  verticalHeight?: InputMaybe<Scalars['Int']['input']>;
  /** The vertical HLS URL of the video. */
  verticalHlsURL?: InputMaybe<Scalars['String']['input']>;
  /** The vertical thumbnail URL of the video. */
  verticalThumbnailURL?: InputMaybe<Scalars['String']['input']>;
  /** The vertical UID of the video. */
  verticalUID?: InputMaybe<Scalars['String']['input']>;
  /** The vertical width of the video in pixels. */
  verticalWidth?: InputMaybe<Scalars['Int']['input']>;
  /** The width of the video in pixels. */
  width?: InputMaybe<Scalars['Int']['input']>;
  wordcloud?: InputMaybe<Scalars['String']['input']>;
  workflowID?: InputMaybe<Scalars['String']['input']>;
  workflowRunID?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateWaitListConfigInput is used for update WaitListConfig object.
 * Input was generated by ent.
 */
export type UpdateWaitListConfigInput = {
  approvedMessage?: InputMaybe<Scalars['String']['input']>;
  clearApprovedMessage?: InputMaybe<Scalars['Boolean']['input']>;
  clearJoinedMessage?: InputMaybe<Scalars['Boolean']['input']>;
  joinedMessage?: InputMaybe<Scalars['String']['input']>;
};

/**
 * UpdateWaitlistEntryInput is used for update WaitlistEntry object.
 * Input was generated by ent.
 */
export type UpdateWaitlistEntryInput = {
  clearEmail?: InputMaybe<Scalars['Boolean']['input']>;
  clearNpiNumber?: InputMaybe<Scalars['Boolean']['input']>;
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** The NPI number for this entry */
  npiNumber?: InputMaybe<Scalars['String']['input']>;
  /** The phone number for this entry, stored in E.164 format. */
  phone?: InputMaybe<Scalars['String']['input']>;
  /** The status of the entry */
  status?: InputMaybe<WaitlistEntryStatus>;
  /** The total number of NPI results found */
  totalNpiResults?: InputMaybe<Scalars['Int']['input']>;
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
};

/**
 * UpdateWorkExperienceInput is used for update WorkExperience object.
 * Input was generated by ent.
 */
export type UpdateWorkExperienceInput = {
  /** The city of the work experience. */
  city?: InputMaybe<Scalars['String']['input']>;
  clearEndDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearStartDate?: InputMaybe<Scalars['Boolean']['input']>;
  clearUser?: InputMaybe<Scalars['Boolean']['input']>;
  /** The employment type of the work experience. */
  employment?: InputMaybe<WorkExperienceEmployment>;
  /** The end date of the work experience. */
  endDate?: InputMaybe<Scalars['Time']['input']>;
  /** The institution of the work experience. */
  institution?: InputMaybe<Scalars['String']['input']>;
  /** The specialty of the work experience. */
  specialty?: InputMaybe<Scalars['String']['input']>;
  /** The start date of the work experience. */
  startDate?: InputMaybe<Scalars['Time']['input']>;
  /** The state of the work experience. */
  state?: InputMaybe<Scalars['String']['input']>;
  /** The title of the work experience. */
  title?: InputMaybe<Scalars['String']['input']>;
  userID?: InputMaybe<Scalars['ID']['input']>;
};

export type Upload = Node & {
  __typename?: 'Upload';
  bucket: Scalars['String']['output'];
  contentType?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  name?: Maybe<Scalars['String']['output']>;
  updatedAt: Scalars['Time']['output'];
  url?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of items. */
export type UploadConnection = {
  __typename?: 'UploadConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UploadEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UploadEdge = {
  __typename?: 'UploadEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Upload>;
};

/** Ordering options for Upload connections */
export type UploadOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Uploads. */
  field: UploadOrderField;
};

/** Properties by which Upload connections can be ordered. */
export enum UploadOrderField {
  CreatedAt = 'CREATED_AT',
  Name = 'NAME'
}

/**
 * UploadWhereInput is used for filtering Upload objects.
 * Input was generated by ent.
 */
export type UploadWhereInput = {
  and?: InputMaybe<Array<UploadWhereInput>>;
  /** bucket field predicates */
  bucket?: InputMaybe<Scalars['String']['input']>;
  bucketContains?: InputMaybe<Scalars['String']['input']>;
  bucketContainsFold?: InputMaybe<Scalars['String']['input']>;
  bucketEqualFold?: InputMaybe<Scalars['String']['input']>;
  bucketGT?: InputMaybe<Scalars['String']['input']>;
  bucketGTE?: InputMaybe<Scalars['String']['input']>;
  bucketHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bucketHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bucketIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bucketLT?: InputMaybe<Scalars['String']['input']>;
  bucketLTE?: InputMaybe<Scalars['String']['input']>;
  bucketNEQ?: InputMaybe<Scalars['String']['input']>;
  bucketNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** content_type field predicates */
  contentType?: InputMaybe<Scalars['String']['input']>;
  contentTypeContains?: InputMaybe<Scalars['String']['input']>;
  contentTypeContainsFold?: InputMaybe<Scalars['String']['input']>;
  contentTypeEqualFold?: InputMaybe<Scalars['String']['input']>;
  contentTypeGT?: InputMaybe<Scalars['String']['input']>;
  contentTypeGTE?: InputMaybe<Scalars['String']['input']>;
  contentTypeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  contentTypeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  contentTypeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contentTypeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  contentTypeLT?: InputMaybe<Scalars['String']['input']>;
  contentTypeLTE?: InputMaybe<Scalars['String']['input']>;
  contentTypeNEQ?: InputMaybe<Scalars['String']['input']>;
  contentTypeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contentTypeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** key field predicates */
  key?: InputMaybe<Scalars['String']['input']>;
  keyContains?: InputMaybe<Scalars['String']['input']>;
  keyContainsFold?: InputMaybe<Scalars['String']['input']>;
  keyEqualFold?: InputMaybe<Scalars['String']['input']>;
  keyGT?: InputMaybe<Scalars['String']['input']>;
  keyGTE?: InputMaybe<Scalars['String']['input']>;
  keyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  keyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  keyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  keyLT?: InputMaybe<Scalars['String']['input']>;
  keyLTE?: InputMaybe<Scalars['String']['input']>;
  keyNEQ?: InputMaybe<Scalars['String']['input']>;
  keyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<UploadWhereInput>;
  or?: InputMaybe<Array<UploadWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']['input']>;
  urlContains?: InputMaybe<Scalars['String']['input']>;
  urlContainsFold?: InputMaybe<Scalars['String']['input']>;
  urlEqualFold?: InputMaybe<Scalars['String']['input']>;
  urlGT?: InputMaybe<Scalars['String']['input']>;
  urlGTE?: InputMaybe<Scalars['String']['input']>;
  urlHasPrefix?: InputMaybe<Scalars['String']['input']>;
  urlHasSuffix?: InputMaybe<Scalars['String']['input']>;
  urlIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  urlLT?: InputMaybe<Scalars['String']['input']>;
  urlLTE?: InputMaybe<Scalars['String']['input']>;
  urlNEQ?: InputMaybe<Scalars['String']['input']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type UpsertPollQuestionInput = {
  /** The id of the question. If not provided, a new question will be created. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The question to ask the user. */
  question?: InputMaybe<Scalars['String']['input']>;
  totalVotes?: InputMaybe<Scalars['Int']['input']>;
};

export type UpsertPostCitationInput = {
  /** The id of the citation. If not provided, a new citation will be created. */
  id?: InputMaybe<Scalars['ID']['input']>;
  /** The name of the citation. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** The url of the citation. */
  url?: InputMaybe<Scalars['String']['input']>;
};

export type User = Node & {
  __typename?: 'User';
  /** 3rd party account connections */
  accountConnections?: Maybe<Array<AccountConnection>>;
  /** The API tokens the user has generated */
  apiTokens?: Maybe<Array<ApiToken>>;
  /** (DEPRECATED) The avatar of the user */
  avatar?: Maybe<MediaItem>;
  /** The bio of the user */
  bio?: Maybe<Scalars['String']['output']>;
  /** The users this user has blocked */
  blockedUsers?: Maybe<Array<UserBlock>>;
  boardCertifications?: Maybe<Array<BoardCertification>>;
  /** The posts the user has bookmarked */
  bookmarkedPosts?: Maybe<Array<Post>>;
  bookmarks?: Maybe<Array<Bookmark>>;
  /** The city the user is located in */
  city?: Maybe<Scalars['String']['output']>;
  /** The CME goal date of the user */
  cmeGoalDate?: Maybe<Scalars['Time']['output']>;
  /** The CME goal value of the user */
  cmeGoalValue?: Maybe<Scalars['String']['output']>;
  cohorts?: Maybe<Array<UserCohort>>;
  commentLikes?: Maybe<Array<CommentLike>>;
  /** The comments the user has made */
  comments?: Maybe<Array<Comment>>;
  /** The country the user is located in, as a 2 digit ISO code */
  country?: Maybe<Scalars['String']['output']>;
  /** The courses the user has created */
  coursesCreated?: Maybe<Array<Course>>;
  /** The courses the user is faculty for */
  coursesFaculty?: Maybe<Array<Course>>;
  /** The courses the user has reviewed */
  coursesReviewed?: Maybe<Array<Course>>;
  createdAt: Scalars['Time']['output'];
  /** The credential of the user, ie MD, DO, PA, NP, etc. Note: Credentials are normalized to uppercase and any periods are removed. */
  credential?: Maybe<Scalars['String']['output']>;
  currentTenant?: Maybe<Tenant>;
  /** (Deprecated, use status instead) Whether the user is disabled */
  disabled: Scalars['Boolean']['output'];
  /** The date of birth of the user */
  dob?: Maybe<Scalars['Time']['output']>;
  /** The education credits of the user */
  educationCredits?: Maybe<Array<EducationCredit>>;
  /** The education history of the user */
  educationHistory?: Maybe<Array<EducationHistory>>;
  /** The email address of the user */
  email?: Maybe<Scalars['String']['output']>;
  /** If set, this user is synthetic and has a feed */
  feed?: Maybe<ArticleFeed>;
  feedHistories?: Maybe<Array<UserFeedHistory>>;
  /** The financial disclosures for the user */
  financialDisclosureStatement?: Maybe<FinancialDisclosureStatement>;
  /** The financial disclosures for the user */
  financialDisclosures?: Maybe<Scalars['String']['output']>;
  /** The first name of the user */
  firstName?: Maybe<Scalars['String']['output']>;
  /** The users that follow this user */
  followers?: Maybe<Array<User>>;
  following?: Maybe<Array<User>>;
  /** Whether the user has disclosures needing review */
  hasDisclosuresNeedingReview: Scalars['Boolean']['output'];
  /** Whether the user has submitted a disclosure */
  hasSubmittedDisclosure: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  /** The imported videos for the user */
  importedVideos?: Maybe<Array<ImportedVideo>>;
  /** Whether the user is an oog staff user */
  isStaff: Scalars['Boolean']['output'];
  /** Whether the user is a student */
  isStudent: Scalars['Boolean']['output'];
  /** The last time the user logged in */
  lastLoginAt?: Maybe<Scalars['Time']['output']>;
  /** The last name of the user */
  lastName?: Maybe<Scalars['String']['output']>;
  /** The license history of the user */
  licenseHistory?: Maybe<Array<LicenseHistory>>;
  /** The comments the user has liked */
  likedComments?: Maybe<Array<Comment>>;
  /** The posts the user has liked */
  likedPosts?: Maybe<Array<Post>>;
  likes?: Maybe<Array<Like>>;
  /** The limited roles of the user. Null or Empty array means no limited roles. */
  limitedRoles?: Maybe<Array<Scalars['String']['output']>>;
  /** The links the user has added */
  links?: Maybe<Array<UserLink>>;
  /** The posts the user has been mentioned in */
  mentionedPosts?: Maybe<Array<Post>>;
  /** The users this user has muted */
  mutedUsers?: Maybe<Array<UserMute>>;
  /** The notification tokens for the user */
  notificationTokens?: Maybe<Array<UserNotificationToken>>;
  /** The notifications for the user: Likes, Comments, etc. */
  notifications?: Maybe<Array<Notification>>;
  /** The NPI number of the user */
  npiNumber?: Maybe<Scalars['String']['output']>;
  npiTaxonomy?: Maybe<NpiTaxonomy>;
  /** The NPI taxonomy code of the user */
  npiTaxonomyCode?: Maybe<Scalars['String']['output']>;
  /** The NPI taxonomy description of the user */
  npiTaxonomyDescription?: Maybe<Scalars['String']['output']>;
  /** The providers offices */
  offices?: Maybe<Array<Office>>;
  /** The notifications the user has generated for other users */
  outgoingNotifications?: Maybe<Array<Notification>>;
  /** The phone number of the user, stored in E.164 format */
  phone?: Maybe<Scalars['String']['output']>;
  /** The post reports this user has created */
  postReports?: Maybe<Array<PostReport>>;
  /** The posts the user has made */
  posts?: Maybe<Array<Post>>;
  /** The start date of the professional experience of the user */
  professionalExperienceStartDate?: Maybe<Scalars['Time']['output']>;
  /** The profile image for the user. Images are hosted using Cloudflare images. Please see https://developers.cloudflare.com/images/cloudflare-images/serve-images/ for details on how to serve images. */
  profileImage?: Maybe<Image>;
  /** Whether reflections are disabled on posts authored by this user */
  reflectionsOnAuthoredPostsDisabled: Scalars['Boolean']['output'];
  /** The user reports this user has been reported by */
  reportedBy?: Maybe<Array<UserReport>>;
  /** The role of the user */
  role: UserRole;
  /** The searches the user has made */
  searches?: Maybe<Array<Search>>;
  shareURL?: Maybe<Scalars['String']['output']>;
  /** The NPI taxonomy of the user */
  specialty?: Maybe<NpiTaxonomy>;
  /** The state or province the user is located in, as a 2 digit ISO code */
  state?: Maybe<Scalars['String']['output']>;
  /** The status of the user */
  status: UserStatus;
  /** The Stream (getstream.io) chat token for the current user */
  streamToken: Scalars['String']['output'];
  /** Whether the user has should appear in the suggested users list */
  suggested: Scalars['Boolean']['output'];
  /** Whether the user is synthetic ie. not a human user */
  synthetic: Scalars['Boolean']['output'];
  /** The tenants the user belongs to */
  tenants?: Maybe<Array<Tenant>>;
  /** The topics the user follows */
  topics?: Maybe<Array<Topic>>;
  /** The total CME earned by the user */
  totalCmeEarned?: Maybe<Scalars['Float']['output']>;
  /** The total number of followers the user has */
  totalFollowers: Scalars['Int']['output'];
  /** The total number of users the user is following */
  totalFollowing: Scalars['Int']['output'];
  /** The trending boost of the user. */
  trendingBoost: Scalars['Float']['output'];
  updatedAt: Scalars['Time']['output'];
  /** The user collection completions */
  userCompletions?: Maybe<Array<UserCollectionCompletion>>;
  /** The user reports this user has created */
  userReports?: Maybe<Array<UserReport>>;
  userTenants?: Maybe<Array<UserTenant>>;
  /** The username of the user */
  username?: Maybe<Scalars['String']['output']>;
  /** The work history of the user */
  workHistory?: Maybe<Array<WorkExperience>>;
};

export type UserActivitySummary = {
  __typename?: 'UserActivitySummary';
  /** The total CE earned on posts the user has created */
  totalCEEarnedOnContent: Scalars['Float']['output'];
  /** The total number of comments on posts the user has created */
  totalCommentsOnContent: Scalars['Int']['output'];
  /** The total number of posts the current user has liked */
  totalLikes: Scalars['Int']['output'];
  /** The total number of likes on posts the user has created */
  totalLikesOnContent: Scalars['Int']['output'];
  /** The total number of views on posts the user has created */
  totalPostViewsOnContent: Scalars['Int']['output'];
  /** The total number of posts the current user has saved */
  totalSaves: Scalars['Int']['output'];
  /** The total number of bookmarked posts, on posts the user has created */
  totalSavesOnContent: Scalars['Int']['output'];
};

export type UserAnalyticsEvent = Node & {
  __typename?: 'UserAnalyticsEvent';
  createdAt: Scalars['Time']['output'];
  entityID: Scalars['Int']['output'];
  entityName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  /** The user who created this event */
  user?: Maybe<User>;
};

/**
 * UserAnalyticsEventWhereInput is used for filtering UserAnalyticsEvent objects.
 * Input was generated by ent.
 */
export type UserAnalyticsEventWhereInput = {
  and?: InputMaybe<Array<UserAnalyticsEventWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** entity_id field predicates */
  entityID?: InputMaybe<Scalars['Int']['input']>;
  entityIDGT?: InputMaybe<Scalars['Int']['input']>;
  entityIDGTE?: InputMaybe<Scalars['Int']['input']>;
  entityIDIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  entityIDLT?: InputMaybe<Scalars['Int']['input']>;
  entityIDLTE?: InputMaybe<Scalars['Int']['input']>;
  entityIDNEQ?: InputMaybe<Scalars['Int']['input']>;
  entityIDNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** entity_name field predicates */
  entityName?: InputMaybe<Scalars['String']['input']>;
  entityNameContains?: InputMaybe<Scalars['String']['input']>;
  entityNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  entityNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  entityNameGT?: InputMaybe<Scalars['String']['input']>;
  entityNameGTE?: InputMaybe<Scalars['String']['input']>;
  entityNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  entityNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  entityNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  entityNameLT?: InputMaybe<Scalars['String']['input']>;
  entityNameLTE?: InputMaybe<Scalars['String']['input']>;
  entityNameNEQ?: InputMaybe<Scalars['String']['input']>;
  entityNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<UserAnalyticsEventWhereInput>;
  or?: InputMaybe<Array<UserAnalyticsEventWhereInput>>;
};

export type UserAuditHistoryItem = {
  __typename?: 'UserAuditHistoryItem';
  action: Scalars['String']['output'];
  createdAt: Scalars['Time']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  post?: Maybe<Post>;
  user: User;
};

export type UserBlock = Node & {
  __typename?: 'UserBlock';
  blockedUser?: Maybe<User>;
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  owner?: Maybe<User>;
};

/** A connection to a list of items. */
export type UserBlockConnection = {
  __typename?: 'UserBlockConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserBlockEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserBlockEdge = {
  __typename?: 'UserBlockEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserBlock>;
};

/** Ordering options for UserBlock connections */
export type UserBlockOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order UserBlocks. */
  field: UserBlockOrderField;
};

/** Properties by which UserBlock connections can be ordered. */
export enum UserBlockOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * UserBlockWhereInput is used for filtering UserBlock objects.
 * Input was generated by ent.
 */
export type UserBlockWhereInput = {
  and?: InputMaybe<Array<UserBlockWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** blocked_user edge predicates */
  hasBlockedUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasBlockedUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** owner edge predicates */
  hasOwner?: InputMaybe<Scalars['Boolean']['input']>;
  hasOwnerWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<UserBlockWhereInput>;
  or?: InputMaybe<Array<UserBlockWhereInput>>;
};

export type UserCohort = Node & {
  __typename?: 'UserCohort';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  users?: Maybe<Array<User>>;
};

/** A connection to a list of items. */
export type UserCohortConnection = {
  __typename?: 'UserCohortConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserCohortEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserCohortEdge = {
  __typename?: 'UserCohortEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserCohort>;
};

/**
 * UserCohortWhereInput is used for filtering UserCohort objects.
 * Input was generated by ent.
 */
export type UserCohortWhereInput = {
  and?: InputMaybe<Array<UserCohortWhereInput>>;
  /** users edge predicates */
  hasUsers?: InputMaybe<Scalars['Boolean']['input']>;
  hasUsersWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<UserCohortWhereInput>;
  or?: InputMaybe<Array<UserCohortWhereInput>>;
};

export type UserCollectionCompletion = Node & {
  __typename?: 'UserCollectionCompletion';
  /** The collection that the user completed. */
  collection: Collection;
  /** The collection that the user completed. */
  collectionID: Scalars['ID']['output'];
  /** The time that the user completed the collection. */
  completedAt?: Maybe<Scalars['Time']['output']>;
  educationCredit?: Maybe<EducationCredit>;
  id: Scalars['ID']['output'];
  /** The user that completed the collection. */
  user: User;
  /** The user that completed the collection. */
  userID: Scalars['ID']['output'];
};

/** A connection to a list of items. */
export type UserCollectionCompletionConnection = {
  __typename?: 'UserCollectionCompletionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserCollectionCompletionEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserCollectionCompletionEdge = {
  __typename?: 'UserCollectionCompletionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserCollectionCompletion>;
};

/**
 * UserCollectionCompletionWhereInput is used for filtering UserCollectionCompletion objects.
 * Input was generated by ent.
 */
export type UserCollectionCompletionWhereInput = {
  and?: InputMaybe<Array<UserCollectionCompletionWhereInput>>;
  /** collection_id field predicates */
  collectionID?: InputMaybe<Scalars['ID']['input']>;
  collectionIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  collectionIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  collectionIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** completed_at field predicates */
  completedAt?: InputMaybe<Scalars['Time']['input']>;
  completedAtGT?: InputMaybe<Scalars['Time']['input']>;
  completedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  completedAtLT?: InputMaybe<Scalars['Time']['input']>;
  completedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  completedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  completedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  completedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** collection edge predicates */
  hasCollection?: InputMaybe<Scalars['Boolean']['input']>;
  hasCollectionWith?: InputMaybe<Array<CollectionWhereInput>>;
  /** education_credit edge predicates */
  hasEducationCredit?: InputMaybe<Scalars['Boolean']['input']>;
  hasEducationCreditWith?: InputMaybe<Array<EducationCreditWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<UserCollectionCompletionWhereInput>;
  or?: InputMaybe<Array<UserCollectionCompletionWhereInput>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/** A connection to a list of items. */
export type UserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

export type UserFeedHistory = Node & {
  __typename?: 'UserFeedHistory';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  post: Post;
  postID: Scalars['ID']['output'];
  user: User;
  userID: Scalars['ID']['output'];
};

/**
 * UserFeedHistoryWhereInput is used for filtering UserFeedHistory objects.
 * Input was generated by ent.
 */
export type UserFeedHistoryWhereInput = {
  and?: InputMaybe<Array<UserFeedHistoryWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<UserFeedHistoryWhereInput>;
  or?: InputMaybe<Array<UserFeedHistoryWhereInput>>;
  /** post_id field predicates */
  postID?: InputMaybe<Scalars['ID']['input']>;
  postIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  postIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  postIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

export type UserLink = Node & {
  __typename?: 'UserLink';
  id: Scalars['ID']['output'];
  /** The ordinal of the link. */
  ordinal: Scalars['Int']['output'];
  /** The title of the link. */
  title: Scalars['String']['output'];
  /** The url of the link. */
  url: Scalars['String']['output'];
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type UserLinkConnection = {
  __typename?: 'UserLinkConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserLinkEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserLinkEdge = {
  __typename?: 'UserLinkEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserLink>;
};

/**
 * UserLinkWhereInput is used for filtering UserLink objects.
 * Input was generated by ent.
 */
export type UserLinkWhereInput = {
  and?: InputMaybe<Array<UserLinkWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<UserLinkWhereInput>;
  or?: InputMaybe<Array<UserLinkWhereInput>>;
  /** ordinal field predicates */
  ordinal?: InputMaybe<Scalars['Int']['input']>;
  ordinalGT?: InputMaybe<Scalars['Int']['input']>;
  ordinalGTE?: InputMaybe<Scalars['Int']['input']>;
  ordinalIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  ordinalLT?: InputMaybe<Scalars['Int']['input']>;
  ordinalLTE?: InputMaybe<Scalars['Int']['input']>;
  ordinalNEQ?: InputMaybe<Scalars['Int']['input']>;
  ordinalNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']['input']>;
  urlContains?: InputMaybe<Scalars['String']['input']>;
  urlContainsFold?: InputMaybe<Scalars['String']['input']>;
  urlEqualFold?: InputMaybe<Scalars['String']['input']>;
  urlGT?: InputMaybe<Scalars['String']['input']>;
  urlGTE?: InputMaybe<Scalars['String']['input']>;
  urlHasPrefix?: InputMaybe<Scalars['String']['input']>;
  urlHasSuffix?: InputMaybe<Scalars['String']['input']>;
  urlIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlLT?: InputMaybe<Scalars['String']['input']>;
  urlLTE?: InputMaybe<Scalars['String']['input']>;
  urlNEQ?: InputMaybe<Scalars['String']['input']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type UserMute = Node & {
  __typename?: 'UserMute';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  mutedUser?: Maybe<User>;
  owner?: Maybe<User>;
};

/** A connection to a list of items. */
export type UserMuteConnection = {
  __typename?: 'UserMuteConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserMuteEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserMuteEdge = {
  __typename?: 'UserMuteEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserMute>;
};

/** Ordering options for UserMute connections */
export type UserMuteOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order UserMutes. */
  field: UserMuteOrderField;
};

/** Properties by which UserMute connections can be ordered. */
export enum UserMuteOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * UserMuteWhereInput is used for filtering UserMute objects.
 * Input was generated by ent.
 */
export type UserMuteWhereInput = {
  and?: InputMaybe<Array<UserMuteWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** muted_user edge predicates */
  hasMutedUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasMutedUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** owner edge predicates */
  hasOwner?: InputMaybe<Scalars['Boolean']['input']>;
  hasOwnerWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<UserMuteWhereInput>;
  or?: InputMaybe<Array<UserMuteWhereInput>>;
};

export type UserNotificationToken = Node & {
  __typename?: 'UserNotificationToken';
  id: Scalars['ID']['output'];
  /** The platform of the notification token was generated on. */
  platform: Scalars['String']['output'];
  /** The token of the notification token. */
  token: Scalars['String']['output'];
  /** The user that the notification token is for. */
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type UserNotificationTokenConnection = {
  __typename?: 'UserNotificationTokenConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserNotificationTokenEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserNotificationTokenEdge = {
  __typename?: 'UserNotificationTokenEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserNotificationToken>;
};

/**
 * UserNotificationTokenWhereInput is used for filtering UserNotificationToken objects.
 * Input was generated by ent.
 */
export type UserNotificationTokenWhereInput = {
  and?: InputMaybe<Array<UserNotificationTokenWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<UserNotificationTokenWhereInput>;
  or?: InputMaybe<Array<UserNotificationTokenWhereInput>>;
  /** platform field predicates */
  platform?: InputMaybe<Scalars['String']['input']>;
  platformContains?: InputMaybe<Scalars['String']['input']>;
  platformContainsFold?: InputMaybe<Scalars['String']['input']>;
  platformEqualFold?: InputMaybe<Scalars['String']['input']>;
  platformGT?: InputMaybe<Scalars['String']['input']>;
  platformGTE?: InputMaybe<Scalars['String']['input']>;
  platformHasPrefix?: InputMaybe<Scalars['String']['input']>;
  platformHasSuffix?: InputMaybe<Scalars['String']['input']>;
  platformIn?: InputMaybe<Array<Scalars['String']['input']>>;
  platformLT?: InputMaybe<Scalars['String']['input']>;
  platformLTE?: InputMaybe<Scalars['String']['input']>;
  platformNEQ?: InputMaybe<Scalars['String']['input']>;
  platformNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** token field predicates */
  token?: InputMaybe<Scalars['String']['input']>;
  tokenContains?: InputMaybe<Scalars['String']['input']>;
  tokenContainsFold?: InputMaybe<Scalars['String']['input']>;
  tokenEqualFold?: InputMaybe<Scalars['String']['input']>;
  tokenGT?: InputMaybe<Scalars['String']['input']>;
  tokenGTE?: InputMaybe<Scalars['String']['input']>;
  tokenHasPrefix?: InputMaybe<Scalars['String']['input']>;
  tokenHasSuffix?: InputMaybe<Scalars['String']['input']>;
  tokenIn?: InputMaybe<Array<Scalars['String']['input']>>;
  tokenLT?: InputMaybe<Scalars['String']['input']>;
  tokenLTE?: InputMaybe<Scalars['String']['input']>;
  tokenNEQ?: InputMaybe<Scalars['String']['input']>;
  tokenNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** Ordering options for User connections */
export type UserOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Users. */
  field: UserOrderField;
};

/** Properties by which User connections can be ordered. */
export enum UserOrderField {
  CreatedAt = 'CREATED_AT',
  Email = 'EMAIL',
  FirstName = 'FIRST_NAME',
  LastLoginAt = 'LAST_LOGIN_AT',
  LastName = 'LAST_NAME',
  Phone = 'PHONE',
  TotalCmeEarned = 'TOTAL_CME_EARNED',
  TotalFollowers = 'TOTAL_FOLLOWERS',
  TotalFollowing = 'TOTAL_FOLLOWING',
  TrendingBoost = 'TRENDING_BOOST',
  UpdatedAt = 'UPDATED_AT',
  Username = 'USERNAME'
}

export type UserRelationship = {
  __typename?: 'UserRelationship';
  follower: Scalars['Boolean']['output'];
  following: Scalars['Boolean']['output'];
};

export type UserReport = Node & {
  __typename?: 'UserReport';
  /** The author of the user report */
  author?: Maybe<User>;
  createdAt: Scalars['Time']['output'];
  /** The description of the user report */
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  /** The reason for the user report */
  reportReason?: Maybe<ReportReason>;
  /** The user that was reported */
  reportedUser?: Maybe<User>;
  /** The time the report was reviewed */
  reviewedAt?: Maybe<Scalars['Time']['output']>;
  /** The admin user that reviewed the report */
  reviewedBy?: Maybe<User>;
};

/** A connection to a list of items. */
export type UserReportConnection = {
  __typename?: 'UserReportConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserReportEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type UserReportEdge = {
  __typename?: 'UserReportEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<UserReport>;
};

/** Ordering options for UserReport connections */
export type UserReportOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order UserReports. */
  field: UserReportOrderField;
};

/** Properties by which UserReport connections can be ordered. */
export enum UserReportOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * UserReportWhereInput is used for filtering UserReport objects.
 * Input was generated by ent.
 */
export type UserReportWhereInput = {
  and?: InputMaybe<Array<UserReportWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']['input']>;
  descriptionContains?: InputMaybe<Scalars['String']['input']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  descriptionGT?: InputMaybe<Scalars['String']['input']>;
  descriptionGTE?: InputMaybe<Scalars['String']['input']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  descriptionLT?: InputMaybe<Scalars['String']['input']>;
  descriptionLTE?: InputMaybe<Scalars['String']['input']>;
  descriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** author edge predicates */
  hasAuthor?: InputMaybe<Scalars['Boolean']['input']>;
  hasAuthorWith?: InputMaybe<Array<UserWhereInput>>;
  /** report_reason edge predicates */
  hasReportReason?: InputMaybe<Scalars['Boolean']['input']>;
  hasReportReasonWith?: InputMaybe<Array<ReportReasonWhereInput>>;
  /** reported_user edge predicates */
  hasReportedUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasReportedUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** reviewed_by edge predicates */
  hasReviewedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasReviewedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<UserReportWhereInput>;
  or?: InputMaybe<Array<UserReportWhereInput>>;
  /** reviewed_at field predicates */
  reviewedAt?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtGT?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  reviewedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  reviewedAtLT?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  reviewedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  reviewedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

/** UserRole is enum for the field role */
export enum UserRole {
  Admin = 'admin',
  User = 'user'
}

export type UserSearchConnection = {
  __typename?: 'UserSearchConnection';
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /**
   * The locations present in the search results.
   * Location is determined by the value of the state_code in the user's office list.
   * Note: A user can therefore have multiple locations.
   */
  locations?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** The highest years of experience present in the search results. */
  maxYearsOfExperience?: Maybe<Scalars['Int']['output']>;
  /** The lowest years of experience present in the search results. */
  minYearsOfExperience?: Maybe<Scalars['Int']['output']>;
  /**
   * The organizations present in the search results.
   * The organizations are determined by the value of the Institution in the user's work history.
   * Note: A user can therefore have multiple organizations.
   * Note: The organization might be from a work history that is no longer active.
   */
  organizations?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  pageInfo: PageInfo;
  /** The Specialties that are present in the search results. */
  specialties?: Maybe<Array<Maybe<NpiTaxonomy>>>;
  totalCount: Scalars['Int']['output'];
};

export type UserSearchResult = {
  __typename?: 'UserSearchResult';
  firstName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  profileImage?: Maybe<SearchResultImage>;
  totalFollowers: Scalars['Int']['output'];
  totalFollowing: Scalars['Int']['output'];
  username: Scalars['String']['output'];
};

/** UserStatus is enum for the field status */
export enum UserStatus {
  Active = 'active',
  Deleted = 'deleted',
  Denied = 'denied',
  Disabled = 'disabled',
  Pending = 'pending'
}

export type UserTenant = Node & {
  __typename?: 'UserTenant';
  /** The time that the user liked the post. */
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  /** The post that the user liked. */
  tenant: Tenant;
  tenantID: Scalars['ID']['output'];
  /** The user that created the like. */
  user: User;
  userID: Scalars['ID']['output'];
};

/**
 * UserTenantWhereInput is used for filtering UserTenant objects.
 * Input was generated by ent.
 */
export type UserTenantWhereInput = {
  and?: InputMaybe<Array<UserTenantWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<UserTenantWhereInput>;
  or?: InputMaybe<Array<UserTenantWhereInput>>;
};

export type UserVideoEvent = Node & {
  __typename?: 'UserVideoEvent';
  createdAt: Scalars['Time']['output'];
  eventType: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  user: User;
  userID: Scalars['ID']['output'];
  video: Video;
  videoID: Scalars['ID']['output'];
};

/**
 * UserVideoEventWhereInput is used for filtering UserVideoEvent objects.
 * Input was generated by ent.
 */
export type UserVideoEventWhereInput = {
  and?: InputMaybe<Array<UserVideoEventWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** event_type field predicates */
  eventType?: InputMaybe<Scalars['String']['input']>;
  eventTypeContains?: InputMaybe<Scalars['String']['input']>;
  eventTypeContainsFold?: InputMaybe<Scalars['String']['input']>;
  eventTypeEqualFold?: InputMaybe<Scalars['String']['input']>;
  eventTypeGT?: InputMaybe<Scalars['String']['input']>;
  eventTypeGTE?: InputMaybe<Scalars['String']['input']>;
  eventTypeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  eventTypeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  eventTypeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  eventTypeLT?: InputMaybe<Scalars['String']['input']>;
  eventTypeLTE?: InputMaybe<Scalars['String']['input']>;
  eventTypeNEQ?: InputMaybe<Scalars['String']['input']>;
  eventTypeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** video edge predicates */
  hasVideo?: InputMaybe<Scalars['Boolean']['input']>;
  hasVideoWith?: InputMaybe<Array<VideoWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<UserVideoEventWhereInput>;
  or?: InputMaybe<Array<UserVideoEventWhereInput>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']['input']>;
  userIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  userIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  userIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** video_id field predicates */
  videoID?: InputMaybe<Scalars['ID']['input']>;
  videoIDIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  videoIDNEQ?: InputMaybe<Scalars['ID']['input']>;
  videoIDNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
};

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** bio field predicates */
  bio?: InputMaybe<Scalars['String']['input']>;
  bioContains?: InputMaybe<Scalars['String']['input']>;
  bioContainsFold?: InputMaybe<Scalars['String']['input']>;
  bioEqualFold?: InputMaybe<Scalars['String']['input']>;
  bioGT?: InputMaybe<Scalars['String']['input']>;
  bioGTE?: InputMaybe<Scalars['String']['input']>;
  bioHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bioHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bioIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bioIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bioLT?: InputMaybe<Scalars['String']['input']>;
  bioLTE?: InputMaybe<Scalars['String']['input']>;
  bioNEQ?: InputMaybe<Scalars['String']['input']>;
  bioNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bioNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** city field predicates */
  city?: InputMaybe<Scalars['String']['input']>;
  cityContains?: InputMaybe<Scalars['String']['input']>;
  cityContainsFold?: InputMaybe<Scalars['String']['input']>;
  cityEqualFold?: InputMaybe<Scalars['String']['input']>;
  cityGT?: InputMaybe<Scalars['String']['input']>;
  cityGTE?: InputMaybe<Scalars['String']['input']>;
  cityHasPrefix?: InputMaybe<Scalars['String']['input']>;
  cityHasSuffix?: InputMaybe<Scalars['String']['input']>;
  cityIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cityIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  cityLT?: InputMaybe<Scalars['String']['input']>;
  cityLTE?: InputMaybe<Scalars['String']['input']>;
  cityNEQ?: InputMaybe<Scalars['String']['input']>;
  cityNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cityNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** cme_goal_date field predicates */
  cmeGoalDate?: InputMaybe<Scalars['Time']['input']>;
  cmeGoalDateGT?: InputMaybe<Scalars['Time']['input']>;
  cmeGoalDateGTE?: InputMaybe<Scalars['Time']['input']>;
  cmeGoalDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  cmeGoalDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  cmeGoalDateLT?: InputMaybe<Scalars['Time']['input']>;
  cmeGoalDateLTE?: InputMaybe<Scalars['Time']['input']>;
  cmeGoalDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  cmeGoalDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  cmeGoalDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** cme_goal_value field predicates */
  cmeGoalValue?: InputMaybe<Scalars['String']['input']>;
  cmeGoalValueContains?: InputMaybe<Scalars['String']['input']>;
  cmeGoalValueContainsFold?: InputMaybe<Scalars['String']['input']>;
  cmeGoalValueEqualFold?: InputMaybe<Scalars['String']['input']>;
  cmeGoalValueGT?: InputMaybe<Scalars['String']['input']>;
  cmeGoalValueGTE?: InputMaybe<Scalars['String']['input']>;
  cmeGoalValueHasPrefix?: InputMaybe<Scalars['String']['input']>;
  cmeGoalValueHasSuffix?: InputMaybe<Scalars['String']['input']>;
  cmeGoalValueIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cmeGoalValueIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  cmeGoalValueLT?: InputMaybe<Scalars['String']['input']>;
  cmeGoalValueLTE?: InputMaybe<Scalars['String']['input']>;
  cmeGoalValueNEQ?: InputMaybe<Scalars['String']['input']>;
  cmeGoalValueNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cmeGoalValueNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** country field predicates */
  country?: InputMaybe<Scalars['String']['input']>;
  countryContains?: InputMaybe<Scalars['String']['input']>;
  countryContainsFold?: InputMaybe<Scalars['String']['input']>;
  countryEqualFold?: InputMaybe<Scalars['String']['input']>;
  countryGT?: InputMaybe<Scalars['String']['input']>;
  countryGTE?: InputMaybe<Scalars['String']['input']>;
  countryHasPrefix?: InputMaybe<Scalars['String']['input']>;
  countryHasSuffix?: InputMaybe<Scalars['String']['input']>;
  countryIn?: InputMaybe<Array<Scalars['String']['input']>>;
  countryIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  countryLT?: InputMaybe<Scalars['String']['input']>;
  countryLTE?: InputMaybe<Scalars['String']['input']>;
  countryNEQ?: InputMaybe<Scalars['String']['input']>;
  countryNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  countryNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** credential field predicates */
  credential?: InputMaybe<Scalars['String']['input']>;
  credentialContains?: InputMaybe<Scalars['String']['input']>;
  credentialContainsFold?: InputMaybe<Scalars['String']['input']>;
  credentialEqualFold?: InputMaybe<Scalars['String']['input']>;
  credentialGT?: InputMaybe<Scalars['String']['input']>;
  credentialGTE?: InputMaybe<Scalars['String']['input']>;
  credentialHasPrefix?: InputMaybe<Scalars['String']['input']>;
  credentialHasSuffix?: InputMaybe<Scalars['String']['input']>;
  credentialIn?: InputMaybe<Array<Scalars['String']['input']>>;
  credentialIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  credentialLT?: InputMaybe<Scalars['String']['input']>;
  credentialLTE?: InputMaybe<Scalars['String']['input']>;
  credentialNEQ?: InputMaybe<Scalars['String']['input']>;
  credentialNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  credentialNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** disabled field predicates */
  disabled?: InputMaybe<Scalars['Boolean']['input']>;
  disabledNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** dob field predicates */
  dob?: InputMaybe<Scalars['Time']['input']>;
  dobGT?: InputMaybe<Scalars['Time']['input']>;
  dobGTE?: InputMaybe<Scalars['Time']['input']>;
  dobIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dobIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  dobLT?: InputMaybe<Scalars['Time']['input']>;
  dobLTE?: InputMaybe<Scalars['Time']['input']>;
  dobNEQ?: InputMaybe<Scalars['Time']['input']>;
  dobNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  dobNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']['input']>;
  emailContains?: InputMaybe<Scalars['String']['input']>;
  emailContainsFold?: InputMaybe<Scalars['String']['input']>;
  emailEqualFold?: InputMaybe<Scalars['String']['input']>;
  emailGT?: InputMaybe<Scalars['String']['input']>;
  emailGTE?: InputMaybe<Scalars['String']['input']>;
  emailHasPrefix?: InputMaybe<Scalars['String']['input']>;
  emailHasSuffix?: InputMaybe<Scalars['String']['input']>;
  emailIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  emailLT?: InputMaybe<Scalars['String']['input']>;
  emailLTE?: InputMaybe<Scalars['String']['input']>;
  emailNEQ?: InputMaybe<Scalars['String']['input']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** financial_disclosures field predicates */
  financialDisclosures?: InputMaybe<Scalars['String']['input']>;
  financialDisclosuresContains?: InputMaybe<Scalars['String']['input']>;
  financialDisclosuresContainsFold?: InputMaybe<Scalars['String']['input']>;
  financialDisclosuresEqualFold?: InputMaybe<Scalars['String']['input']>;
  financialDisclosuresGT?: InputMaybe<Scalars['String']['input']>;
  financialDisclosuresGTE?: InputMaybe<Scalars['String']['input']>;
  financialDisclosuresHasPrefix?: InputMaybe<Scalars['String']['input']>;
  financialDisclosuresHasSuffix?: InputMaybe<Scalars['String']['input']>;
  financialDisclosuresIn?: InputMaybe<Array<Scalars['String']['input']>>;
  financialDisclosuresIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  financialDisclosuresLT?: InputMaybe<Scalars['String']['input']>;
  financialDisclosuresLTE?: InputMaybe<Scalars['String']['input']>;
  financialDisclosuresNEQ?: InputMaybe<Scalars['String']['input']>;
  financialDisclosuresNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  financialDisclosuresNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** first_name field predicates */
  firstName?: InputMaybe<Scalars['String']['input']>;
  firstNameContains?: InputMaybe<Scalars['String']['input']>;
  firstNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  firstNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  firstNameGT?: InputMaybe<Scalars['String']['input']>;
  firstNameGTE?: InputMaybe<Scalars['String']['input']>;
  firstNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  firstNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  firstNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  firstNameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  firstNameLT?: InputMaybe<Scalars['String']['input']>;
  firstNameLTE?: InputMaybe<Scalars['String']['input']>;
  firstNameNEQ?: InputMaybe<Scalars['String']['input']>;
  firstNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  firstNameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** api_tokens edge predicates */
  hasAPITokens?: InputMaybe<Scalars['Boolean']['input']>;
  hasAPITokensWith?: InputMaybe<Array<ApiTokenWhereInput>>;
  /** account_connections edge predicates */
  hasAccountConnections?: InputMaybe<Scalars['Boolean']['input']>;
  hasAccountConnectionsWith?: InputMaybe<Array<AccountConnectionWhereInput>>;
  /** avatar edge predicates */
  hasAvatar?: InputMaybe<Scalars['Boolean']['input']>;
  hasAvatarWith?: InputMaybe<Array<MediaItemWhereInput>>;
  /** blocked_users edge predicates */
  hasBlockedUsers?: InputMaybe<Scalars['Boolean']['input']>;
  hasBlockedUsersWith?: InputMaybe<Array<UserBlockWhereInput>>;
  /** board_certifications edge predicates */
  hasBoardCertifications?: InputMaybe<Scalars['Boolean']['input']>;
  hasBoardCertificationsWith?: InputMaybe<Array<BoardCertificationWhereInput>>;
  /** bookmarked_posts edge predicates */
  hasBookmarkedPosts?: InputMaybe<Scalars['Boolean']['input']>;
  hasBookmarkedPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** bookmarks edge predicates */
  hasBookmarks?: InputMaybe<Scalars['Boolean']['input']>;
  hasBookmarksWith?: InputMaybe<Array<BookmarkWhereInput>>;
  /** cohorts edge predicates */
  hasCohorts?: InputMaybe<Scalars['Boolean']['input']>;
  hasCohortsWith?: InputMaybe<Array<UserCohortWhereInput>>;
  /** comment_likes edge predicates */
  hasCommentLikes?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommentLikesWith?: InputMaybe<Array<CommentLikeWhereInput>>;
  /** comments edge predicates */
  hasComments?: InputMaybe<Scalars['Boolean']['input']>;
  hasCommentsWith?: InputMaybe<Array<CommentWhereInput>>;
  /** courses_created edge predicates */
  hasCoursesCreated?: InputMaybe<Scalars['Boolean']['input']>;
  hasCoursesCreatedWith?: InputMaybe<Array<CourseWhereInput>>;
  /** courses_faculty edge predicates */
  hasCoursesFaculty?: InputMaybe<Scalars['Boolean']['input']>;
  hasCoursesFacultyWith?: InputMaybe<Array<CourseWhereInput>>;
  /** courses_reviewed edge predicates */
  hasCoursesReviewed?: InputMaybe<Scalars['Boolean']['input']>;
  hasCoursesReviewedWith?: InputMaybe<Array<CourseWhereInput>>;
  /** has_disclosures_needing_review field predicates */
  hasDisclosuresNeedingReview?: InputMaybe<Scalars['Boolean']['input']>;
  hasDisclosuresNeedingReviewNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** education_credits edge predicates */
  hasEducationCredits?: InputMaybe<Scalars['Boolean']['input']>;
  hasEducationCreditsWith?: InputMaybe<Array<EducationCreditWhereInput>>;
  /** education_history edge predicates */
  hasEducationHistory?: InputMaybe<Scalars['Boolean']['input']>;
  hasEducationHistoryWith?: InputMaybe<Array<EducationHistoryWhereInput>>;
  /** feed edge predicates */
  hasFeed?: InputMaybe<Scalars['Boolean']['input']>;
  /** feed_histories edge predicates */
  hasFeedHistories?: InputMaybe<Scalars['Boolean']['input']>;
  hasFeedHistoriesWith?: InputMaybe<Array<UserFeedHistoryWhereInput>>;
  hasFeedWith?: InputMaybe<Array<ArticleFeedWhereInput>>;
  /** financial_disclosure_statement edge predicates */
  hasFinancialDisclosureStatement?: InputMaybe<Scalars['Boolean']['input']>;
  hasFinancialDisclosureStatementWith?: InputMaybe<Array<FinancialDisclosureStatementWhereInput>>;
  /** followers edge predicates */
  hasFollowers?: InputMaybe<Scalars['Boolean']['input']>;
  hasFollowersWith?: InputMaybe<Array<UserWhereInput>>;
  /** following edge predicates */
  hasFollowing?: InputMaybe<Scalars['Boolean']['input']>;
  hasFollowingWith?: InputMaybe<Array<UserWhereInput>>;
  /** imported_videos edge predicates */
  hasImportedVideos?: InputMaybe<Scalars['Boolean']['input']>;
  hasImportedVideosWith?: InputMaybe<Array<ImportedVideoWhereInput>>;
  /** license_history edge predicates */
  hasLicenseHistory?: InputMaybe<Scalars['Boolean']['input']>;
  hasLicenseHistoryWith?: InputMaybe<Array<LicenseHistoryWhereInput>>;
  /** liked_comments edge predicates */
  hasLikedComments?: InputMaybe<Scalars['Boolean']['input']>;
  hasLikedCommentsWith?: InputMaybe<Array<CommentWhereInput>>;
  /** liked_posts edge predicates */
  hasLikedPosts?: InputMaybe<Scalars['Boolean']['input']>;
  hasLikedPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** likes edge predicates */
  hasLikes?: InputMaybe<Scalars['Boolean']['input']>;
  hasLikesWith?: InputMaybe<Array<LikeWhereInput>>;
  /** links edge predicates */
  hasLinks?: InputMaybe<Scalars['Boolean']['input']>;
  hasLinksWith?: InputMaybe<Array<UserLinkWhereInput>>;
  /** mentioned_posts edge predicates */
  hasMentionedPosts?: InputMaybe<Scalars['Boolean']['input']>;
  hasMentionedPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** muted_users edge predicates */
  hasMutedUsers?: InputMaybe<Scalars['Boolean']['input']>;
  hasMutedUsersWith?: InputMaybe<Array<UserMuteWhereInput>>;
  /** notification_tokens edge predicates */
  hasNotificationTokens?: InputMaybe<Scalars['Boolean']['input']>;
  hasNotificationTokensWith?: InputMaybe<Array<UserNotificationTokenWhereInput>>;
  /** notifications edge predicates */
  hasNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  hasNotificationsWith?: InputMaybe<Array<NotificationWhereInput>>;
  /** offices edge predicates */
  hasOffices?: InputMaybe<Scalars['Boolean']['input']>;
  hasOfficesWith?: InputMaybe<Array<OfficeWhereInput>>;
  /** outgoing_notifications edge predicates */
  hasOutgoingNotifications?: InputMaybe<Scalars['Boolean']['input']>;
  hasOutgoingNotificationsWith?: InputMaybe<Array<NotificationWhereInput>>;
  /** post_reports edge predicates */
  hasPostReports?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostReportsWith?: InputMaybe<Array<PostReportWhereInput>>;
  /** posts edge predicates */
  hasPosts?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** profile_image edge predicates */
  hasProfileImage?: InputMaybe<Scalars['Boolean']['input']>;
  hasProfileImageWith?: InputMaybe<Array<ImageWhereInput>>;
  /** reported_by edge predicates */
  hasReportedBy?: InputMaybe<Scalars['Boolean']['input']>;
  hasReportedByWith?: InputMaybe<Array<UserReportWhereInput>>;
  /** searches edge predicates */
  hasSearches?: InputMaybe<Scalars['Boolean']['input']>;
  hasSearchesWith?: InputMaybe<Array<SearchWhereInput>>;
  /** specialty edge predicates */
  hasSpecialty?: InputMaybe<Scalars['Boolean']['input']>;
  hasSpecialtyWith?: InputMaybe<Array<NpiTaxonomyWhereInput>>;
  /** has_submitted_disclosure field predicates */
  hasSubmittedDisclosure?: InputMaybe<Scalars['Boolean']['input']>;
  hasSubmittedDisclosureNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** tenants edge predicates */
  hasTenants?: InputMaybe<Scalars['Boolean']['input']>;
  hasTenantsWith?: InputMaybe<Array<TenantWhereInput>>;
  /** topics edge predicates */
  hasTopics?: InputMaybe<Scalars['Boolean']['input']>;
  hasTopicsWith?: InputMaybe<Array<TopicWhereInput>>;
  /** user_completions edge predicates */
  hasUserCompletions?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserCompletionsWith?: InputMaybe<Array<UserCollectionCompletionWhereInput>>;
  /** user_reports edge predicates */
  hasUserReports?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserReportsWith?: InputMaybe<Array<UserReportWhereInput>>;
  /** user_tenants edge predicates */
  hasUserTenants?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserTenantsWith?: InputMaybe<Array<UserTenantWhereInput>>;
  /** work_history edge predicates */
  hasWorkHistory?: InputMaybe<Scalars['Boolean']['input']>;
  hasWorkHistoryWith?: InputMaybe<Array<WorkExperienceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** is_staff field predicates */
  isStaff?: InputMaybe<Scalars['Boolean']['input']>;
  isStaffNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** is_student field predicates */
  isStudent?: InputMaybe<Scalars['Boolean']['input']>;
  isStudentNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** last_login_at field predicates */
  lastLoginAt?: InputMaybe<Scalars['Time']['input']>;
  lastLoginAtGT?: InputMaybe<Scalars['Time']['input']>;
  lastLoginAtGTE?: InputMaybe<Scalars['Time']['input']>;
  lastLoginAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastLoginAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  lastLoginAtLT?: InputMaybe<Scalars['Time']['input']>;
  lastLoginAtLTE?: InputMaybe<Scalars['Time']['input']>;
  lastLoginAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  lastLoginAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastLoginAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** last_name field predicates */
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastNameContains?: InputMaybe<Scalars['String']['input']>;
  lastNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  lastNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  lastNameGT?: InputMaybe<Scalars['String']['input']>;
  lastNameGTE?: InputMaybe<Scalars['String']['input']>;
  lastNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  lastNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  lastNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  lastNameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  lastNameLT?: InputMaybe<Scalars['String']['input']>;
  lastNameLTE?: InputMaybe<Scalars['String']['input']>;
  lastNameNEQ?: InputMaybe<Scalars['String']['input']>;
  lastNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  lastNameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<UserWhereInput>;
  /** npi_number field predicates */
  npiNumber?: InputMaybe<Scalars['String']['input']>;
  npiNumberContains?: InputMaybe<Scalars['String']['input']>;
  npiNumberContainsFold?: InputMaybe<Scalars['String']['input']>;
  npiNumberEqualFold?: InputMaybe<Scalars['String']['input']>;
  npiNumberGT?: InputMaybe<Scalars['String']['input']>;
  npiNumberGTE?: InputMaybe<Scalars['String']['input']>;
  npiNumberHasPrefix?: InputMaybe<Scalars['String']['input']>;
  npiNumberHasSuffix?: InputMaybe<Scalars['String']['input']>;
  npiNumberIn?: InputMaybe<Array<Scalars['String']['input']>>;
  npiNumberIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  npiNumberLT?: InputMaybe<Scalars['String']['input']>;
  npiNumberLTE?: InputMaybe<Scalars['String']['input']>;
  npiNumberNEQ?: InputMaybe<Scalars['String']['input']>;
  npiNumberNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  npiNumberNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** npi_taxonomy_code field predicates */
  npiTaxonomyCode?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyCodeContains?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyCodeContainsFold?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyCodeEqualFold?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyCodeGT?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyCodeGTE?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyCodeHasPrefix?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyCodeHasSuffix?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyCodeIn?: InputMaybe<Array<Scalars['String']['input']>>;
  npiTaxonomyCodeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  npiTaxonomyCodeLT?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyCodeLTE?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyCodeNEQ?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyCodeNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  npiTaxonomyCodeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** npi_taxonomy_description field predicates */
  npiTaxonomyDescription?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyDescriptionContains?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyDescriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyDescriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyDescriptionGT?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyDescriptionGTE?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyDescriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyDescriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyDescriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  npiTaxonomyDescriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  npiTaxonomyDescriptionLT?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyDescriptionLTE?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyDescriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  npiTaxonomyDescriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  npiTaxonomyDescriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** phone field predicates */
  phone?: InputMaybe<Scalars['String']['input']>;
  phoneContains?: InputMaybe<Scalars['String']['input']>;
  phoneContainsFold?: InputMaybe<Scalars['String']['input']>;
  phoneEqualFold?: InputMaybe<Scalars['String']['input']>;
  phoneGT?: InputMaybe<Scalars['String']['input']>;
  phoneGTE?: InputMaybe<Scalars['String']['input']>;
  phoneHasPrefix?: InputMaybe<Scalars['String']['input']>;
  phoneHasSuffix?: InputMaybe<Scalars['String']['input']>;
  phoneIn?: InputMaybe<Array<Scalars['String']['input']>>;
  phoneIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  phoneLT?: InputMaybe<Scalars['String']['input']>;
  phoneLTE?: InputMaybe<Scalars['String']['input']>;
  phoneNEQ?: InputMaybe<Scalars['String']['input']>;
  phoneNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  phoneNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** professional_experience_start_date field predicates */
  professionalExperienceStartDate?: InputMaybe<Scalars['Time']['input']>;
  professionalExperienceStartDateGT?: InputMaybe<Scalars['Time']['input']>;
  professionalExperienceStartDateGTE?: InputMaybe<Scalars['Time']['input']>;
  professionalExperienceStartDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  professionalExperienceStartDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  professionalExperienceStartDateLT?: InputMaybe<Scalars['Time']['input']>;
  professionalExperienceStartDateLTE?: InputMaybe<Scalars['Time']['input']>;
  professionalExperienceStartDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  professionalExperienceStartDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  professionalExperienceStartDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** reflections_on_authored_posts_disabled field predicates */
  reflectionsOnAuthoredPostsDisabled?: InputMaybe<Scalars['Boolean']['input']>;
  reflectionsOnAuthoredPostsDisabledNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** role field predicates */
  role?: InputMaybe<UserRole>;
  roleIn?: InputMaybe<Array<UserRole>>;
  roleNEQ?: InputMaybe<UserRole>;
  roleNotIn?: InputMaybe<Array<UserRole>>;
  search?: InputMaybe<Scalars['String']['input']>;
  /** state field predicates */
  state?: InputMaybe<Scalars['String']['input']>;
  stateContains?: InputMaybe<Scalars['String']['input']>;
  stateContainsFold?: InputMaybe<Scalars['String']['input']>;
  stateEqualFold?: InputMaybe<Scalars['String']['input']>;
  stateGT?: InputMaybe<Scalars['String']['input']>;
  stateGTE?: InputMaybe<Scalars['String']['input']>;
  stateHasPrefix?: InputMaybe<Scalars['String']['input']>;
  stateHasSuffix?: InputMaybe<Scalars['String']['input']>;
  stateIn?: InputMaybe<Array<Scalars['String']['input']>>;
  stateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  stateLT?: InputMaybe<Scalars['String']['input']>;
  stateLTE?: InputMaybe<Scalars['String']['input']>;
  stateNEQ?: InputMaybe<Scalars['String']['input']>;
  stateNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  stateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** status field predicates */
  status?: InputMaybe<UserStatus>;
  statusIn?: InputMaybe<Array<UserStatus>>;
  statusNEQ?: InputMaybe<UserStatus>;
  statusNotIn?: InputMaybe<Array<UserStatus>>;
  /** suggested field predicates */
  suggested?: InputMaybe<Scalars['Boolean']['input']>;
  suggestedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** synthetic field predicates */
  synthetic?: InputMaybe<Scalars['Boolean']['input']>;
  syntheticNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** total_cme_earned field predicates */
  totalCmeEarned?: InputMaybe<Scalars['Float']['input']>;
  totalCmeEarnedGT?: InputMaybe<Scalars['Float']['input']>;
  totalCmeEarnedGTE?: InputMaybe<Scalars['Float']['input']>;
  totalCmeEarnedIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  totalCmeEarnedIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  totalCmeEarnedLT?: InputMaybe<Scalars['Float']['input']>;
  totalCmeEarnedLTE?: InputMaybe<Scalars['Float']['input']>;
  totalCmeEarnedNEQ?: InputMaybe<Scalars['Float']['input']>;
  totalCmeEarnedNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  totalCmeEarnedNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** total_followers field predicates */
  totalFollowers?: InputMaybe<Scalars['Int']['input']>;
  totalFollowersGT?: InputMaybe<Scalars['Int']['input']>;
  totalFollowersGTE?: InputMaybe<Scalars['Int']['input']>;
  totalFollowersIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalFollowersLT?: InputMaybe<Scalars['Int']['input']>;
  totalFollowersLTE?: InputMaybe<Scalars['Int']['input']>;
  totalFollowersNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalFollowersNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** total_following field predicates */
  totalFollowing?: InputMaybe<Scalars['Int']['input']>;
  totalFollowingGT?: InputMaybe<Scalars['Int']['input']>;
  totalFollowingGTE?: InputMaybe<Scalars['Int']['input']>;
  totalFollowingIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalFollowingLT?: InputMaybe<Scalars['Int']['input']>;
  totalFollowingLTE?: InputMaybe<Scalars['Int']['input']>;
  totalFollowingNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalFollowingNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** trending_boost field predicates */
  trendingBoost?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostGT?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostGTE?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  trendingBoostLT?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostLTE?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostNEQ?: InputMaybe<Scalars['Float']['input']>;
  trendingBoostNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** username field predicates */
  username?: InputMaybe<Scalars['String']['input']>;
  usernameContains?: InputMaybe<Scalars['String']['input']>;
  usernameContainsFold?: InputMaybe<Scalars['String']['input']>;
  usernameEqualFold?: InputMaybe<Scalars['String']['input']>;
  usernameGT?: InputMaybe<Scalars['String']['input']>;
  usernameGTE?: InputMaybe<Scalars['String']['input']>;
  usernameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  usernameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  usernameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  usernameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  usernameLT?: InputMaybe<Scalars['String']['input']>;
  usernameLTE?: InputMaybe<Scalars['String']['input']>;
  usernameNEQ?: InputMaybe<Scalars['String']['input']>;
  usernameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  usernameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type VerificationRequest = Node & {
  __typename?: 'VerificationRequest';
  createdAt: Scalars['Time']['output'];
  dob?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  status: VerificationRequestStatus;
  storageKey: Scalars['String']['output'];
  updatedAt: Scalars['Time']['output'];
  url: Scalars['String']['output'];
  user: User;
  zip?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of items. */
export type VerificationRequestConnection = {
  __typename?: 'VerificationRequestConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VerificationRequestEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type VerificationRequestEdge = {
  __typename?: 'VerificationRequestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VerificationRequest>;
};

/** Ordering options for VerificationRequest connections */
export type VerificationRequestOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order VerificationRequests. */
  field: VerificationRequestOrderField;
};

/** Properties by which VerificationRequest connections can be ordered. */
export enum VerificationRequestOrderField {
  CreatedAt = 'CREATED_AT'
}

export type VerificationRequestResult = {
  __typename?: 'VerificationRequestResult';
  url: Scalars['String']['output'];
  verificationRequest: VerificationRequest;
};

/** VerificationRequestStatus is enum for the field status */
export enum VerificationRequestStatus {
  Approved = 'approved',
  Pending = 'pending',
  Rejected = 'rejected',
  Waiting = 'waiting'
}

/**
 * VerificationRequestWhereInput is used for filtering VerificationRequest objects.
 * Input was generated by ent.
 */
export type VerificationRequestWhereInput = {
  and?: InputMaybe<Array<VerificationRequestWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** dob field predicates */
  dob?: InputMaybe<Scalars['String']['input']>;
  dobContains?: InputMaybe<Scalars['String']['input']>;
  dobContainsFold?: InputMaybe<Scalars['String']['input']>;
  dobEqualFold?: InputMaybe<Scalars['String']['input']>;
  dobGT?: InputMaybe<Scalars['String']['input']>;
  dobGTE?: InputMaybe<Scalars['String']['input']>;
  dobHasPrefix?: InputMaybe<Scalars['String']['input']>;
  dobHasSuffix?: InputMaybe<Scalars['String']['input']>;
  dobIn?: InputMaybe<Array<Scalars['String']['input']>>;
  dobIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  dobLT?: InputMaybe<Scalars['String']['input']>;
  dobLTE?: InputMaybe<Scalars['String']['input']>;
  dobNEQ?: InputMaybe<Scalars['String']['input']>;
  dobNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  dobNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<VerificationRequestWhereInput>;
  or?: InputMaybe<Array<VerificationRequestWhereInput>>;
  /** status field predicates */
  status?: InputMaybe<VerificationRequestStatus>;
  statusIn?: InputMaybe<Array<VerificationRequestStatus>>;
  statusNEQ?: InputMaybe<VerificationRequestStatus>;
  statusNotIn?: InputMaybe<Array<VerificationRequestStatus>>;
  /** storage_key field predicates */
  storageKey?: InputMaybe<Scalars['String']['input']>;
  storageKeyContains?: InputMaybe<Scalars['String']['input']>;
  storageKeyContainsFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyEqualFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyGT?: InputMaybe<Scalars['String']['input']>;
  storageKeyGTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  storageKeyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  storageKeyLT?: InputMaybe<Scalars['String']['input']>;
  storageKeyLTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyNEQ?: InputMaybe<Scalars['String']['input']>;
  storageKeyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']['input']>;
  urlContains?: InputMaybe<Scalars['String']['input']>;
  urlContainsFold?: InputMaybe<Scalars['String']['input']>;
  urlEqualFold?: InputMaybe<Scalars['String']['input']>;
  urlGT?: InputMaybe<Scalars['String']['input']>;
  urlGTE?: InputMaybe<Scalars['String']['input']>;
  urlHasPrefix?: InputMaybe<Scalars['String']['input']>;
  urlHasSuffix?: InputMaybe<Scalars['String']['input']>;
  urlIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlLT?: InputMaybe<Scalars['String']['input']>;
  urlLTE?: InputMaybe<Scalars['String']['input']>;
  urlNEQ?: InputMaybe<Scalars['String']['input']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** zip field predicates */
  zip?: InputMaybe<Scalars['String']['input']>;
  zipContains?: InputMaybe<Scalars['String']['input']>;
  zipContainsFold?: InputMaybe<Scalars['String']['input']>;
  zipEqualFold?: InputMaybe<Scalars['String']['input']>;
  zipGT?: InputMaybe<Scalars['String']['input']>;
  zipGTE?: InputMaybe<Scalars['String']['input']>;
  zipHasPrefix?: InputMaybe<Scalars['String']['input']>;
  zipHasSuffix?: InputMaybe<Scalars['String']['input']>;
  zipIn?: InputMaybe<Array<Scalars['String']['input']>>;
  zipIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  zipLT?: InputMaybe<Scalars['String']['input']>;
  zipLTE?: InputMaybe<Scalars['String']['input']>;
  zipNEQ?: InputMaybe<Scalars['String']['input']>;
  zipNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  zipNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Video = Node & {
  __typename?: 'Video';
  alternatePlaylists: Array<AlternatePlaylist>;
  /** The time when the video was uploaded to Cloudflare */
  cloudflareUploadEndedAt?: Maybe<Scalars['Time']['output']>;
  /** The error message if the upload failed */
  cloudflareUploadError?: Maybe<Scalars['String']['output']>;
  /** The time when the video was uploaded to Cloudflare */
  cloudflareUploadStartedAt?: Maybe<Scalars['Time']['output']>;
  /** The processing status of the video. */
  cloudflareUploadStatus?: Maybe<VideoCloudflareUploadStatus>;
  /** The Cloudflare upload UID */
  cloudflareUploadUID?: Maybe<Scalars['String']['output']>;
  completedAt?: Maybe<Scalars['Time']['output']>;
  course?: Maybe<Array<Course>>;
  createdAt: Scalars['Time']['output'];
  /** The URL of the DASH stream of the video. */
  dashURL?: Maybe<Scalars['String']['output']>;
  /** The main discussion points for this post */
  discussionPoints?: Maybe<Array<Scalars['String']['output']>>;
  /** The duration of the video in seconds. */
  duration?: Maybe<Scalars['Int']['output']>;
  faceDetectionRequest?: Maybe<Array<FaceDetectRequest>>;
  frames?: Maybe<Array<VideoFrame>>;
  /** The time when the video insights were generated */
  generateInsightsEndedAt?: Maybe<Scalars['Time']['output']>;
  /** The error message if the generate insights failed */
  generateInsightsError?: Maybe<Scalars['String']['output']>;
  /** The time when the video insights were generated */
  generateInsightsStartedAt?: Maybe<Scalars['Time']['output']>;
  /** The processing status of the video. */
  generateInsightsStatus?: Maybe<VideoGenerateInsightsStatus>;
  /** The Google Drive file that the video was imported from. */
  googleDriveFile?: Maybe<GoogleDriveFile>;
  /** The height of the video in pixels. */
  height?: Maybe<Scalars['Int']['output']>;
  /** The URL of the HLS stream of the video. */
  hlsURL?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  images?: Maybe<Array<Image>>;
  /** The imported video record. */
  importedVideo?: Maybe<ImportedVideo>;
  /** The time when the insights were last generated */
  insightsGeneratedAt?: Maybe<Scalars['Time']['output']>;
  /** The likely audience for this video */
  likelyAudience?: Maybe<Scalars['String']['output']>;
  /** The post that the video belongs to. */
  post?: Maybe<Post>;
  /** The size of the video in bytes */
  size?: Maybe<Scalars['Int']['output']>;
  /** The media ID of the video in SpeakAI */
  speakMediaID?: Maybe<Scalars['String']['output']>;
  /** The processing status of the video. */
  status: VideoStatus;
  /** The storage key of the video. */
  storageKey?: Maybe<Scalars['String']['output']>;
  /** A suggested body based on the audio transcription */
  suggestedBody?: Maybe<Scalars['String']['output']>;
  /** The topics this post is associated with */
  suggestedLearningObjectives?: Maybe<Array<LearningObjective>>;
  /** A suggested title based on the audio transcription */
  suggestedTitle?: Maybe<Scalars['String']['output']>;
  suggestedTopics?: Maybe<Array<Topic>>;
  termFrequencies?: Maybe<Scalars['Map']['output']>;
  terms?: Maybe<Array<Scalars['String']['output']>>;
  /** The number of terms per minute in the video */
  termsPerMinute: Scalars['Float']['output'];
  /** The URL of the thumbnail image of the video. */
  thumbnailURL?: Maybe<Scalars['String']['output']>;
  /** The top learning objectives for this post */
  topLearningObjectives?: Maybe<Array<Scalars['String']['output']>>;
  topicClassifications?: Maybe<Array<TopicClassification>>;
  /** The time when the video was transcoded */
  transcodeEndedAt?: Maybe<Scalars['Time']['output']>;
  /** The error message if the transcode failed */
  transcodeError?: Maybe<Scalars['String']['output']>;
  /** The time when the video was transcoded */
  transcodeStartedAt?: Maybe<Scalars['Time']['output']>;
  /** The processing status of the video. */
  transcodeStatus?: Maybe<VideoTranscodeStatus>;
  /** The time when the video was transcribed */
  transcribeEndedAt?: Maybe<Scalars['Time']['output']>;
  /** The error message if the transcribe failed */
  transcribeError?: Maybe<Scalars['String']['output']>;
  /** The time when the video was transcribed */
  transcribeStartedAt?: Maybe<Scalars['Time']['output']>;
  /** The processing status of the video. */
  transcribeStatus?: Maybe<VideoTranscribeStatus>;
  /** The transcription of the video. */
  transcription?: Maybe<Scalars['String']['output']>;
  transcriptionRequest?: Maybe<TranscriptionRequest>;
  updatedAt: Scalars['Time']['output'];
  /** The user video events for this video. */
  userVideoEvents?: Maybe<Array<UserVideoEvent>>;
  /** The vertical DASH URL of the video. */
  verticalDashURL?: Maybe<Scalars['String']['output']>;
  /** The vertical height of the video in pixels. */
  verticalHeight?: Maybe<Scalars['Int']['output']>;
  /** The vertical HLS URL of the video. */
  verticalHlsURL?: Maybe<Scalars['String']['output']>;
  /** The vertical thumbnail URL of the video. */
  verticalThumbnailURL?: Maybe<Scalars['String']['output']>;
  /** The vertical UID of the video. */
  verticalUID?: Maybe<Scalars['String']['output']>;
  /** The vertical width of the video in pixels. */
  verticalWidth?: Maybe<Scalars['Int']['output']>;
  /** The width of the video in pixels. */
  width?: Maybe<Scalars['Int']['output']>;
  wordcloud?: Maybe<Scalars['String']['output']>;
  workflowID?: Maybe<Scalars['String']['output']>;
  workflowRunID?: Maybe<Scalars['String']['output']>;
};


export type VideoTopicClassificationsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  suggested?: InputMaybe<Scalars['Boolean']['input']>;
};

/** VideoCloudflareUploadStatus is enum for the field cloudflare_upload_status */
export enum VideoCloudflareUploadStatus {
  Completed = 'completed',
  Failed = 'failed',
  Started = 'started'
}

/** A connection to a list of items. */
export type VideoConnection = {
  __typename?: 'VideoConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VideoEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type VideoEdge = {
  __typename?: 'VideoEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Video>;
};

export enum VideoEventType {
  End = 'END',
  Play = 'PLAY'
}

export type VideoFrame = Node & {
  __typename?: 'VideoFrame';
  bucket: Scalars['String']['output'];
  faces?: Maybe<Scalars['Map']['output']>;
  id: Scalars['ID']['output'];
  key: Scalars['String']['output'];
  /** The url of the image. */
  url?: Maybe<Scalars['String']['output']>;
  /** The video that this frame belongs to. */
  video?: Maybe<Video>;
};

/**
 * VideoFrameWhereInput is used for filtering VideoFrame objects.
 * Input was generated by ent.
 */
export type VideoFrameWhereInput = {
  and?: InputMaybe<Array<VideoFrameWhereInput>>;
  /** bucket field predicates */
  bucket?: InputMaybe<Scalars['String']['input']>;
  bucketContains?: InputMaybe<Scalars['String']['input']>;
  bucketContainsFold?: InputMaybe<Scalars['String']['input']>;
  bucketEqualFold?: InputMaybe<Scalars['String']['input']>;
  bucketGT?: InputMaybe<Scalars['String']['input']>;
  bucketGTE?: InputMaybe<Scalars['String']['input']>;
  bucketHasPrefix?: InputMaybe<Scalars['String']['input']>;
  bucketHasSuffix?: InputMaybe<Scalars['String']['input']>;
  bucketIn?: InputMaybe<Array<Scalars['String']['input']>>;
  bucketLT?: InputMaybe<Scalars['String']['input']>;
  bucketLTE?: InputMaybe<Scalars['String']['input']>;
  bucketNEQ?: InputMaybe<Scalars['String']['input']>;
  bucketNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** video edge predicates */
  hasVideo?: InputMaybe<Scalars['Boolean']['input']>;
  hasVideoWith?: InputMaybe<Array<VideoWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** key field predicates */
  key?: InputMaybe<Scalars['String']['input']>;
  keyContains?: InputMaybe<Scalars['String']['input']>;
  keyContainsFold?: InputMaybe<Scalars['String']['input']>;
  keyEqualFold?: InputMaybe<Scalars['String']['input']>;
  keyGT?: InputMaybe<Scalars['String']['input']>;
  keyGTE?: InputMaybe<Scalars['String']['input']>;
  keyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  keyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  keyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  keyLT?: InputMaybe<Scalars['String']['input']>;
  keyLTE?: InputMaybe<Scalars['String']['input']>;
  keyNEQ?: InputMaybe<Scalars['String']['input']>;
  keyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<VideoFrameWhereInput>;
  or?: InputMaybe<Array<VideoFrameWhereInput>>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']['input']>;
  urlContains?: InputMaybe<Scalars['String']['input']>;
  urlContainsFold?: InputMaybe<Scalars['String']['input']>;
  urlEqualFold?: InputMaybe<Scalars['String']['input']>;
  urlGT?: InputMaybe<Scalars['String']['input']>;
  urlGTE?: InputMaybe<Scalars['String']['input']>;
  urlHasPrefix?: InputMaybe<Scalars['String']['input']>;
  urlHasSuffix?: InputMaybe<Scalars['String']['input']>;
  urlIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  urlLT?: InputMaybe<Scalars['String']['input']>;
  urlLTE?: InputMaybe<Scalars['String']['input']>;
  urlNEQ?: InputMaybe<Scalars['String']['input']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  urlNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

/** VideoGenerateInsightsStatus is enum for the field generate_insights_status */
export enum VideoGenerateInsightsStatus {
  Completed = 'completed',
  Failed = 'failed',
  Started = 'started'
}

/** Ordering options for Video connections */
export type VideoOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Videos. */
  field: VideoOrderField;
};

/** Properties by which Video connections can be ordered. */
export enum VideoOrderField {
  CreatedAt = 'CREATED_AT',
  TermsPerMinute = 'TERMS_PER_MINUTE'
}

export type VideoPipeline = Node & {
  __typename?: 'VideoPipeline';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  updatedAt: Scalars['Time']['output'];
  video?: Maybe<Video>;
};

/** A connection to a list of items. */
export type VideoPipelineConnection = {
  __typename?: 'VideoPipelineConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VideoPipelineEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type VideoPipelineEdge = {
  __typename?: 'VideoPipelineEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<VideoPipeline>;
};

/** Ordering options for VideoPipeline connections */
export type VideoPipelineOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order VideoPipelines. */
  field: VideoPipelineOrderField;
};

/** Properties by which VideoPipeline connections can be ordered. */
export enum VideoPipelineOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * VideoPipelineWhereInput is used for filtering VideoPipeline objects.
 * Input was generated by ent.
 */
export type VideoPipelineWhereInput = {
  and?: InputMaybe<Array<VideoPipelineWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** video edge predicates */
  hasVideo?: InputMaybe<Scalars['Boolean']['input']>;
  hasVideoWith?: InputMaybe<Array<VideoWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<VideoPipelineWhereInput>;
  or?: InputMaybe<Array<VideoPipelineWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

/** VideoStatus is enum for the field status */
export enum VideoStatus {
  Failed = 'failed',
  Processing = 'processing',
  Ready = 'ready',
  Waiting = 'waiting'
}

/** VideoTranscodeStatus is enum for the field transcode_status */
export enum VideoTranscodeStatus {
  Completed = 'completed',
  Failed = 'failed',
  Started = 'started'
}

/** VideoTranscribeStatus is enum for the field transcribe_status */
export enum VideoTranscribeStatus {
  Completed = 'completed',
  Failed = 'failed',
  Started = 'started'
}

export type VideoUploadResponse = {
  __typename?: 'VideoUploadResponse';
  url: Scalars['String']['output'];
  video: Video;
};

/**
 * VideoWhereInput is used for filtering Video objects.
 * Input was generated by ent.
 */
export type VideoWhereInput = {
  and?: InputMaybe<Array<VideoWhereInput>>;
  /** cloudflare_upload_ended_at field predicates */
  cloudflareUploadEndedAt?: InputMaybe<Scalars['Time']['input']>;
  cloudflareUploadEndedAtGT?: InputMaybe<Scalars['Time']['input']>;
  cloudflareUploadEndedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  cloudflareUploadEndedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  cloudflareUploadEndedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  cloudflareUploadEndedAtLT?: InputMaybe<Scalars['Time']['input']>;
  cloudflareUploadEndedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  cloudflareUploadEndedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  cloudflareUploadEndedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  cloudflareUploadEndedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** cloudflare_upload_error field predicates */
  cloudflareUploadError?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadErrorContains?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadErrorContainsFold?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadErrorEqualFold?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadErrorGT?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadErrorGTE?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadErrorHasPrefix?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadErrorHasSuffix?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadErrorIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cloudflareUploadErrorIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  cloudflareUploadErrorLT?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadErrorLTE?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadErrorNEQ?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadErrorNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cloudflareUploadErrorNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** cloudflare_upload_started_at field predicates */
  cloudflareUploadStartedAt?: InputMaybe<Scalars['Time']['input']>;
  cloudflareUploadStartedAtGT?: InputMaybe<Scalars['Time']['input']>;
  cloudflareUploadStartedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  cloudflareUploadStartedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  cloudflareUploadStartedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  cloudflareUploadStartedAtLT?: InputMaybe<Scalars['Time']['input']>;
  cloudflareUploadStartedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  cloudflareUploadStartedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  cloudflareUploadStartedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  cloudflareUploadStartedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** cloudflare_upload_status field predicates */
  cloudflareUploadStatus?: InputMaybe<VideoCloudflareUploadStatus>;
  cloudflareUploadStatusIn?: InputMaybe<Array<VideoCloudflareUploadStatus>>;
  cloudflareUploadStatusIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  cloudflareUploadStatusNEQ?: InputMaybe<VideoCloudflareUploadStatus>;
  cloudflareUploadStatusNotIn?: InputMaybe<Array<VideoCloudflareUploadStatus>>;
  cloudflareUploadStatusNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** cloudflare_upload_uid field predicates */
  cloudflareUploadUID?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadUIDContains?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadUIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadUIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadUIDGT?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadUIDGTE?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadUIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadUIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadUIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cloudflareUploadUIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  cloudflareUploadUIDLT?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadUIDLTE?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadUIDNEQ?: InputMaybe<Scalars['String']['input']>;
  cloudflareUploadUIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cloudflareUploadUIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** dash_url field predicates */
  dashURL?: InputMaybe<Scalars['String']['input']>;
  dashURLContains?: InputMaybe<Scalars['String']['input']>;
  dashURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  dashURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  dashURLGT?: InputMaybe<Scalars['String']['input']>;
  dashURLGTE?: InputMaybe<Scalars['String']['input']>;
  dashURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  dashURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  dashURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  dashURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  dashURLLT?: InputMaybe<Scalars['String']['input']>;
  dashURLLTE?: InputMaybe<Scalars['String']['input']>;
  dashURLNEQ?: InputMaybe<Scalars['String']['input']>;
  dashURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  dashURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** duration field predicates */
  duration?: InputMaybe<Scalars['Int']['input']>;
  durationGT?: InputMaybe<Scalars['Int']['input']>;
  durationGTE?: InputMaybe<Scalars['Int']['input']>;
  durationIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  durationIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  durationLT?: InputMaybe<Scalars['Int']['input']>;
  durationLTE?: InputMaybe<Scalars['Int']['input']>;
  durationNEQ?: InputMaybe<Scalars['Int']['input']>;
  durationNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  durationNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** generate_insights_ended_at field predicates */
  generateInsightsEndedAt?: InputMaybe<Scalars['Time']['input']>;
  generateInsightsEndedAtGT?: InputMaybe<Scalars['Time']['input']>;
  generateInsightsEndedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  generateInsightsEndedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  generateInsightsEndedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  generateInsightsEndedAtLT?: InputMaybe<Scalars['Time']['input']>;
  generateInsightsEndedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  generateInsightsEndedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  generateInsightsEndedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  generateInsightsEndedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** generate_insights_error field predicates */
  generateInsightsError?: InputMaybe<Scalars['String']['input']>;
  generateInsightsErrorContains?: InputMaybe<Scalars['String']['input']>;
  generateInsightsErrorContainsFold?: InputMaybe<Scalars['String']['input']>;
  generateInsightsErrorEqualFold?: InputMaybe<Scalars['String']['input']>;
  generateInsightsErrorGT?: InputMaybe<Scalars['String']['input']>;
  generateInsightsErrorGTE?: InputMaybe<Scalars['String']['input']>;
  generateInsightsErrorHasPrefix?: InputMaybe<Scalars['String']['input']>;
  generateInsightsErrorHasSuffix?: InputMaybe<Scalars['String']['input']>;
  generateInsightsErrorIn?: InputMaybe<Array<Scalars['String']['input']>>;
  generateInsightsErrorIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  generateInsightsErrorLT?: InputMaybe<Scalars['String']['input']>;
  generateInsightsErrorLTE?: InputMaybe<Scalars['String']['input']>;
  generateInsightsErrorNEQ?: InputMaybe<Scalars['String']['input']>;
  generateInsightsErrorNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  generateInsightsErrorNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** generate_insights_started_at field predicates */
  generateInsightsStartedAt?: InputMaybe<Scalars['Time']['input']>;
  generateInsightsStartedAtGT?: InputMaybe<Scalars['Time']['input']>;
  generateInsightsStartedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  generateInsightsStartedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  generateInsightsStartedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  generateInsightsStartedAtLT?: InputMaybe<Scalars['Time']['input']>;
  generateInsightsStartedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  generateInsightsStartedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  generateInsightsStartedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  generateInsightsStartedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** generate_insights_status field predicates */
  generateInsightsStatus?: InputMaybe<VideoGenerateInsightsStatus>;
  generateInsightsStatusIn?: InputMaybe<Array<VideoGenerateInsightsStatus>>;
  generateInsightsStatusIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  generateInsightsStatusNEQ?: InputMaybe<VideoGenerateInsightsStatus>;
  generateInsightsStatusNotIn?: InputMaybe<Array<VideoGenerateInsightsStatus>>;
  generateInsightsStatusNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** course edge predicates */
  hasCourse?: InputMaybe<Scalars['Boolean']['input']>;
  hasCourseWith?: InputMaybe<Array<CourseWhereInput>>;
  /** face_detection_request edge predicates */
  hasFaceDetectionRequest?: InputMaybe<Scalars['Boolean']['input']>;
  hasFaceDetectionRequestWith?: InputMaybe<Array<FaceDetectRequestWhereInput>>;
  /** frames edge predicates */
  hasFrames?: InputMaybe<Scalars['Boolean']['input']>;
  hasFramesWith?: InputMaybe<Array<VideoFrameWhereInput>>;
  /** google_drive_file edge predicates */
  hasGoogleDriveFile?: InputMaybe<Scalars['Boolean']['input']>;
  hasGoogleDriveFileWith?: InputMaybe<Array<GoogleDriveFileWhereInput>>;
  /** images edge predicates */
  hasImages?: InputMaybe<Scalars['Boolean']['input']>;
  hasImagesWith?: InputMaybe<Array<ImageWhereInput>>;
  /** imported_video edge predicates */
  hasImportedVideo?: InputMaybe<Scalars['Boolean']['input']>;
  hasImportedVideoWith?: InputMaybe<Array<ImportedVideoWhereInput>>;
  /** post edge predicates */
  hasPost?: InputMaybe<Scalars['Boolean']['input']>;
  hasPostWith?: InputMaybe<Array<PostWhereInput>>;
  /** suggested_learning_objectives edge predicates */
  hasSuggestedLearningObjectives?: InputMaybe<Scalars['Boolean']['input']>;
  hasSuggestedLearningObjectivesWith?: InputMaybe<Array<LearningObjectiveWhereInput>>;
  /** user_video_events edge predicates */
  hasUserVideoEvents?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserVideoEventsWith?: InputMaybe<Array<UserVideoEventWhereInput>>;
  /** height field predicates */
  height?: InputMaybe<Scalars['Int']['input']>;
  heightGT?: InputMaybe<Scalars['Int']['input']>;
  heightGTE?: InputMaybe<Scalars['Int']['input']>;
  heightIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  heightIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  heightLT?: InputMaybe<Scalars['Int']['input']>;
  heightLTE?: InputMaybe<Scalars['Int']['input']>;
  heightNEQ?: InputMaybe<Scalars['Int']['input']>;
  heightNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  heightNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** hls_url field predicates */
  hlsURL?: InputMaybe<Scalars['String']['input']>;
  hlsURLContains?: InputMaybe<Scalars['String']['input']>;
  hlsURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  hlsURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  hlsURLGT?: InputMaybe<Scalars['String']['input']>;
  hlsURLGTE?: InputMaybe<Scalars['String']['input']>;
  hlsURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  hlsURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  hlsURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  hlsURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  hlsURLLT?: InputMaybe<Scalars['String']['input']>;
  hlsURLLTE?: InputMaybe<Scalars['String']['input']>;
  hlsURLNEQ?: InputMaybe<Scalars['String']['input']>;
  hlsURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  hlsURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** insights_generated_at field predicates */
  insightsGeneratedAt?: InputMaybe<Scalars['Time']['input']>;
  insightsGeneratedAtGT?: InputMaybe<Scalars['Time']['input']>;
  insightsGeneratedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  insightsGeneratedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  insightsGeneratedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  insightsGeneratedAtLT?: InputMaybe<Scalars['Time']['input']>;
  insightsGeneratedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  insightsGeneratedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  insightsGeneratedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  insightsGeneratedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** likely_audience field predicates */
  likelyAudience?: InputMaybe<Scalars['String']['input']>;
  likelyAudienceContains?: InputMaybe<Scalars['String']['input']>;
  likelyAudienceContainsFold?: InputMaybe<Scalars['String']['input']>;
  likelyAudienceEqualFold?: InputMaybe<Scalars['String']['input']>;
  likelyAudienceGT?: InputMaybe<Scalars['String']['input']>;
  likelyAudienceGTE?: InputMaybe<Scalars['String']['input']>;
  likelyAudienceHasPrefix?: InputMaybe<Scalars['String']['input']>;
  likelyAudienceHasSuffix?: InputMaybe<Scalars['String']['input']>;
  likelyAudienceIn?: InputMaybe<Array<Scalars['String']['input']>>;
  likelyAudienceIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  likelyAudienceLT?: InputMaybe<Scalars['String']['input']>;
  likelyAudienceLTE?: InputMaybe<Scalars['String']['input']>;
  likelyAudienceNEQ?: InputMaybe<Scalars['String']['input']>;
  likelyAudienceNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  likelyAudienceNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<VideoWhereInput>;
  or?: InputMaybe<Array<VideoWhereInput>>;
  /** size field predicates */
  size?: InputMaybe<Scalars['Int']['input']>;
  sizeGT?: InputMaybe<Scalars['Int']['input']>;
  sizeGTE?: InputMaybe<Scalars['Int']['input']>;
  sizeIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  sizeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  sizeLT?: InputMaybe<Scalars['Int']['input']>;
  sizeLTE?: InputMaybe<Scalars['Int']['input']>;
  sizeNEQ?: InputMaybe<Scalars['Int']['input']>;
  sizeNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  sizeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** speak_media_id field predicates */
  speakMediaID?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDContains?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDGT?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDGTE?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  speakMediaIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  speakMediaIDLT?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDLTE?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDNEQ?: InputMaybe<Scalars['String']['input']>;
  speakMediaIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  speakMediaIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** status field predicates */
  status?: InputMaybe<VideoStatus>;
  statusIn?: InputMaybe<Array<VideoStatus>>;
  statusNEQ?: InputMaybe<VideoStatus>;
  statusNotIn?: InputMaybe<Array<VideoStatus>>;
  /** storage_key field predicates */
  storageKey?: InputMaybe<Scalars['String']['input']>;
  storageKeyContains?: InputMaybe<Scalars['String']['input']>;
  storageKeyContainsFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyEqualFold?: InputMaybe<Scalars['String']['input']>;
  storageKeyGT?: InputMaybe<Scalars['String']['input']>;
  storageKeyGTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  storageKeyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  storageKeyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  storageKeyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  storageKeyLT?: InputMaybe<Scalars['String']['input']>;
  storageKeyLTE?: InputMaybe<Scalars['String']['input']>;
  storageKeyNEQ?: InputMaybe<Scalars['String']['input']>;
  storageKeyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  storageKeyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** suggested_body field predicates */
  suggestedBody?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyContains?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyContainsFold?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyEqualFold?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyGT?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyGTE?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  suggestedBodyIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  suggestedBodyLT?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyLTE?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyNEQ?: InputMaybe<Scalars['String']['input']>;
  suggestedBodyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  suggestedBodyNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** suggested_title field predicates */
  suggestedTitle?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleContains?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleContainsFold?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleEqualFold?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleGT?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleGTE?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  suggestedTitleIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  suggestedTitleLT?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleLTE?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleNEQ?: InputMaybe<Scalars['String']['input']>;
  suggestedTitleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  suggestedTitleNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** terms_per_minute field predicates */
  termsPerMinute?: InputMaybe<Scalars['Float']['input']>;
  termsPerMinuteGT?: InputMaybe<Scalars['Float']['input']>;
  termsPerMinuteGTE?: InputMaybe<Scalars['Float']['input']>;
  termsPerMinuteIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  termsPerMinuteLT?: InputMaybe<Scalars['Float']['input']>;
  termsPerMinuteLTE?: InputMaybe<Scalars['Float']['input']>;
  termsPerMinuteNEQ?: InputMaybe<Scalars['Float']['input']>;
  termsPerMinuteNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  /** thumbnail_url field predicates */
  thumbnailURL?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLContains?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLGT?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLGTE?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  thumbnailURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  thumbnailURLLT?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLLTE?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLNEQ?: InputMaybe<Scalars['String']['input']>;
  thumbnailURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  thumbnailURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** transcode_ended_at field predicates */
  transcodeEndedAt?: InputMaybe<Scalars['Time']['input']>;
  transcodeEndedAtGT?: InputMaybe<Scalars['Time']['input']>;
  transcodeEndedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  transcodeEndedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  transcodeEndedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  transcodeEndedAtLT?: InputMaybe<Scalars['Time']['input']>;
  transcodeEndedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  transcodeEndedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  transcodeEndedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  transcodeEndedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** transcode_error field predicates */
  transcodeError?: InputMaybe<Scalars['String']['input']>;
  transcodeErrorContains?: InputMaybe<Scalars['String']['input']>;
  transcodeErrorContainsFold?: InputMaybe<Scalars['String']['input']>;
  transcodeErrorEqualFold?: InputMaybe<Scalars['String']['input']>;
  transcodeErrorGT?: InputMaybe<Scalars['String']['input']>;
  transcodeErrorGTE?: InputMaybe<Scalars['String']['input']>;
  transcodeErrorHasPrefix?: InputMaybe<Scalars['String']['input']>;
  transcodeErrorHasSuffix?: InputMaybe<Scalars['String']['input']>;
  transcodeErrorIn?: InputMaybe<Array<Scalars['String']['input']>>;
  transcodeErrorIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  transcodeErrorLT?: InputMaybe<Scalars['String']['input']>;
  transcodeErrorLTE?: InputMaybe<Scalars['String']['input']>;
  transcodeErrorNEQ?: InputMaybe<Scalars['String']['input']>;
  transcodeErrorNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  transcodeErrorNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** transcode_started_at field predicates */
  transcodeStartedAt?: InputMaybe<Scalars['Time']['input']>;
  transcodeStartedAtGT?: InputMaybe<Scalars['Time']['input']>;
  transcodeStartedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  transcodeStartedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  transcodeStartedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  transcodeStartedAtLT?: InputMaybe<Scalars['Time']['input']>;
  transcodeStartedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  transcodeStartedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  transcodeStartedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  transcodeStartedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** transcode_status field predicates */
  transcodeStatus?: InputMaybe<VideoTranscodeStatus>;
  transcodeStatusIn?: InputMaybe<Array<VideoTranscodeStatus>>;
  transcodeStatusIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  transcodeStatusNEQ?: InputMaybe<VideoTranscodeStatus>;
  transcodeStatusNotIn?: InputMaybe<Array<VideoTranscodeStatus>>;
  transcodeStatusNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** transcribe_ended_at field predicates */
  transcribeEndedAt?: InputMaybe<Scalars['Time']['input']>;
  transcribeEndedAtGT?: InputMaybe<Scalars['Time']['input']>;
  transcribeEndedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  transcribeEndedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  transcribeEndedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  transcribeEndedAtLT?: InputMaybe<Scalars['Time']['input']>;
  transcribeEndedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  transcribeEndedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  transcribeEndedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  transcribeEndedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** transcribe_error field predicates */
  transcribeError?: InputMaybe<Scalars['String']['input']>;
  transcribeErrorContains?: InputMaybe<Scalars['String']['input']>;
  transcribeErrorContainsFold?: InputMaybe<Scalars['String']['input']>;
  transcribeErrorEqualFold?: InputMaybe<Scalars['String']['input']>;
  transcribeErrorGT?: InputMaybe<Scalars['String']['input']>;
  transcribeErrorGTE?: InputMaybe<Scalars['String']['input']>;
  transcribeErrorHasPrefix?: InputMaybe<Scalars['String']['input']>;
  transcribeErrorHasSuffix?: InputMaybe<Scalars['String']['input']>;
  transcribeErrorIn?: InputMaybe<Array<Scalars['String']['input']>>;
  transcribeErrorIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  transcribeErrorLT?: InputMaybe<Scalars['String']['input']>;
  transcribeErrorLTE?: InputMaybe<Scalars['String']['input']>;
  transcribeErrorNEQ?: InputMaybe<Scalars['String']['input']>;
  transcribeErrorNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  transcribeErrorNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** transcribe_started_at field predicates */
  transcribeStartedAt?: InputMaybe<Scalars['Time']['input']>;
  transcribeStartedAtGT?: InputMaybe<Scalars['Time']['input']>;
  transcribeStartedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  transcribeStartedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  transcribeStartedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  transcribeStartedAtLT?: InputMaybe<Scalars['Time']['input']>;
  transcribeStartedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  transcribeStartedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  transcribeStartedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  transcribeStartedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** transcribe_status field predicates */
  transcribeStatus?: InputMaybe<VideoTranscribeStatus>;
  transcribeStatusIn?: InputMaybe<Array<VideoTranscribeStatus>>;
  transcribeStatusIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  transcribeStatusNEQ?: InputMaybe<VideoTranscribeStatus>;
  transcribeStatusNotIn?: InputMaybe<Array<VideoTranscribeStatus>>;
  transcribeStatusNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** transcription field predicates */
  transcription?: InputMaybe<Scalars['String']['input']>;
  transcriptionContains?: InputMaybe<Scalars['String']['input']>;
  transcriptionContainsFold?: InputMaybe<Scalars['String']['input']>;
  transcriptionEqualFold?: InputMaybe<Scalars['String']['input']>;
  transcriptionGT?: InputMaybe<Scalars['String']['input']>;
  transcriptionGTE?: InputMaybe<Scalars['String']['input']>;
  transcriptionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  transcriptionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  transcriptionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  transcriptionIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  transcriptionLT?: InputMaybe<Scalars['String']['input']>;
  transcriptionLTE?: InputMaybe<Scalars['String']['input']>;
  transcriptionNEQ?: InputMaybe<Scalars['String']['input']>;
  transcriptionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  transcriptionNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** vertical_dash_url field predicates */
  verticalDashURL?: InputMaybe<Scalars['String']['input']>;
  verticalDashURLContains?: InputMaybe<Scalars['String']['input']>;
  verticalDashURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  verticalDashURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  verticalDashURLGT?: InputMaybe<Scalars['String']['input']>;
  verticalDashURLGTE?: InputMaybe<Scalars['String']['input']>;
  verticalDashURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  verticalDashURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  verticalDashURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  verticalDashURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  verticalDashURLLT?: InputMaybe<Scalars['String']['input']>;
  verticalDashURLLTE?: InputMaybe<Scalars['String']['input']>;
  verticalDashURLNEQ?: InputMaybe<Scalars['String']['input']>;
  verticalDashURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  verticalDashURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** vertical_height field predicates */
  verticalHeight?: InputMaybe<Scalars['Int']['input']>;
  verticalHeightGT?: InputMaybe<Scalars['Int']['input']>;
  verticalHeightGTE?: InputMaybe<Scalars['Int']['input']>;
  verticalHeightIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  verticalHeightIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  verticalHeightLT?: InputMaybe<Scalars['Int']['input']>;
  verticalHeightLTE?: InputMaybe<Scalars['Int']['input']>;
  verticalHeightNEQ?: InputMaybe<Scalars['Int']['input']>;
  verticalHeightNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  verticalHeightNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** vertical_hls_url field predicates */
  verticalHlsURL?: InputMaybe<Scalars['String']['input']>;
  verticalHlsURLContains?: InputMaybe<Scalars['String']['input']>;
  verticalHlsURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  verticalHlsURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  verticalHlsURLGT?: InputMaybe<Scalars['String']['input']>;
  verticalHlsURLGTE?: InputMaybe<Scalars['String']['input']>;
  verticalHlsURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  verticalHlsURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  verticalHlsURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  verticalHlsURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  verticalHlsURLLT?: InputMaybe<Scalars['String']['input']>;
  verticalHlsURLLTE?: InputMaybe<Scalars['String']['input']>;
  verticalHlsURLNEQ?: InputMaybe<Scalars['String']['input']>;
  verticalHlsURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  verticalHlsURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** vertical_thumbnail_url field predicates */
  verticalThumbnailURL?: InputMaybe<Scalars['String']['input']>;
  verticalThumbnailURLContains?: InputMaybe<Scalars['String']['input']>;
  verticalThumbnailURLContainsFold?: InputMaybe<Scalars['String']['input']>;
  verticalThumbnailURLEqualFold?: InputMaybe<Scalars['String']['input']>;
  verticalThumbnailURLGT?: InputMaybe<Scalars['String']['input']>;
  verticalThumbnailURLGTE?: InputMaybe<Scalars['String']['input']>;
  verticalThumbnailURLHasPrefix?: InputMaybe<Scalars['String']['input']>;
  verticalThumbnailURLHasSuffix?: InputMaybe<Scalars['String']['input']>;
  verticalThumbnailURLIn?: InputMaybe<Array<Scalars['String']['input']>>;
  verticalThumbnailURLIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  verticalThumbnailURLLT?: InputMaybe<Scalars['String']['input']>;
  verticalThumbnailURLLTE?: InputMaybe<Scalars['String']['input']>;
  verticalThumbnailURLNEQ?: InputMaybe<Scalars['String']['input']>;
  verticalThumbnailURLNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  verticalThumbnailURLNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** vertical_uid field predicates */
  verticalUID?: InputMaybe<Scalars['String']['input']>;
  verticalUIDContains?: InputMaybe<Scalars['String']['input']>;
  verticalUIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  verticalUIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  verticalUIDGT?: InputMaybe<Scalars['String']['input']>;
  verticalUIDGTE?: InputMaybe<Scalars['String']['input']>;
  verticalUIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  verticalUIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  verticalUIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  verticalUIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  verticalUIDLT?: InputMaybe<Scalars['String']['input']>;
  verticalUIDLTE?: InputMaybe<Scalars['String']['input']>;
  verticalUIDNEQ?: InputMaybe<Scalars['String']['input']>;
  verticalUIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  verticalUIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** vertical_width field predicates */
  verticalWidth?: InputMaybe<Scalars['Int']['input']>;
  verticalWidthGT?: InputMaybe<Scalars['Int']['input']>;
  verticalWidthGTE?: InputMaybe<Scalars['Int']['input']>;
  verticalWidthIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  verticalWidthIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  verticalWidthLT?: InputMaybe<Scalars['Int']['input']>;
  verticalWidthLTE?: InputMaybe<Scalars['Int']['input']>;
  verticalWidthNEQ?: InputMaybe<Scalars['Int']['input']>;
  verticalWidthNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  verticalWidthNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** width field predicates */
  width?: InputMaybe<Scalars['Int']['input']>;
  widthGT?: InputMaybe<Scalars['Int']['input']>;
  widthGTE?: InputMaybe<Scalars['Int']['input']>;
  widthIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  widthIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  widthLT?: InputMaybe<Scalars['Int']['input']>;
  widthLTE?: InputMaybe<Scalars['Int']['input']>;
  widthNEQ?: InputMaybe<Scalars['Int']['input']>;
  widthNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  widthNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** wordcloud field predicates */
  wordcloud?: InputMaybe<Scalars['String']['input']>;
  wordcloudContains?: InputMaybe<Scalars['String']['input']>;
  wordcloudContainsFold?: InputMaybe<Scalars['String']['input']>;
  wordcloudEqualFold?: InputMaybe<Scalars['String']['input']>;
  wordcloudGT?: InputMaybe<Scalars['String']['input']>;
  wordcloudGTE?: InputMaybe<Scalars['String']['input']>;
  wordcloudHasPrefix?: InputMaybe<Scalars['String']['input']>;
  wordcloudHasSuffix?: InputMaybe<Scalars['String']['input']>;
  wordcloudIn?: InputMaybe<Array<Scalars['String']['input']>>;
  wordcloudIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  wordcloudLT?: InputMaybe<Scalars['String']['input']>;
  wordcloudLTE?: InputMaybe<Scalars['String']['input']>;
  wordcloudNEQ?: InputMaybe<Scalars['String']['input']>;
  wordcloudNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  wordcloudNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** workflow_id field predicates */
  workflowID?: InputMaybe<Scalars['String']['input']>;
  workflowIDContains?: InputMaybe<Scalars['String']['input']>;
  workflowIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  workflowIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  workflowIDGT?: InputMaybe<Scalars['String']['input']>;
  workflowIDGTE?: InputMaybe<Scalars['String']['input']>;
  workflowIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  workflowIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  workflowIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  workflowIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  workflowIDLT?: InputMaybe<Scalars['String']['input']>;
  workflowIDLTE?: InputMaybe<Scalars['String']['input']>;
  workflowIDNEQ?: InputMaybe<Scalars['String']['input']>;
  workflowIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  workflowIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** workflow_run_id field predicates */
  workflowRunID?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDContains?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDContainsFold?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDEqualFold?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDGT?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDGTE?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDHasPrefix?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDHasSuffix?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDIn?: InputMaybe<Array<Scalars['String']['input']>>;
  workflowRunIDIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  workflowRunIDLT?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDLTE?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDNEQ?: InputMaybe<Scalars['String']['input']>;
  workflowRunIDNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  workflowRunIDNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type WaitListConfig = Node & {
  __typename?: 'WaitListConfig';
  approvedMessage?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  joinedMessage?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of items. */
export type WaitListConfigConnection = {
  __typename?: 'WaitListConfigConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WaitListConfigEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type WaitListConfigEdge = {
  __typename?: 'WaitListConfigEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WaitListConfig>;
};

/**
 * WaitListConfigWhereInput is used for filtering WaitListConfig objects.
 * Input was generated by ent.
 */
export type WaitListConfigWhereInput = {
  and?: InputMaybe<Array<WaitListConfigWhereInput>>;
  /** approved_message field predicates */
  approvedMessage?: InputMaybe<Scalars['String']['input']>;
  approvedMessageContains?: InputMaybe<Scalars['String']['input']>;
  approvedMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  approvedMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  approvedMessageGT?: InputMaybe<Scalars['String']['input']>;
  approvedMessageGTE?: InputMaybe<Scalars['String']['input']>;
  approvedMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  approvedMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  approvedMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  approvedMessageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  approvedMessageLT?: InputMaybe<Scalars['String']['input']>;
  approvedMessageLTE?: InputMaybe<Scalars['String']['input']>;
  approvedMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  approvedMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  approvedMessageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** joined_message field predicates */
  joinedMessage?: InputMaybe<Scalars['String']['input']>;
  joinedMessageContains?: InputMaybe<Scalars['String']['input']>;
  joinedMessageContainsFold?: InputMaybe<Scalars['String']['input']>;
  joinedMessageEqualFold?: InputMaybe<Scalars['String']['input']>;
  joinedMessageGT?: InputMaybe<Scalars['String']['input']>;
  joinedMessageGTE?: InputMaybe<Scalars['String']['input']>;
  joinedMessageHasPrefix?: InputMaybe<Scalars['String']['input']>;
  joinedMessageHasSuffix?: InputMaybe<Scalars['String']['input']>;
  joinedMessageIn?: InputMaybe<Array<Scalars['String']['input']>>;
  joinedMessageIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  joinedMessageLT?: InputMaybe<Scalars['String']['input']>;
  joinedMessageLTE?: InputMaybe<Scalars['String']['input']>;
  joinedMessageNEQ?: InputMaybe<Scalars['String']['input']>;
  joinedMessageNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  joinedMessageNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<WaitListConfigWhereInput>;
  or?: InputMaybe<Array<WaitListConfigWhereInput>>;
};

export type WaitlistEntry = Node & {
  __typename?: 'WaitlistEntry';
  createdAt: Scalars['Time']['output'];
  email?: Maybe<Scalars['String']['output']>;
  firstName: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  lastName: Scalars['String']['output'];
  /** The NPI number for this entry */
  npiNumber?: Maybe<Scalars['String']['output']>;
  npiSearchResults?: Maybe<Array<RegistryResult>>;
  /** The phone number for this entry, stored in E.164 format. */
  phone: Scalars['String']['output'];
  /** The status of the entry */
  status: WaitlistEntryStatus;
  /** The total number of NPI results found */
  totalNpiResults: Scalars['Int']['output'];
  updatedAt: Scalars['Time']['output'];
};

/** A connection to a list of items. */
export type WaitlistEntryConnection = {
  __typename?: 'WaitlistEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WaitlistEntryEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type WaitlistEntryEdge = {
  __typename?: 'WaitlistEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WaitlistEntry>;
};

/** Ordering options for WaitlistEntry connections */
export type WaitlistEntryOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order WaitlistEntries. */
  field: WaitlistEntryOrderField;
};

/** Properties by which WaitlistEntry connections can be ordered. */
export enum WaitlistEntryOrderField {
  CreatedAt = 'CREATED_AT',
  UpdatedAt = 'UPDATED_AT'
}

/** WaitlistEntryStatus is enum for the field status */
export enum WaitlistEntryStatus {
  Approved = 'approved',
  Denied = 'denied',
  Pending = 'pending'
}

/**
 * WaitlistEntryWhereInput is used for filtering WaitlistEntry objects.
 * Input was generated by ent.
 */
export type WaitlistEntryWhereInput = {
  and?: InputMaybe<Array<WaitlistEntryWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']['input']>;
  emailContains?: InputMaybe<Scalars['String']['input']>;
  emailContainsFold?: InputMaybe<Scalars['String']['input']>;
  emailEqualFold?: InputMaybe<Scalars['String']['input']>;
  emailGT?: InputMaybe<Scalars['String']['input']>;
  emailGTE?: InputMaybe<Scalars['String']['input']>;
  emailHasPrefix?: InputMaybe<Scalars['String']['input']>;
  emailHasSuffix?: InputMaybe<Scalars['String']['input']>;
  emailIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  emailLT?: InputMaybe<Scalars['String']['input']>;
  emailLTE?: InputMaybe<Scalars['String']['input']>;
  emailNEQ?: InputMaybe<Scalars['String']['input']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  emailNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** first_name field predicates */
  firstName?: InputMaybe<Scalars['String']['input']>;
  firstNameContains?: InputMaybe<Scalars['String']['input']>;
  firstNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  firstNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  firstNameGT?: InputMaybe<Scalars['String']['input']>;
  firstNameGTE?: InputMaybe<Scalars['String']['input']>;
  firstNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  firstNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  firstNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  firstNameLT?: InputMaybe<Scalars['String']['input']>;
  firstNameLTE?: InputMaybe<Scalars['String']['input']>;
  firstNameNEQ?: InputMaybe<Scalars['String']['input']>;
  firstNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_name field predicates */
  lastName?: InputMaybe<Scalars['String']['input']>;
  lastNameContains?: InputMaybe<Scalars['String']['input']>;
  lastNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  lastNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  lastNameGT?: InputMaybe<Scalars['String']['input']>;
  lastNameGTE?: InputMaybe<Scalars['String']['input']>;
  lastNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  lastNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  lastNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  lastNameLT?: InputMaybe<Scalars['String']['input']>;
  lastNameLTE?: InputMaybe<Scalars['String']['input']>;
  lastNameNEQ?: InputMaybe<Scalars['String']['input']>;
  lastNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<WaitlistEntryWhereInput>;
  /** npi_number field predicates */
  npiNumber?: InputMaybe<Scalars['String']['input']>;
  npiNumberContains?: InputMaybe<Scalars['String']['input']>;
  npiNumberContainsFold?: InputMaybe<Scalars['String']['input']>;
  npiNumberEqualFold?: InputMaybe<Scalars['String']['input']>;
  npiNumberGT?: InputMaybe<Scalars['String']['input']>;
  npiNumberGTE?: InputMaybe<Scalars['String']['input']>;
  npiNumberHasPrefix?: InputMaybe<Scalars['String']['input']>;
  npiNumberHasSuffix?: InputMaybe<Scalars['String']['input']>;
  npiNumberIn?: InputMaybe<Array<Scalars['String']['input']>>;
  npiNumberIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  npiNumberLT?: InputMaybe<Scalars['String']['input']>;
  npiNumberLTE?: InputMaybe<Scalars['String']['input']>;
  npiNumberNEQ?: InputMaybe<Scalars['String']['input']>;
  npiNumberNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  npiNumberNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  or?: InputMaybe<Array<WaitlistEntryWhereInput>>;
  /** phone field predicates */
  phone?: InputMaybe<Scalars['String']['input']>;
  phoneContains?: InputMaybe<Scalars['String']['input']>;
  phoneContainsFold?: InputMaybe<Scalars['String']['input']>;
  phoneEqualFold?: InputMaybe<Scalars['String']['input']>;
  phoneGT?: InputMaybe<Scalars['String']['input']>;
  phoneGTE?: InputMaybe<Scalars['String']['input']>;
  phoneHasPrefix?: InputMaybe<Scalars['String']['input']>;
  phoneHasSuffix?: InputMaybe<Scalars['String']['input']>;
  phoneIn?: InputMaybe<Array<Scalars['String']['input']>>;
  phoneLT?: InputMaybe<Scalars['String']['input']>;
  phoneLTE?: InputMaybe<Scalars['String']['input']>;
  phoneNEQ?: InputMaybe<Scalars['String']['input']>;
  phoneNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** status field predicates */
  status?: InputMaybe<WaitlistEntryStatus>;
  statusIn?: InputMaybe<Array<WaitlistEntryStatus>>;
  statusNEQ?: InputMaybe<WaitlistEntryStatus>;
  statusNotIn?: InputMaybe<Array<WaitlistEntryStatus>>;
  /** total_npi_results field predicates */
  totalNpiResults?: InputMaybe<Scalars['Int']['input']>;
  totalNpiResultsGT?: InputMaybe<Scalars['Int']['input']>;
  totalNpiResultsGTE?: InputMaybe<Scalars['Int']['input']>;
  totalNpiResultsIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  totalNpiResultsLT?: InputMaybe<Scalars['Int']['input']>;
  totalNpiResultsLTE?: InputMaybe<Scalars['Int']['input']>;
  totalNpiResultsNEQ?: InputMaybe<Scalars['Int']['input']>;
  totalNpiResultsNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type WatchHistoryForLearningObjective = {
  __typename?: 'WatchHistoryForLearningObjective';
  educationCredits: Array<EducationCredit>;
  learningObjective: LearningObjective;
  surveyQuestions: Array<CertificateSurveyQuestion>;
  totalCredits: Scalars['Float']['output'];
  totalVideos: Scalars['Int']['output'];
};

export type WorkExperience = Node & {
  __typename?: 'WorkExperience';
  /** The city of the work experience. */
  city: Scalars['String']['output'];
  /** The employment type of the work experience. */
  employment: WorkExperienceEmployment;
  /** The end date of the work experience. */
  endDate?: Maybe<Scalars['Time']['output']>;
  id: Scalars['ID']['output'];
  /** The institution of the work experience. */
  institution: Scalars['String']['output'];
  /** The specialty of the work experience. */
  specialty: Scalars['String']['output'];
  /** The start date of the work experience. */
  startDate?: Maybe<Scalars['Time']['output']>;
  /** The state of the work experience. */
  state: Scalars['String']['output'];
  /** The title of the work experience. */
  title: Scalars['String']['output'];
  /** The user that the work experience is for. */
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type WorkExperienceConnection = {
  __typename?: 'WorkExperienceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkExperienceEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type WorkExperienceEdge = {
  __typename?: 'WorkExperienceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WorkExperience>;
};

/** WorkExperienceEmployment is enum for the field employment */
export enum WorkExperienceEmployment {
  FullTime = 'full_time',
  Internship = 'internship',
  PartTime = 'part_time',
  Unknown = 'unknown',
  Volunteer = 'volunteer'
}

/**
 * WorkExperienceWhereInput is used for filtering WorkExperience objects.
 * Input was generated by ent.
 */
export type WorkExperienceWhereInput = {
  and?: InputMaybe<Array<WorkExperienceWhereInput>>;
  /** city field predicates */
  city?: InputMaybe<Scalars['String']['input']>;
  cityContains?: InputMaybe<Scalars['String']['input']>;
  cityContainsFold?: InputMaybe<Scalars['String']['input']>;
  cityEqualFold?: InputMaybe<Scalars['String']['input']>;
  cityGT?: InputMaybe<Scalars['String']['input']>;
  cityGTE?: InputMaybe<Scalars['String']['input']>;
  cityHasPrefix?: InputMaybe<Scalars['String']['input']>;
  cityHasSuffix?: InputMaybe<Scalars['String']['input']>;
  cityIn?: InputMaybe<Array<Scalars['String']['input']>>;
  cityLT?: InputMaybe<Scalars['String']['input']>;
  cityLTE?: InputMaybe<Scalars['String']['input']>;
  cityNEQ?: InputMaybe<Scalars['String']['input']>;
  cityNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** employment field predicates */
  employment?: InputMaybe<WorkExperienceEmployment>;
  employmentIn?: InputMaybe<Array<WorkExperienceEmployment>>;
  employmentNEQ?: InputMaybe<WorkExperienceEmployment>;
  employmentNotIn?: InputMaybe<Array<WorkExperienceEmployment>>;
  /** end_date field predicates */
  endDate?: InputMaybe<Scalars['Time']['input']>;
  endDateGT?: InputMaybe<Scalars['Time']['input']>;
  endDateGTE?: InputMaybe<Scalars['Time']['input']>;
  endDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  endDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  endDateLT?: InputMaybe<Scalars['Time']['input']>;
  endDateLTE?: InputMaybe<Scalars['Time']['input']>;
  endDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  endDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  endDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']['input']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** institution field predicates */
  institution?: InputMaybe<Scalars['String']['input']>;
  institutionContains?: InputMaybe<Scalars['String']['input']>;
  institutionContainsFold?: InputMaybe<Scalars['String']['input']>;
  institutionEqualFold?: InputMaybe<Scalars['String']['input']>;
  institutionGT?: InputMaybe<Scalars['String']['input']>;
  institutionGTE?: InputMaybe<Scalars['String']['input']>;
  institutionHasPrefix?: InputMaybe<Scalars['String']['input']>;
  institutionHasSuffix?: InputMaybe<Scalars['String']['input']>;
  institutionIn?: InputMaybe<Array<Scalars['String']['input']>>;
  institutionLT?: InputMaybe<Scalars['String']['input']>;
  institutionLTE?: InputMaybe<Scalars['String']['input']>;
  institutionNEQ?: InputMaybe<Scalars['String']['input']>;
  institutionNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<WorkExperienceWhereInput>;
  or?: InputMaybe<Array<WorkExperienceWhereInput>>;
  /** specialty field predicates */
  specialty?: InputMaybe<Scalars['String']['input']>;
  specialtyContains?: InputMaybe<Scalars['String']['input']>;
  specialtyContainsFold?: InputMaybe<Scalars['String']['input']>;
  specialtyEqualFold?: InputMaybe<Scalars['String']['input']>;
  specialtyGT?: InputMaybe<Scalars['String']['input']>;
  specialtyGTE?: InputMaybe<Scalars['String']['input']>;
  specialtyHasPrefix?: InputMaybe<Scalars['String']['input']>;
  specialtyHasSuffix?: InputMaybe<Scalars['String']['input']>;
  specialtyIn?: InputMaybe<Array<Scalars['String']['input']>>;
  specialtyLT?: InputMaybe<Scalars['String']['input']>;
  specialtyLTE?: InputMaybe<Scalars['String']['input']>;
  specialtyNEQ?: InputMaybe<Scalars['String']['input']>;
  specialtyNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** start_date field predicates */
  startDate?: InputMaybe<Scalars['Time']['input']>;
  startDateGT?: InputMaybe<Scalars['Time']['input']>;
  startDateGTE?: InputMaybe<Scalars['Time']['input']>;
  startDateIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startDateIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  startDateLT?: InputMaybe<Scalars['Time']['input']>;
  startDateLTE?: InputMaybe<Scalars['Time']['input']>;
  startDateNEQ?: InputMaybe<Scalars['Time']['input']>;
  startDateNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  startDateNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** state field predicates */
  state?: InputMaybe<Scalars['String']['input']>;
  stateContains?: InputMaybe<Scalars['String']['input']>;
  stateContainsFold?: InputMaybe<Scalars['String']['input']>;
  stateEqualFold?: InputMaybe<Scalars['String']['input']>;
  stateGT?: InputMaybe<Scalars['String']['input']>;
  stateGTE?: InputMaybe<Scalars['String']['input']>;
  stateHasPrefix?: InputMaybe<Scalars['String']['input']>;
  stateHasSuffix?: InputMaybe<Scalars['String']['input']>;
  stateIn?: InputMaybe<Array<Scalars['String']['input']>>;
  stateLT?: InputMaybe<Scalars['String']['input']>;
  stateLTE?: InputMaybe<Scalars['String']['input']>;
  stateNEQ?: InputMaybe<Scalars['String']['input']>;
  stateNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type CurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrentUserQuery = { __typename?: 'Query', currentUser: { __typename?: 'User', id: string, streamToken: string, firstName?: string | null, lastName?: string | null } };

export type MedicalSearchSubscriptionVariables = Exact<{ [key: string]: never; }>;


export type MedicalSearchSubscription = { __typename?: 'Subscription', medicalSearchResponse: { __typename?: 'MedicalSearchEvent', text: string, citation?: { __typename?: 'OpenEvidenceReference', citationKey: number, referenceText: string, referenceDetail: { __typename?: 'OpenEvidenceReferenceDetail', title: string, authorsString: string, publicationInfoString: string, journalName: string, journalShortName: string, publicationDate: string, doi: string, url: string } } | null } };

export type SparkyMessageQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type SparkyMessageQuery = { __typename?: 'Query', node?: { __typename?: 'AccountConnection' } | { __typename?: 'AnatomicalModel' } | { __typename?: 'ApiQueryLog' } | { __typename?: 'ApiToken' } | { __typename?: 'Article' } | { __typename?: 'ArticleFeed' } | { __typename?: 'Audience' } | { __typename?: 'AuditLog' } | { __typename?: 'BoardCertification' } | { __typename?: 'Bookmark' } | { __typename?: 'Certificate' } | { __typename?: 'CertificateSurveyAnswer' } | { __typename?: 'CertificateSurveyQuestion' } | { __typename?: 'CertificateSurveyQuestionChoice' } | { __typename?: 'CertifyingBoard' } | { __typename?: 'ClinicalTrial' } | { __typename?: 'ClinicalTrialDocument' } | { __typename?: 'ClinicalTrialEmbedding' } | { __typename?: 'CloudflareUpload' } | { __typename?: 'Collection' } | { __typename?: 'Comment' } | { __typename?: 'CommentLike' } | { __typename?: 'CommentNamedEntity' } | { __typename?: 'Course' } | { __typename?: 'Dashboard' } | { __typename?: 'EducationCredit' } | { __typename?: 'EducationHistory' } | { __typename?: 'EducationRequirement' } | { __typename?: 'FaceDetectRequest' } | { __typename?: 'FinancialDisclosure' } | { __typename?: 'FinancialDisclosurePrintTemplate' } | { __typename?: 'FinancialDisclosureRole' } | { __typename?: 'FinancialDisclosureStatement' } | { __typename?: 'GiblibVideo' } | { __typename?: 'GoogleDriveFile' } | { __typename?: 'GptLog' } | { __typename?: 'HumanOntologyNode' } | { __typename?: 'Image' } | { __typename?: 'ImportedVideo' } | { __typename?: 'InsightRequest' } | { __typename?: 'InstagramScrapeLog' } | { __typename?: 'JobHistory' } | { __typename?: 'LanguageModelLog' } | { __typename?: 'LanguageModelResponse' } | { __typename?: 'LearningObjective' } | { __typename?: 'LicenseHistory' } | { __typename?: 'Like' } | { __typename?: 'MediaItem' } | { __typename?: 'MedicalHealthTerm' } | { __typename?: 'MedicalSubjectHeading' } | { __typename?: 'Notification' } | { __typename?: 'NotificationConfig' } | { __typename?: 'NpiTaxonomy' } | { __typename?: 'Office' } | { __typename?: 'PhoneVerificationToken' } | { __typename?: 'Poll' } | { __typename?: 'PollAnswer' } | { __typename?: 'PollQuestion' } | { __typename?: 'Post' } | { __typename?: 'PostCitation' } | { __typename?: 'PostCollection' } | { __typename?: 'PostEmbedding' } | { __typename?: 'PostLearningObjective' } | { __typename?: 'PostReaction' } | { __typename?: 'PostReport' } | { __typename?: 'Provider' } | { __typename?: 'PubmedAbstractEmbedding' } | { __typename?: 'PubmedArticle' } | { __typename?: 'PubmedArticleAbstract' } | { __typename?: 'PubmedArticleEmbedding' } | { __typename?: 'PubmedCentralArticle' } | { __typename?: 'PubmedDownloadLog' } | { __typename?: 'PubmedTopicCluster' } | { __typename?: 'ReflectionAnalysis' } | { __typename?: 'ReflectionAnalysisResult' } | { __typename?: 'ReflectionAnalysisScore' } | { __typename?: 'ReflectionCriteria' } | { __typename?: 'ReflectionCriteriaGroup' } | { __typename?: 'ReflectionExperiment' } | { __typename?: 'ReflectionExperimentRun' } | { __typename?: 'ReportReason' } | { __typename?: 'Search' } | { __typename?: 'SearchConversion' } | { __typename?: 'SparkyChat' } | { __typename?: 'SparkyChatConfig' } | { __typename?: 'SparkyChatMessage' } | { __typename?: 'SparkyConversation' } | { __typename?: 'SparkyConversationConfigSet' } | { __typename?: 'SparkyMessage', notHelpful: boolean, isHelpful: boolean, conversation?: { __typename?: 'SparkyConversation', id: string } | null, opengraphReferences?: Array<{ __typename?: 'OpenGraphReference', title: string, description: string, url: string, image: string }> | null, references?: Array<{ __typename?: 'OpenEvidenceReference', citationKey: number, sourceTexts: Array<string>, referenceText: string, referenceDetail: { __typename?: 'OpenEvidenceReferenceDetail', doi: string, url: string, title: string, journalName: string, authorsString: string, publicationDate: string, publicationInfoString: string } }> | null } | { __typename?: 'SparkyPrompt' } | { __typename?: 'SparkyQuery' } | { __typename?: 'SparkyRule' } | { __typename?: 'SparkyRuleCondition' } | { __typename?: 'SparkyRuleField' } | { __typename?: 'Tag' } | { __typename?: 'Tenant' } | { __typename?: 'Topic' } | { __typename?: 'TopicClassification' } | { __typename?: 'TopicCluster' } | { __typename?: 'TopicNpiTaxonomy' } | { __typename?: 'TopicPubmedTopicCluster' } | { __typename?: 'TranscriptionRequest' } | { __typename?: 'Upload' } | { __typename?: 'User' } | { __typename?: 'UserAnalyticsEvent' } | { __typename?: 'UserBlock' } | { __typename?: 'UserCohort' } | { __typename?: 'UserCollectionCompletion' } | { __typename?: 'UserFeedHistory' } | { __typename?: 'UserLink' } | { __typename?: 'UserMute' } | { __typename?: 'UserNotificationToken' } | { __typename?: 'UserReport' } | { __typename?: 'UserTenant' } | { __typename?: 'UserVideoEvent' } | { __typename?: 'VerificationRequest' } | { __typename?: 'Video' } | { __typename?: 'VideoFrame' } | { __typename?: 'VideoPipeline' } | { __typename?: 'WaitListConfig' } | { __typename?: 'WaitlistEntry' } | { __typename?: 'WorkExperience' } | null };

export type SparkyMessagesQueryVariables = Exact<{
  where: SparkyMessageWhereInput;
}>;


export type SparkyMessagesQuery = { __typename?: 'Query', sparkyMessages: { __typename?: 'SparkyMessageConnection', edges?: Array<{ __typename?: 'SparkyMessageEdge', node?: { __typename?: 'SparkyMessage', id: string, body: string, notHelpful: boolean, isHelpful: boolean, conversation?: { __typename?: 'SparkyConversation', id: string, convertedFromModel?: string | null } | null, opengraphReferences?: Array<{ __typename?: 'OpenGraphReference', title: string, description: string, url: string, image: string }> | null, references?: Array<{ __typename?: 'OpenEvidenceReference', citationKey: number, sourceTexts: Array<string>, referenceText: string, referenceDetail: { __typename?: 'OpenEvidenceReferenceDetail', doi: string, url: string, title: string, journalName: string, authorsString: string, publicationDate: string, publicationInfoString: string } }> | null } | null } | null> | null } };

export type SparkyConversationQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type SparkyConversationQuery = { __typename?: 'Query', node?: { __typename?: 'AccountConnection' } | { __typename?: 'AnatomicalModel' } | { __typename?: 'ApiQueryLog' } | { __typename?: 'ApiToken' } | { __typename?: 'Article' } | { __typename?: 'ArticleFeed' } | { __typename?: 'Audience' } | { __typename?: 'AuditLog' } | { __typename?: 'BoardCertification' } | { __typename?: 'Bookmark' } | { __typename?: 'Certificate' } | { __typename?: 'CertificateSurveyAnswer' } | { __typename?: 'CertificateSurveyQuestion' } | { __typename?: 'CertificateSurveyQuestionChoice' } | { __typename?: 'CertifyingBoard' } | { __typename?: 'ClinicalTrial' } | { __typename?: 'ClinicalTrialDocument' } | { __typename?: 'ClinicalTrialEmbedding' } | { __typename?: 'CloudflareUpload' } | { __typename?: 'Collection' } | { __typename?: 'Comment' } | { __typename?: 'CommentLike' } | { __typename?: 'CommentNamedEntity' } | { __typename?: 'Course' } | { __typename?: 'Dashboard' } | { __typename?: 'EducationCredit' } | { __typename?: 'EducationHistory' } | { __typename?: 'EducationRequirement' } | { __typename?: 'FaceDetectRequest' } | { __typename?: 'FinancialDisclosure' } | { __typename?: 'FinancialDisclosurePrintTemplate' } | { __typename?: 'FinancialDisclosureRole' } | { __typename?: 'FinancialDisclosureStatement' } | { __typename?: 'GiblibVideo' } | { __typename?: 'GoogleDriveFile' } | { __typename?: 'GptLog' } | { __typename?: 'HumanOntologyNode' } | { __typename?: 'Image' } | { __typename?: 'ImportedVideo' } | { __typename?: 'InsightRequest' } | { __typename?: 'InstagramScrapeLog' } | { __typename?: 'JobHistory' } | { __typename?: 'LanguageModelLog' } | { __typename?: 'LanguageModelResponse' } | { __typename?: 'LearningObjective' } | { __typename?: 'LicenseHistory' } | { __typename?: 'Like' } | { __typename?: 'MediaItem' } | { __typename?: 'MedicalHealthTerm' } | { __typename?: 'MedicalSubjectHeading' } | { __typename?: 'Notification' } | { __typename?: 'NotificationConfig' } | { __typename?: 'NpiTaxonomy' } | { __typename?: 'Office' } | { __typename?: 'PhoneVerificationToken' } | { __typename?: 'Poll' } | { __typename?: 'PollAnswer' } | { __typename?: 'PollQuestion' } | { __typename?: 'Post' } | { __typename?: 'PostCitation' } | { __typename?: 'PostCollection' } | { __typename?: 'PostEmbedding' } | { __typename?: 'PostLearningObjective' } | { __typename?: 'PostReaction' } | { __typename?: 'PostReport' } | { __typename?: 'Provider' } | { __typename?: 'PubmedAbstractEmbedding' } | { __typename?: 'PubmedArticle' } | { __typename?: 'PubmedArticleAbstract' } | { __typename?: 'PubmedArticleEmbedding' } | { __typename?: 'PubmedCentralArticle' } | { __typename?: 'PubmedDownloadLog' } | { __typename?: 'PubmedTopicCluster' } | { __typename?: 'ReflectionAnalysis' } | { __typename?: 'ReflectionAnalysisResult' } | { __typename?: 'ReflectionAnalysisScore' } | { __typename?: 'ReflectionCriteria' } | { __typename?: 'ReflectionCriteriaGroup' } | { __typename?: 'ReflectionExperiment' } | { __typename?: 'ReflectionExperimentRun' } | { __typename?: 'ReportReason' } | { __typename?: 'Search' } | { __typename?: 'SearchConversion' } | { __typename?: 'SparkyChat' } | { __typename?: 'SparkyChatConfig' } | { __typename?: 'SparkyChatMessage' } | { __typename?: 'SparkyConversation', id: string, token?: string | null, model?: string | null, createdAt: any, messages?: Array<{ __typename?: 'SparkyMessage', body: string, notHelpful: boolean, isHelpful: boolean }> | null, targetConversation?: { __typename?: 'SparkyConversation', id: string, token?: string | null } | null } | { __typename?: 'SparkyConversationConfigSet' } | { __typename?: 'SparkyMessage' } | { __typename?: 'SparkyPrompt' } | { __typename?: 'SparkyQuery' } | { __typename?: 'SparkyRule' } | { __typename?: 'SparkyRuleCondition' } | { __typename?: 'SparkyRuleField' } | { __typename?: 'Tag' } | { __typename?: 'Tenant' } | { __typename?: 'Topic' } | { __typename?: 'TopicClassification' } | { __typename?: 'TopicCluster' } | { __typename?: 'TopicNpiTaxonomy' } | { __typename?: 'TopicPubmedTopicCluster' } | { __typename?: 'TranscriptionRequest' } | { __typename?: 'Upload' } | { __typename?: 'User' } | { __typename?: 'UserAnalyticsEvent' } | { __typename?: 'UserBlock' } | { __typename?: 'UserCohort' } | { __typename?: 'UserCollectionCompletion' } | { __typename?: 'UserFeedHistory' } | { __typename?: 'UserLink' } | { __typename?: 'UserMute' } | { __typename?: 'UserNotificationToken' } | { __typename?: 'UserReport' } | { __typename?: 'UserTenant' } | { __typename?: 'UserVideoEvent' } | { __typename?: 'VerificationRequest' } | { __typename?: 'Video' } | { __typename?: 'VideoFrame' } | { __typename?: 'VideoPipeline' } | { __typename?: 'WaitListConfig' } | { __typename?: 'WaitlistEntry' } | { __typename?: 'WorkExperience' } | null };

export type SparkyConversationsQueryVariables = Exact<{
  where: SparkyConversationWhereInput;
}>;


export type SparkyConversationsQuery = { __typename?: 'Query', sparkyConversations: { __typename?: 'SparkyConversationConnection', edges?: Array<{ __typename?: 'SparkyConversationEdge', node?: { __typename?: 'SparkyConversation', id: string, token?: string | null, model?: string | null, createdAt: any, educationCredit?: { __typename?: 'EducationCredit', id: string } | null, messages?: Array<{ __typename?: 'SparkyMessage', id: string, body: string, notHelpful: boolean, isHelpful: boolean, sentBySparky: boolean }> | null } | null } | null> | null } };

export type AdminCreateConversationFromConversationMutationVariables = Exact<{
  conversationId: Scalars['ID']['input'];
}>;


export type AdminCreateConversationFromConversationMutation = { __typename?: 'Mutation', adminCreateConversationFromConversation: { __typename?: 'SparkyConversation', id: string, token?: string | null } };

export type CreateConversationMutationVariables = Exact<{
  model: ConversationModel;
  initialMessage?: InputMaybe<Scalars['String']['input']>;
}>;


export type CreateConversationMutation = { __typename?: 'Mutation', createConversation: { __typename?: 'SparkyConversation', token?: string | null } };

export type ReflectOnConversationMutationVariables = Exact<{
  conversationId: Scalars['ID']['input'];
}>;


export type ReflectOnConversationMutation = { __typename?: 'Mutation', reflectOnConversation: { __typename?: 'SparkyConversation', id: string } };

export type FlagMessageNotHelpfulMutationVariables = Exact<{
  messageId: Scalars['ID']['input'];
}>;


export type FlagMessageNotHelpfulMutation = { __typename?: 'Mutation', flagMessageNotHelpful: boolean };

export type FlagMessageHelpfulMutationVariables = Exact<{
  messageId: Scalars['ID']['input'];
}>;


export type FlagMessageHelpfulMutation = { __typename?: 'Mutation', flagMessageHelpful: boolean };

export type PostQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type PostQuery = { __typename?: 'Query', node?: { __typename?: 'AccountConnection' } | { __typename?: 'AnatomicalModel' } | { __typename?: 'ApiQueryLog' } | { __typename?: 'ApiToken' } | { __typename?: 'Article' } | { __typename?: 'ArticleFeed' } | { __typename?: 'Audience' } | { __typename?: 'AuditLog' } | { __typename?: 'BoardCertification' } | { __typename?: 'Bookmark' } | { __typename?: 'Certificate' } | { __typename?: 'CertificateSurveyAnswer' } | { __typename?: 'CertificateSurveyQuestion' } | { __typename?: 'CertificateSurveyQuestionChoice' } | { __typename?: 'CertifyingBoard' } | { __typename?: 'ClinicalTrial' } | { __typename?: 'ClinicalTrialDocument' } | { __typename?: 'ClinicalTrialEmbedding' } | { __typename?: 'CloudflareUpload' } | { __typename?: 'Collection' } | { __typename?: 'Comment' } | { __typename?: 'CommentLike' } | { __typename?: 'CommentNamedEntity' } | { __typename?: 'Course' } | { __typename?: 'Dashboard' } | { __typename?: 'EducationCredit' } | { __typename?: 'EducationHistory' } | { __typename?: 'EducationRequirement' } | { __typename?: 'FaceDetectRequest' } | { __typename?: 'FinancialDisclosure' } | { __typename?: 'FinancialDisclosurePrintTemplate' } | { __typename?: 'FinancialDisclosureRole' } | { __typename?: 'FinancialDisclosureStatement' } | { __typename?: 'GiblibVideo' } | { __typename?: 'GoogleDriveFile' } | { __typename?: 'GptLog' } | { __typename?: 'HumanOntologyNode' } | { __typename?: 'Image' } | { __typename?: 'ImportedVideo' } | { __typename?: 'InsightRequest' } | { __typename?: 'InstagramScrapeLog' } | { __typename?: 'JobHistory' } | { __typename?: 'LanguageModelLog' } | { __typename?: 'LanguageModelResponse' } | { __typename?: 'LearningObjective' } | { __typename?: 'LicenseHistory' } | { __typename?: 'Like' } | { __typename?: 'MediaItem' } | { __typename?: 'MedicalHealthTerm' } | { __typename?: 'MedicalSubjectHeading' } | { __typename?: 'Notification' } | { __typename?: 'NotificationConfig' } | { __typename?: 'NpiTaxonomy' } | { __typename?: 'Office' } | { __typename?: 'PhoneVerificationToken' } | { __typename?: 'Poll' } | { __typename?: 'PollAnswer' } | { __typename?: 'PollQuestion' } | { __typename?: 'Post', id: string, type: PostType, title: string, createdAt: any, status: PostStatus, body: string, featured: boolean, insightsGeneratedAt?: any | null, commentsDisabled?: boolean | null, creditHours: number, totalComments: number, totalLikes: number, totalBookmarks: number, termsPerMinute: number, topics?: Array<{ __typename?: 'Topic', id: string, name: string }> | null, topicClassifications?: Array<{ __typename?: 'TopicClassification', id: string, modelVersion?: string | null, active: boolean, suggested: boolean, topic: { __typename?: 'Topic', id: string, name: string } }> | null, audiences?: Array<{ __typename?: 'Audience', id: string, name: string }> | null, author?: { __typename?: 'User', id: string, username?: string | null, firstName?: string | null, lastName?: string | null, hasSubmittedDisclosure: boolean, hasDisclosuresNeedingReview: boolean, reflectionsOnAuthoredPostsDisabled: boolean, npiTaxonomyCode?: string | null, npiTaxonomyDescription?: string | null, credential?: string | null, profileImage?: { __typename?: 'Image', url?: string | null } | null } | null, coverImage?: { __typename?: 'Image', id: string, url?: string | null } | null, videos?: Array<{ __typename?: 'Video', id: string, thumbnailURL?: string | null, duration?: number | null, width?: number | null, height?: number | null, hlsURL?: string | null, insightsGeneratedAt?: any | null, discussionPoints?: Array<string> | null, terms?: Array<string> | null, termFrequencies?: any | null, termsPerMinute: number, wordcloud?: string | null, alternatePlaylists: Array<{ __typename?: 'AlternatePlaylist', cdn: string, url: string }> }> | null } | { __typename?: 'PostCitation' } | { __typename?: 'PostCollection' } | { __typename?: 'PostEmbedding' } | { __typename?: 'PostLearningObjective' } | { __typename?: 'PostReaction' } | { __typename?: 'PostReport' } | { __typename?: 'Provider' } | { __typename?: 'PubmedAbstractEmbedding' } | { __typename?: 'PubmedArticle' } | { __typename?: 'PubmedArticleAbstract' } | { __typename?: 'PubmedArticleEmbedding' } | { __typename?: 'PubmedCentralArticle' } | { __typename?: 'PubmedDownloadLog' } | { __typename?: 'PubmedTopicCluster' } | { __typename?: 'ReflectionAnalysis' } | { __typename?: 'ReflectionAnalysisResult' } | { __typename?: 'ReflectionAnalysisScore' } | { __typename?: 'ReflectionCriteria' } | { __typename?: 'ReflectionCriteriaGroup' } | { __typename?: 'ReflectionExperiment' } | { __typename?: 'ReflectionExperimentRun' } | { __typename?: 'ReportReason' } | { __typename?: 'Search' } | { __typename?: 'SearchConversion' } | { __typename?: 'SparkyChat' } | { __typename?: 'SparkyChatConfig' } | { __typename?: 'SparkyChatMessage' } | { __typename?: 'SparkyConversation' } | { __typename?: 'SparkyConversationConfigSet' } | { __typename?: 'SparkyMessage' } | { __typename?: 'SparkyPrompt' } | { __typename?: 'SparkyQuery' } | { __typename?: 'SparkyRule' } | { __typename?: 'SparkyRuleCondition' } | { __typename?: 'SparkyRuleField' } | { __typename?: 'Tag' } | { __typename?: 'Tenant' } | { __typename?: 'Topic' } | { __typename?: 'TopicClassification' } | { __typename?: 'TopicCluster' } | { __typename?: 'TopicNpiTaxonomy' } | { __typename?: 'TopicPubmedTopicCluster' } | { __typename?: 'TranscriptionRequest' } | { __typename?: 'Upload' } | { __typename?: 'User' } | { __typename?: 'UserAnalyticsEvent' } | { __typename?: 'UserBlock' } | { __typename?: 'UserCohort' } | { __typename?: 'UserCollectionCompletion' } | { __typename?: 'UserFeedHistory' } | { __typename?: 'UserLink' } | { __typename?: 'UserMute' } | { __typename?: 'UserNotificationToken' } | { __typename?: 'UserReport' } | { __typename?: 'UserTenant' } | { __typename?: 'UserVideoEvent' } | { __typename?: 'VerificationRequest' } | { __typename?: 'Video' } | { __typename?: 'VideoFrame' } | { __typename?: 'VideoPipeline' } | { __typename?: 'WaitListConfig' } | { __typename?: 'WaitlistEntry' } | { __typename?: 'WorkExperience' } | null };

export type UsersQueryVariables = Exact<{
  where: UserWhereInput;
}>;


export type UsersQuery = { __typename?: 'Query', users: { __typename?: 'UserConnection', edges?: Array<{ __typename?: 'UserEdge', node?: { __typename?: 'User', id: string, firstName?: string | null, lastName?: string | null, credential?: string | null, npiTaxonomyCode?: string | null, npiTaxonomyDescription?: string | null, profileImage?: { __typename?: 'Image', id: string, url?: string | null, width?: number | null, height?: number | null } | null } | null } | null> | null } };

export type UserQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type UserQuery = { __typename?: 'Query', node?: { __typename: 'AccountConnection' } | { __typename: 'AnatomicalModel' } | { __typename: 'ApiQueryLog' } | { __typename: 'ApiToken' } | { __typename: 'Article' } | { __typename: 'ArticleFeed' } | { __typename: 'Audience' } | { __typename: 'AuditLog' } | { __typename: 'BoardCertification' } | { __typename: 'Bookmark' } | { __typename: 'Certificate' } | { __typename: 'CertificateSurveyAnswer' } | { __typename: 'CertificateSurveyQuestion' } | { __typename: 'CertificateSurveyQuestionChoice' } | { __typename: 'CertifyingBoard' } | { __typename: 'ClinicalTrial' } | { __typename: 'ClinicalTrialDocument' } | { __typename: 'ClinicalTrialEmbedding' } | { __typename: 'CloudflareUpload' } | { __typename: 'Collection' } | { __typename: 'Comment' } | { __typename: 'CommentLike' } | { __typename: 'CommentNamedEntity' } | { __typename: 'Course' } | { __typename: 'Dashboard' } | { __typename: 'EducationCredit' } | { __typename: 'EducationHistory' } | { __typename: 'EducationRequirement' } | { __typename: 'FaceDetectRequest' } | { __typename: 'FinancialDisclosure' } | { __typename: 'FinancialDisclosurePrintTemplate' } | { __typename: 'FinancialDisclosureRole' } | { __typename: 'FinancialDisclosureStatement' } | { __typename: 'GiblibVideo' } | { __typename: 'GoogleDriveFile' } | { __typename: 'GptLog' } | { __typename: 'HumanOntologyNode' } | { __typename: 'Image' } | { __typename: 'ImportedVideo' } | { __typename: 'InsightRequest' } | { __typename: 'InstagramScrapeLog' } | { __typename: 'JobHistory' } | { __typename: 'LanguageModelLog' } | { __typename: 'LanguageModelResponse' } | { __typename: 'LearningObjective' } | { __typename: 'LicenseHistory' } | { __typename: 'Like' } | { __typename: 'MediaItem' } | { __typename: 'MedicalHealthTerm' } | { __typename: 'MedicalSubjectHeading' } | { __typename: 'Notification' } | { __typename: 'NotificationConfig' } | { __typename: 'NpiTaxonomy' } | { __typename: 'Office' } | { __typename: 'PhoneVerificationToken' } | { __typename: 'Poll' } | { __typename: 'PollAnswer' } | { __typename: 'PollQuestion' } | { __typename: 'Post' } | { __typename: 'PostCitation' } | { __typename: 'PostCollection' } | { __typename: 'PostEmbedding' } | { __typename: 'PostLearningObjective' } | { __typename: 'PostReaction' } | { __typename: 'PostReport' } | { __typename: 'Provider' } | { __typename: 'PubmedAbstractEmbedding' } | { __typename: 'PubmedArticle' } | { __typename: 'PubmedArticleAbstract' } | { __typename: 'PubmedArticleEmbedding' } | { __typename: 'PubmedCentralArticle' } | { __typename: 'PubmedDownloadLog' } | { __typename: 'PubmedTopicCluster' } | { __typename: 'ReflectionAnalysis' } | { __typename: 'ReflectionAnalysisResult' } | { __typename: 'ReflectionAnalysisScore' } | { __typename: 'ReflectionCriteria' } | { __typename: 'ReflectionCriteriaGroup' } | { __typename: 'ReflectionExperiment' } | { __typename: 'ReflectionExperimentRun' } | { __typename: 'ReportReason' } | { __typename: 'Search' } | { __typename: 'SearchConversion' } | { __typename: 'SparkyChat' } | { __typename: 'SparkyChatConfig' } | { __typename: 'SparkyChatMessage' } | { __typename: 'SparkyConversation' } | { __typename: 'SparkyConversationConfigSet' } | { __typename: 'SparkyMessage' } | { __typename: 'SparkyPrompt' } | { __typename: 'SparkyQuery' } | { __typename: 'SparkyRule' } | { __typename: 'SparkyRuleCondition' } | { __typename: 'SparkyRuleField' } | { __typename: 'Tag' } | { __typename: 'Tenant' } | { __typename: 'Topic' } | { __typename: 'TopicClassification' } | { __typename: 'TopicCluster' } | { __typename: 'TopicNpiTaxonomy' } | { __typename: 'TopicPubmedTopicCluster' } | { __typename: 'TranscriptionRequest' } | { __typename: 'Upload' } | { __typename: 'User', id: string, firstName?: string | null, lastName?: string | null, credential?: string | null, npiTaxonomyCode?: string | null, npiTaxonomyDescription?: string | null, profileImage?: { __typename?: 'Image', id: string, url?: string | null, width?: number | null, height?: number | null } | null } | { __typename: 'UserAnalyticsEvent' } | { __typename: 'UserBlock' } | { __typename: 'UserCohort' } | { __typename: 'UserCollectionCompletion' } | { __typename: 'UserFeedHistory' } | { __typename: 'UserLink' } | { __typename: 'UserMute' } | { __typename: 'UserNotificationToken' } | { __typename: 'UserReport' } | { __typename: 'UserTenant' } | { __typename: 'UserVideoEvent' } | { __typename: 'VerificationRequest' } | { __typename: 'Video' } | { __typename: 'VideoFrame' } | { __typename: 'VideoPipeline' } | { __typename: 'WaitListConfig' } | { __typename: 'WaitlistEntry' } | { __typename: 'WorkExperience' } | null };

export class TypedDocumentString<TResult, TVariables>
  extends String
  implements DocumentTypeDecoration<TResult, TVariables>
{
  __apiType?: DocumentTypeDecoration<TResult, TVariables>['__apiType'];

  constructor(private value: string, public __meta__?: Record<string, any> | undefined) {
    super(value);
  }

  toString(): string & DocumentTypeDecoration<TResult, TVariables> {
    return this.value;
  }
}

export const CurrentUserDocument = new TypedDocumentString(`
    query CurrentUser {
  currentUser {
    id
    streamToken
    firstName
    lastName
  }
}
    `) as unknown as TypedDocumentString<CurrentUserQuery, CurrentUserQueryVariables>;
export const MedicalSearchDocument = new TypedDocumentString(`
    subscription MedicalSearch {
  medicalSearchResponse(token: "test-token") {
    text
    citation {
      citationKey
      referenceText
      referenceDetail {
        title
        authorsString
        publicationInfoString
        journalName
        journalShortName
        publicationDate
        doi
        url
      }
    }
  }
}
    `) as unknown as TypedDocumentString<MedicalSearchSubscription, MedicalSearchSubscriptionVariables>;
export const SparkyMessageDocument = new TypedDocumentString(`
    query SparkyMessage($id: ID!) {
  node(id: $id) {
    ... on SparkyMessage {
      conversation {
        id
      }
      notHelpful
      isHelpful
      opengraphReferences {
        title
        description
        url
        image
      }
      references {
        citationKey
        sourceTexts
        referenceText
        referenceDetail {
          doi
          url
          title
          journalName
          authorsString
          publicationDate
          publicationInfoString
        }
      }
    }
  }
}
    `) as unknown as TypedDocumentString<SparkyMessageQuery, SparkyMessageQueryVariables>;
export const SparkyMessagesDocument = new TypedDocumentString(`
    query SparkyMessages($where: SparkyMessageWhereInput!) {
  sparkyMessages(where: $where) {
    edges {
      node {
        id
        body
        notHelpful
        isHelpful
        conversation {
          id
          convertedFromModel
        }
        opengraphReferences {
          title
          description
          url
          image
        }
        references {
          citationKey
          sourceTexts
          referenceText
          referenceDetail {
            doi
            url
            title
            journalName
            authorsString
            publicationDate
            publicationInfoString
          }
        }
      }
    }
  }
}
    `) as unknown as TypedDocumentString<SparkyMessagesQuery, SparkyMessagesQueryVariables>;
export const SparkyConversationDocument = new TypedDocumentString(`
    query SparkyConversation($id: ID!) {
  node(id: $id) {
    ... on SparkyConversation {
      id
      token
      model
      createdAt
      messages {
        body
        notHelpful
        isHelpful
      }
      targetConversation {
        id
        token
      }
    }
  }
}
    `) as unknown as TypedDocumentString<SparkyConversationQuery, SparkyConversationQueryVariables>;
export const SparkyConversationsDocument = new TypedDocumentString(`
    query SparkyConversations($where: SparkyConversationWhereInput!) {
  sparkyConversations(where: $where) {
    edges {
      node {
        id
        token
        model
        createdAt
        educationCredit {
          id
        }
        messages {
          id
          body
          notHelpful
          isHelpful
          sentBySparky
        }
      }
    }
  }
}
    `) as unknown as TypedDocumentString<SparkyConversationsQuery, SparkyConversationsQueryVariables>;
export const AdminCreateConversationFromConversationDocument = new TypedDocumentString(`
    mutation AdminCreateConversationFromConversation($conversationId: ID!) {
  adminCreateConversationFromConversation(conversationId: $conversationId) {
    id
    token
  }
}
    `) as unknown as TypedDocumentString<AdminCreateConversationFromConversationMutation, AdminCreateConversationFromConversationMutationVariables>;
export const CreateConversationDocument = new TypedDocumentString(`
    mutation CreateConversation($model: ConversationModel!, $initialMessage: String) {
  createConversation(model: $model, initialMessage: $initialMessage) {
    token
  }
}
    `) as unknown as TypedDocumentString<CreateConversationMutation, CreateConversationMutationVariables>;
export const ReflectOnConversationDocument = new TypedDocumentString(`
    mutation ReflectOnConversation($conversationId: ID!) {
  reflectOnConversation(conversationId: $conversationId) {
    id
  }
}
    `) as unknown as TypedDocumentString<ReflectOnConversationMutation, ReflectOnConversationMutationVariables>;
export const FlagMessageNotHelpfulDocument = new TypedDocumentString(`
    mutation FlagMessageNotHelpful($messageId: ID!) {
  flagMessageNotHelpful(messageId: $messageId)
}
    `) as unknown as TypedDocumentString<FlagMessageNotHelpfulMutation, FlagMessageNotHelpfulMutationVariables>;
export const FlagMessageHelpfulDocument = new TypedDocumentString(`
    mutation FlagMessageHelpful($messageId: ID!) {
  flagMessageHelpful(messageId: $messageId)
}
    `) as unknown as TypedDocumentString<FlagMessageHelpfulMutation, FlagMessageHelpfulMutationVariables>;
export const PostDocument = new TypedDocumentString(`
    query Post($id: ID!) {
  node(id: $id) {
    ... on Post {
      id
      type
      title
      createdAt
      status
      body
      featured
      insightsGeneratedAt
      commentsDisabled
      creditHours
      topics {
        id
        name
      }
      topicClassifications {
        id
        modelVersion
        topic {
          id
          name
        }
        active
        suggested
      }
      audiences {
        id
        name
      }
      totalComments
      totalLikes
      totalBookmarks
      termsPerMinute
      author {
        id
        username
        firstName
        lastName
        username
        hasSubmittedDisclosure
        hasDisclosuresNeedingReview
        reflectionsOnAuthoredPostsDisabled
        npiTaxonomyCode
        npiTaxonomyDescription
        credential
        profileImage {
          url
        }
      }
      coverImage {
        id
        url
      }
      videos {
        id
        thumbnailURL
        alternatePlaylists {
          cdn
          url
        }
        duration
        width
        height
        hlsURL
        insightsGeneratedAt
        discussionPoints
        terms
        termFrequencies
        termsPerMinute
        wordcloud
      }
    }
  }
}
    `) as unknown as TypedDocumentString<PostQuery, PostQueryVariables>;
export const UsersDocument = new TypedDocumentString(`
    query Users($where: UserWhereInput!) {
  users(where: $where) {
    edges {
      node {
        id
        firstName
        lastName
        credential
        npiTaxonomyCode
        npiTaxonomyDescription
        profileImage {
          id
          url
          width
          height
        }
      }
    }
  }
}
    `) as unknown as TypedDocumentString<UsersQuery, UsersQueryVariables>;
export const UserDocument = new TypedDocumentString(`
    query User($id: ID!) {
  node(id: $id) {
    __typename
    ... on User {
      id
      firstName
      lastName
      credential
      npiTaxonomyCode
      npiTaxonomyDescription
      profileImage {
        id
        url
        width
        height
      }
    }
  }
}
    `) as unknown as TypedDocumentString<UserQuery, UserQueryVariables>;